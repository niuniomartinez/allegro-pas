<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="Allegro dot pas">
<short>Allegro.pas is a wrapper to use the Allegro library with Pascal compilers.</short>

<!--
  ====================================================================
    Standard config variables
  ====================================================================
-->

<topic name="standard_config_variables">
<short>Description of Allegro's standard config variables</short>
<descr>
	<pre>Allegro uses these standard variables from the configuration file:

    * [system]
      Section containing general purpose variables:
          o system = x
	    Specifies which system driver to use. This is currently only useful
	    on Linux, for choosing between the XWindows ("XWIN") or console
	    ("LNXC") modes.
          o keyboard = x
	    Specifies which keyboard layout to use. The parameter is the name
	    of a keyboard mapping file produced by the keyconf utility, and can
	    either be a fully qualified file path or a basename like `us' or
	    `uk'. If the latter, Allegro will look first for a separate config
	    file with that name (eg. `uk.cfg') and then for an object with that
	    name in the `keyboard.dat' file (eg. `UK_CFG'). The config file or
	    `keyboard.dat' file can be stored in the same directory as the
	    program, or in the location pointed to by the ALLEGRO environment
	    variable. Look in the `keyboard.dat' file to see what mappings are
	    currently available.
          o language = x
	    Specifies which language file to use for error messages and other
	    bits of system text. The parameter is the name of a translation
	    file, and can either be a fully qualified file path or a basename
	    like `en' or `es'. If the latter, Allegro will look first for a
	    separate config file with a name in the form `entext.cfg', and then
	    for an object with that name in the `language.dat' file (eg.
	    `ENTEXT_CFG'). The config file or `language.dat' file can be stored
	    in the same directory as the program, or in the location pointed to
	    by the ALLEGRO environment variable. Look in the `language.dat'
	    file to see which mappings are currently available. If there is
	    none for your language, you can create it using the English one as
	    model, and even send it to the Allegro development team to include
	    it in future releases.
          o disable_screensaver = x
	    Specifies whether to disable the screensaver: 0 to never disable
	    it, 1 to disable it in fullscreen mode only and 2 to always disable
	    it. Default is 1.
          o menu_opening_delay = x
	    Sets how long the menus take to auto-open. The time is given in
	    milliseconds (default is `300'). Specifying `-1' will disable the
	    auto-opening feature.
          o XInitThreads = x
	    If this is set to 0, the X11 port will not call XInitThreads. This
	    can have slight performance advantages and was required on some
	    broken X11 servers, but it makes Allegro incompatible with other
	    X11 libraries like Mesa. 
    * [graphics]
      Section containing graphics configuration information, using the
      variables:
          o gfx_card = x
	    Specifies which graphics driver to use when the program requests
	    GFX_AUTODETECT. Multiple possible drivers can be suggested with
	    extra lines in the form `gfx_card1 = x', `gfx_card2 = x', etc, or
	    you can specify different drivers for each mode and color depth
	    with variables in the form `gfx_card_24bpp = x',
	    `gfx_card_640x480x16 = x', etc.
          o gfx_cardw = x
	    Specifies which graphics driver to use when the program requests
	    GFX_AUTODETECT_WINDOWED. This variable functions exactly like
	    gfx_card in all other respects. If it is not set, Allegro will
	    look for the gfx_card variable.
          o disable_vsync = x
	    Specifies whether to disable synchronization with the vertical
	    blank when page-flipping (yes or no). Disabling synchronization may
	    increase the frame rate on slow systems, at the expense of
	    introducing flicker on fast systems.
          o vbeaf_driver = x
	    DOS and Linux only: specifies where to look for the VBE/AF driver
	    (vbeaf.drv). If this variable is not set, Allegro will look in the
	    same directory as the program, and then fall back on the standard
	    locations (`c:\' for DOS, `/usr/local/lib', `/usr/lib', `/lib', and
	    `/' for Linux, or the directory specified with the VBEAF_PATH
	    environment variable).
          o framebuffer = x
	    Linux only: specifies what device file to use for the fbcon driver.
	    If this variable is not set, Allegro checks the FRAMEBUFFER
	    environment variable, and then defaults to `/dev/fb0'.
          o force_centering = x
	    Unix/X11 only: specifies whether to force window centering in
	    fullscreen mode when the XWFS driver is used (yes or no). Enabling
	    this setting may cause some artifacts to appear on KDE desktops.
          o disable_direct_updating = x
	    Windows only: specifies whether to disable direct updating when the
	    GFX_DIRECTX_WIN driver is used in color conversion mode (yes or
	    no). Direct updating can cause artifacts to be left on the desktop
	    when the window is moved or minimized; disabling it results in a
	    significant performance loss. 
    * [mouse]
      Section containing mouse configuration information, using the variables:
          o mouse = x
            Mouse driver type. Available DOS drivers are:

                      MICK - mickey mode driver (normally the best)
                      I33  - int 0x33 callback driver
                      POLL - timer polling (for use under NT)

            Linux console mouse drivers are:

                      MS   - Microsoft serial mouse
                      IMS  - Microsoft serial mouse with Intellimouse extension
                      LPS2 - PS2 mouse
                      LIPS - PS2 mouse with Intellimouse extension
                      GPMD - GPM repeater data (Mouse Systems protocol)
                      EV   - Event interfaces (EVDEV)

          o num_buttons = x
	    Sets the number of mouse buttons viewed by Allegro. You don't
	    normally need to set this variable because Allegro will autodetect
	    it. You can only use it to restrict the set of actual mouse buttons
	    to zero or positive values, negative values will be ignored.
          o emulate_three = x
	    Sets whether to emulate a third mouse button by detecting chords of
	    the left and right buttons (yes or no). Defaults to no.
          o mouse_device = x
	    Linux only: specifies the name of the mouse device file
	    (eg. `/dev/mouse').
          o ev_absolute = x
	    Linux only: specifies the mode for the default EV input:
	    0 - relative mode: pointer position changes if the input moves,
	    1 - absolute mode: pointer position is the input position. If
	    unspecified, the mode is relative. If the device supports several
	    tools (such as a graphic tablet), the default input is the mouse.
	    If the device has only one tool (e.g. a normal mouse) the default
	    input is this tool. All additionnal tools work in absolute mode.
          o ev_min_x = x
            ev_max_x = x
            ev_min_y = x
            ev_max_y = x
            ev_min_z = x
            ev_max_z = x
	    Linux only: for absolute EV inputs, minimum and maximum value. By
	    default this information is autodetected. If you want to use only
	    part of a tablet, you need to set the entries for X and Y axis by
	    hand.
          o ev_abs_to_rel_x = x
            ev_abs_to_rel_y = x
            ev_abs_to_rel_z = x
	    Linux only: scaling factor for tablet mouse speed. Defaults to 1.
	    This is used only when the input sends absolute events (tablet,
	    joystick, etc.) and the cursor should behave like a mouse. If you
	    are using a mouse on a tablet, you need to set these entries for X
	    and Y axis (try numbers between 1 and 40).
          o mouse_accel_factor = x
	    Windows only: specifies the mouse acceleration factor. Defaults to
	    1. Set it to 0 in order to disable mouse acceleration. 
	    2 accelerates twice as much as 1. 
    * [sound]
      Section containing sound configuration information, using the variables:
          o digi_card = x
            Sets the driver to use for playing digital samples.
          o midi_card = x
            Sets the driver to use for MIDI music.
          o digi_input_card = x
            Sets the driver to use for digital sample input.
          o midi_input_card = x
            Sets the driver to use for MIDI data input.
          o digi_voices = x
	    Specifies the minimum number of voices to reserve for use by the
	    digital sound driver. How many are possible depends on the driver.
          o midi_voices = x
	    Specifies the minimum number of voices to reserve for use by the
	    MIDI sound driver. How many are possible depends on the driver.
          o digi_volume = x
            Sets the volume for digital sample playback, from 0 to 255.
          o midi_volume = x
            Sets the volume for midi music playback, from 0 to 255.
          o quality = x
	    Controls the sound quality vs. performance tradeoff for the sample
	    mixing code. This can be set to any of the values:

                      0 - fast mixing of 8-bit data into 16-bit buffers
                      1 - true 16-bit mixing (requires a 16-bit stereo soundcard)
                      2 - interpolated 16-bit mixing

          o flip_pan = x
	    Toggling this between 0 and 1 reverses the left/right panning of
	    samples, which might be needed because some SB cards get the stereo
	    image the wrong way round.
          o sound_freq = x
	    DOS, Unix and BeOS: sets the sample frequency. With the SB driver,
	    possible rates are 11906 (any), 16129 (any), 22727 (SB 2.0 and
	    above), and 45454 (only on SB 2.0 or SB16, not the stereo SB Pro
	    driver). On the ESS Audiodrive, possible rates are 11363, 17046,
	    22729, or 44194. On the Ensoniq Soundscape, possible rates are
	    11025, 16000, 22050, or 48000. On the Windows Sound System,
	    possible rates are 11025, 22050, 44100, or 48000. Don't worry if
	    you set some other number by mistake: Allegro will automatically
	    round it to the closest supported frequency.
          o sound_bits = x
            Unix and BeOS: sets the preferred number of bits (8 or 16).
          o sound_stereo = x
            Unix and BeOS: selects mono or stereo output (0 or 1).
          o sound_port = x
            DOS only: sets the soundcard port address (this is usually 220).
          o sound_dma = x
            DOS only: sets the soundcard DMA channel (this is usually 1).
          o sound_irq = x
            DOS only: sets the soundcard IRQ number (this is usually 7).
          o fm_port = x
	    DOS only: sets the port address of the OPL synth (this is usually
	    388).
          o mpu_port = x
	    DOS only: sets the port address of the MPU-401 MIDI interface (this
	    is usually 330).
          o mpu_irq = x
	    DOS only: sets the IRQ for the MPU-401 (this is usually the same as
	    sound_irq).
          o ibk_file = x
	    DOS only: specifies the name of a .IBK file which will be used to
	    replace the standard Adlib patch set.
          o ibk_drum_file = x
	    DOS only: specifies the name of a .IBK file which will be used to
	    replace the standard set of Adlib percussion patches.
          o oss_driver = x
	    Unix only: sets the OSS device driver name. Usually `/dev/dsp' or
	    `/dev/audio', but could be a particular device (e.g. `/dev/dsp2').
          o oss_numfrags = x
            oss_fragsize = x
	    Unix only: sets number of OSS driver fragments (buffers) and size
	    of each buffer in samples. Buffers are filled with data in the
	    interrupts where interval between subsequent interrupts is not less
	    than 10 ms. If hardware can play all information from buffers
	    faster than 10 ms, then there will be clicks, when hardware have
	    played all data and library has not prepared new data yet. On the
	    other hand, if it takes too long for device driver to play data
	    from all buffers, then there will be delays between action which
	    triggers sound and sound itself.
          o oss_midi_driver = x
            Unix only: sets the OSS MIDI device name. Usually `/dev/sequencer'.
          o oss_mixer_driver = x
            Unix only: sets the OSS mixer device name. Usually `/dev/mixer'.
          o esd_server = x
            Unix only: where to find the ESD (Enlightened Sound Daemon) server.
          o alsa_card = x
            alsa_pcmdevice = x
            Unix only: card number and PCM device for the ALSA 0.5 sound driver.
          o alsa_device = x
	    Unix only: device name for the ALSA 0.9 sound driver. The format is
	    &lt;driver&gt;[:&lt;card&gt;,&lt;device&gt;], for example: `hw:0,1'.
          o alsa_mixer_device = x
	    Unix only: mixer device name for the ALSA 0.9 sound driver. The
	    default is "default".
          o alsa_mixer_elem = x
	    Unix only: mixer element name for the ALSA 0.9 driver. The default
	    is PCM.
          o alsa_numfrags = x
            Unix only: number of ALSA driver fragments (buffers).
          o alsa_fragsize = x
            Unix only: size of each ALSA fragment, in samples.
          o alsa_rawmidi_card = x
            Unix only: card number and device for the ALSA 0.5 midi driver.
          o alsa_rawmidi_device = x
	    Unix only: device for the ALSA 0.5 midi driver or device name for
	    the ALSA 0.9 midi driver (see alsa_device for the format).
          o jack_client_name = x
	    Sets the name with which Allegro should identify itself to the Jack
	    audio server.
          o jack_buffer_size = x
	    Forces a buffer size for the transfer buffer from Allegro's mixer
	    to Jack.
          o be_midi_quality = x
	    BeOS only: system MIDI synthesizer instruments quality. 0 uses low
	    quality 8-bit 11 kHz samples, 1 uses 16-bit 22 kHz samples.
          o be_midi_freq = x
	    BeOS only: MIDI sample mixing frequency in Hz. Can be 11025, 22050
	    or 44100.
          o be_midi_interpolation = x
	    BeOS only: specifies the MIDI samples interpolation method. 0
	    doesn't interpolate, it's fast but has the worst quality; 1 does a
	    fast interpolation with better performances, but it's a bit slower
	    than the previous method; 2 does a linear interpolation between
	    samples, it is the slowest method but gives the best performances.
          o be_midi_reverb = x
	    BeOS only: reverberation intensity, from 0 to 5. 0 disables it, 5
	    is the strongest one.
          o ca_midi_quality = x
	    MacOS X only: CoreAudio MIDI synthesizer rendering quality, from 0
	    to 127. Higher qualities sound better but increase the CPU work
	    load.
          o ca_midi_reverb = x
	    MacOS X only: CoreAudio MIDI synthesizer reverberation intensity,
	    from 0 to 5. 0 equals to a small room (low reverb), 5 to a plate
	    (high reverb).
          o patches = x
	    Specifies where to find the sample set for the DIGMID driver. This
	    can either be a Gravis style directory containing a collection of
	    .pat files and a `default.cfg' index, or an Allegro datafile
	    produced by the pat2dat utility. If this variable is not set,
	    Allegro will look either for a `default.cfg' or `patches.dat' file
	    in the same directory as the program, the directory pointed to by
	    the ALLEGRO environment variable, and the standard GUS directory
	    pointed to by the ULTRASND environment variable. 
    * [midimap]
      If you are using the SB MIDI output or MPU-401 drivers with an external
      synthesiser that is not General MIDI compatible, you can use the midimap
      section of the config file to specify a patch mapping table for
      converting GM patch numbers into whatever bank and program change
      messages will select the appropriate sound on your synth. This is a real
      piece of self-indulgence. I have a Yamaha TG500, which has some great
      sounds but no GM patch set, and I just had to make it work somehow...
      This section consists of a set of lines in the form:
          o p&lt;n&gt; = bank0 bank1 prog pitch
	    With this statement, n is the GM program change number (1-128),
	    bank0 and bank1 are the two bank change messages to send to your
	    synth (on controllers #0 and #32), prog is the program change
	    message to send to your synth, and pitch is the number of semitones
	    to shift everything that is played with that sound. Setting the
	    bank change numbers to -1 will prevent them from being sent. For
	    example, the line:

                      p36 = 0 34 9 12

	    specifies that whenever GM program 36 (which happens to be a
	    fretless bass) is selected, Allegro should send a bank change
	    message #0 with a parameter of 0, a bank change message #32 with a
	    parameter of 34, a program change with a parameter of 9, and then
	    should shift everything up by an octave. 
    * [joystick]
      Section containing joystick configuration information, using the
      variables:
          o joytype = x
	    Specifies which joystick driver to use when the program requests
	    JOY_TYPE_AUTODETECT.
          o joystick_device = x
	    BeOS and Linux only: specifies the name of the joystick device to
	    be used (as reported in the system joystick preferences under
	    BeOS). The first device found is used by default. If you want to
	    specify the device for each joystick, use variables of the form
	    joystick_device_n, where n is the joystick number.
          o throttle_axis = x
	    Linux only: sets the axis number the throttle is located at. This
	    variable will be used for every detected joystick. If you want to
	    specify the axis number for each joystick individually, use
	    variables of the form throttle_axis_n, where n is the joystick
	    number.</pre>
</descr>
</topic>

<!--
  ====================================================================
    License
  ====================================================================
-->

<topic name="license">
<short>The giftware license</short>
<descr>	
	<p>Allegro.pas is gift-ware. It was created by a number of people working in cooperation, and is given to you freely as a gift. You may use, modify, redistribute, and generally hack it about in any way you like, and you do not have to give us anything in return.</p>
	<p>However, if you like this product you are encouraged to thank us by making a return gift to the Allegro.pas community. This could be by writing an add-on package, providing a useful bug report, making an improvement to the library, or perhaps just releasing the sources of your program so that other people can learn from them. If you redistribute parts of this code or make a game using it, it would be nice if you mentioned Allegro and/or Allegro.pas somewhere in the credits, but you are not required to do this. We trust you not to abuse our generosity.</p>
	<dl>
		<dt>Disclaimer</dt>
		<dd>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</dd>
	</dl>
</descr>
</topic>

<!--
  ====================================================================
    Help
  ====================================================================
-->

<topic name="help">
<short>What to do when your Allegro program doesn't work.</short>
<descr>
	<p>When things go wrong, it often seems like a good idea to ask other people for help. Fortunately for people in this situation, there are many people (both developers and users) who are happy to spend their time answering support questions of this type, but there are various things you can do to make this process work more efficiently. This document describes some steps to take whenever you have a problem with an Allegro.pas program, suggesting ways that you can try to solve it yourself, and also giving some tips about when/how to ask for help. Following these guidelines will make life easier both for the helper (because all the relevant information will be presented to them in a concise and useful way), and for the helped (because they are more likely to get a prompt and accurate reply).</p>
	<p><b>Part 1 - who is the culprit?</b></p>
	<p>Is the problem a bug in Allegro, Allegro.pas (remember: they're two different libraries), or in your code? To find out, try running the Allegro test programs, in particular the test.exe (for graphics related problems), the play.exe (for soundcard troubles), and the entire contents of the examples directory (both Allegro and Allegro.pas, for anything that is going wrong). If you can't reproduce the problem with any of these, it is probably your fault, in which case you should skip to part 3 below.</p>
	<p><b>Part 2 - when Allegro.pas (or Allegro) is at fault</b></p>
	<p>If you think the problem lies with Allegro.pas, post a system report containing a description of the problem, what platform and library version you are using, your hardware specs, and a list of exactly which programs you were able to reproduce the problem with (it is important to know not only what programs had trouble, but also which ones worked correctly, if any).</p>
	<p>Try running the test.exe program (of Allegro) with various display drivers (any native drivers that you think might work with your card), and in various video modes, and report exactly what modes and color depths cause problems. If you are able to use any high resolutions at all, run test.exe with the Autodetect option and report the entire text that it displays in the middle of the screen.</p>
	<p>If the problem is related to the sound system, try using the setup program to manually configure your card. You may need to manually enter the hardware parameters, and if it is an SB clone card, try selecting some earlier breed of SB card than whatever it is autodetecting (SB Pro, SB 2.0, or SB 1.0). If you are still unable to get anything working, your post should include the name and descriptions of whatever digital and MIDI sound drivers are being autodetected (this information is displayed by the play.exe program).</p>
	<p><b>Part 3 - things people don't do (but should)</b></p>
	<p>One of the most common errors made by programmers is to neglect to check the return value from a function that may fail. Such an error will often lead to unexpected and downright unusual errors, making for a debugging nightmare. There are many functions in and out of Allegro that may or may not work depending on varying circumstances. They are, however, nice enough to let you know whether or not they were successful through documented return values.</p>
	<p>Whenever you call a function that might fail (most importantly <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>, <link id="alsound.al_install_sound">al_install_sound</link>, and anything that loads data from the disk), it is essential that you check the return code from this, and respond accordingly.</p>
	<!-- p>Another commonly forgotten but important tool is to use whatever option enables strict warnings for your compiler (gcc uses -Wall), when compiling your code. Any warnings reported by this option will almost certainly represent errors in your program, and should be fixed before doing anything else. When using gcc, a useful trick is to compile with the -O setting as well, because this causes gcc to examine the program's actions in more detail, enabling more useful warnings. You should normally disable optimisation while debugging, though. Although it gives better compile time warnings, it is likely to upset any debugging tools that you later try to use.</p -->
	<p><b>Part 4 - asking for help</b></p>
	<p>Ok, so you've tried everything described above, and your program still doesn't work. You have no idea what to do next, so it is time to cast yourself unto the mercies of the net, in hopes of finding some kind of wise man, seer, or oracle that holds an answer for your question...</p>
	<p>There are several sites to ask in the Internet:</p>
	<ul>
		<li><b>http://sourceforge.net/forum/forum.php?forum_id=644249:</b> The official help forum.</li>
		<li><b>http://www.pascalgamedevelopment.com/:</b> Pascal game development forum.</li>
		<li><b>http://www.allegro.cc/:</b> Allegro community forum.</li>
	</ul>
	<p>In accordance with proper netiquette, it is assumed that when you post to any forum on the Internet you have at least consulted the relevant documentation first, if not read it in its entirety. If the problem you are having is worth asking hundreds of people the answer for, then it is certainly worth taking a few minutes to try to solve the problem yourself. Allegro is extensively and painstakingly documented and it is considered a prerequisite to posting that you have not only read the text, but examined the example programs as well.</p>
	<p><b>Part 5 - learn from my mistakes</b></p>
	<p>What not to do, Part One:</p>
	<p><i>"My program crashes. Please tell me why."</i></p>
	<p>Yes, people really do sometimes send me questions like this :-) (I know, I copyed this directly from the original Allegro documentation, but I've received this too :-O) Despite years of practice I am still totally unable to read minds, so this is a very pointless thing to ask. In order to get help with a problem you must describe it in enough detail that other people will be able to understand and reproduce it: this usually means posting some of your source code.</p>
	<p>What not to do, Part Two:</p>
	<p><i>"I've got a problem with my program. I'm attaching a 500k zip file containing ten thousand lines of source code and all the graphics and sound data: can you please debug it and tell me what the trouble is?"</i></p>
	<p>After wasting the time and phone bills to download such a huge file, it is unlikely that anyone will even _want_ to help you, let alone invest the amount of time it would take to read and understand such a huge mess of information. You must try to isolate a smaller chunk of code that demonstrates the trouble: the smaller you can make it, the more chance that someone will be able to help you with it. Remember that you are asking other people to do you a favour, so it is your responsibility to make this process as easy for them as you possibly can.</p>
	<p><b>Part 6 - a model of perfection</b></p>
	<p>For reference, here is an example of what I would consider to be an ideal problem report:</p>
	<pre>I'm having some trouble using the hicolor video modes in my program, 
although they work fine with the Allegro tests. I'm using Allegro 4.2.1 
with MinGW 3.1.0 (gcc version 3.3.1) and Allegro.pas 4.2.3 with
FreePascal 2.0 on a Pentium 1.2GHz, running under Windows 2000 and an
ATi Radeon 7000 videocard.

This program is supposed to select a 640x480 16 bit resolution, draw a 
blue rectangle near the top left corner of the screen, and then wait for 
a keypress before quitting, but I just get a General Protection Fault 
when I run it.

I compile it using "fpc t.dpr", and don't get any warnings.

--- cut here, t.dpr ---

USES
  albitmap, alkeybrd, algraph, aldraw;

VAR
  bmp: AL_BITMAPptr;
BEGIN
  bmp := al_screen;

  al_install_keyboard;

  IF al_set_gfx_mode (AL_GFX_AUTODETECT, 640, 480, 0, 0) &lt;&gt; 0 THEN
  BEGIN
    WriteLN ('Error setting video mode');
    EXIT;
  END;

  al_set_color_depth (16);

{ crashes during this rectangle call! }
  al_rectfill (bmp, 32, 32, 64, 64, 0x001F);

  al_readkey;
END;</pre>
</descr>
</topic>

<!--
  ====================================================================
    Examples
  ====================================================================
-->

<topic name="examples">
<short>Examples</short>
<descr>
	<p>Most these examples were translated from the examples of the Allegro library.</p>
	<ul>
		<li><b>exblend.dpr:</b> How to use the translucency functions in truecolor video modes.</li>
		<li><b>excolmap.dpr:</b> Creating graphical effects with color mapping tables.</li>
		<li><b>exdata.dpr:</b> Appending datafiles onto your executable.</li>
		<li><b>exdbuf.dpr:</b> How to use double buffering to avoid flicker.</li>
		<li><b>exfixed.dpr:</b> Using fixed point maths.</li>
		<li><b>exhello.dpr:</b> Simple graphical "hello world" program.</li>
		<li><b>exhsvrgb.dpr:</b> Translating HSV space -> RGB values. </li>
		<li><b>exmouse.dpr:</b> Getting input from the mouse.</li>
		<li><b>expal.dpr:</b> Palette effects and color cycling.</li>
		<li><b>expat.dpr:</b> Using patterned drawing modes and sub-bitmaps.</li>
		<li><b>exsprite.dpr:</b> Datafiles access and sprite animation.</li>
		<li><b>extrans.dpr:</b> Lighting and translucency effects.</li>
		<li><b>extruec.dpr:</b> Truecolor pixel format conversions.</li>
	</ul>
</descr>
</topic>

<!--
  ====================================================================
    Makefile targets
  ====================================================================
-->

<topic name="makefile">
<short>Makefile targets</short>
<descr>
	<p>If you only want to recompile a specific test program or utility, you can specify it as an argument to make, eg. "make lib" or "make examples". The makefiles also provide some special pseudo-targets:</p>
	<ul>
		<li><b>all:</b> Compiles the library and builds the example programs.</li>
		<li><b>lib:</b> Compiles the library, building the DLL file. You'll need the MingW32 compiler.</li>
		<li><b>examples:</b> Builds the example programs.</li>
		<li><b>tools</b> Builds the tools.</li>
		<li><b>demo:</b> Builds the demo game.</li>
		<li><b>status:</b> Dumps information about the build configuration.</li>
		<li><b>clean:</b> Delete all temporary files.</li>
		<li><b>veryclean:</b> Deletes all binary files, objects and temporary files.</li>
		<li><b>help:</b> Shows all options. Note that some of them are not avaiable in the current version.</li>
	</ul>
	<p>In the docs directory you'll find another makefile. It's used to build the documentation. You can use it if you want to translate the documentation to another languaje. It uses the fpdoc utility.</p>
</descr>
</topic>

<!--
  ====================================================================
    al256tra
  ====================================================================
-->

<module name="al256tra">
<short>Tranparency for 8 bit graphic modes.</short>
<descr>
	<p>In paletted video modes, translucency and lighting are implemented with a 64k lookup table, which contains the result of combining any two colors c1 and c2. You must set up this table before you use any of the translucency or lighting routines. Depending on how you construct the table, a range of different effects are possible. For example, translucency can be implemented by using a color halfway between c1 and c2 as the result of the combination. Lighting is achieved by treating one of the colors as a light level (0-255) rather than a color, and setting up the table appropriately. A range of specialised effects are possible, for instance replacing any color with any other color and making individual source or destination colors completely solid or invisible. Color mapping tables can be precalculated with the colormap utility, or generated at runtime.</p>
</descr>

<!-- pointer type Visibility: default -->
<element name="AL_COLOR_MAPptr">
	<short>Pointer to <link id="AL_COLOR_MAP" />.</short>
<seealso>
	<link id="al_create_color_table" />
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="AL_COLOR_MAP">
<short>Color map.</short>
<descr>
	<p>Read <link id="al256tra">8 bit transparency overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al256tra">8 bit transparency overview</link><link id="al_set_color_map" />
	<link id="al_create_color_table" />
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="AL_256_BLEND_PROC">
	<short>Pointer to a procedure to be used by <link id="al_create_color_table" />.</short>
<descr>
	<p>A procedure with the form:</p>
	<code>PROCEDURE blend (pal: AL_PALETTE; x, y: AL_INTEGER; rgb: AL_RGB_PTR);</code>
	<p>Read <link id="al_create_color_table" /> for more information.</p>
</descr>
<seealso>
	<link id="al_create_color_table" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_create_trans_table">
<short>Fills the specified color mapping table with lookup data for doing translucency effects with the specified palette</short>
<descr>
	<p>Fills the specified color mapping table with lookup data for doing translucency effects with the specified palette. When combining the colors c1 and c2 with this table, the result will be a color somewhere between the two. The r, g, and b parameters specify the solidity of each color component, ranging from 0 (totally transparent) to 255 (totally solid). For 50% solidity, pass 128.</p>
	<p>This function treats source color #0 as a special case, leaving the destination unchanged whenever a zero source pixel is encountered, so that masked sprites will draw correctly. This function will take advantage of the global rgb_map variable to speed up color conversions. If the callback function is not NIL, it will be called 256 times during the calculation, allowing you to display a progress indicator. Example:</p>
	<code>VAR
  trans_table: AL_COLOR_MAP;
  pal: AL_PALETTE;
  ...
{ Build a color lookup table for translucent drawing. }
  al_create_trans_table (@trans_table, pal, 128, 128, 128, NIL);</code>
</descr>
<seealso>
	<link id="al_create_light_table" />
	<link id="al_create_color_table" />
	<link id="al_create_blender_table" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="alpalete.al_set_rgb_map">al_set_rgb_map</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.table">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_trans_table.callback">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_create_light_table">
<short>Fills the specified color mapping table with lookup data for doing lighting effects with the specified palette.</short>
<descr>
	<p>Fills the specified color mapping table with lookup data for doing lighting effects with the specified palette. When combining the colors c1 and c2 with this table, c1 is treated as a light level from 0-255. At light level 255 the table will output color c2 unchanged, at light level 0 it will output the r, g, b value you specify to this function, and at intermediate light levels it will output a color somewhere between the two extremes. The r, g, and b values are in the range 0-63.</p>
	<p>This function will take advantage of the global rgb_ap variable to speed up color conversions. If the callback function is not NIL, it will be called 256 times during the calculation, allowing you to display a progress indicator. Example:</p>
	<code>VAR
  light_table: AL_COLOR_MAP;
  pal: AL_PALETTE;
  ...
{ Build a color lookup table for translucent drawing. }
  al_create_light_table (@light_table, pal, 128, 128, 128, NIL);</code>
</descr>
<seealso>
	<link id="al_create_trans_table" />
	<link id="al_create_color_table" />
	<link id="al_create_blender_table" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="alpalete.al_set_rgb_map">al_set_rgb_map</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.table">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_light_table.callback">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_create_color_table">
<short>Fills the specified color mapping table with lookup data for doing customised effects with the specified palette.</short>
<descr>
	<p>Fills the specified color mapping table with lookup data for doing customised effects with the specified palette, calling the blend function to determine the results of each color combination.</p>
	<p>Your blend routine will be passed a pointer to the palette and the two indices of the colors which are to be combined, and should fill in the RGB structure with the desired result in 0-63 format. Allegro will then search the palette for the closest match to the RGB color that you requested, so it doesn't matter if the palette has no exact match for this color.</p>
	<p>If the callback function is not NIL, it will be called 256 times during the calculation, allowing you to display a progress indicator. Example:</p>
	<code>VAR
  COLOR_MAP greyscale_table;
  ...

PROCEDURE return_grey_color (pal: AL_PALETTE; x, y: AL_INT; rgb: AL_RGBptr);
BEGIN
  ...
END;

  ...
{ Build a color lookup table for greyscale effect. }
  al_create_color_table (@greyscale_table, pal, @return_grey_color, NIL);</code>
</descr>
<seealso>
	<link id="al_create_trans_table" />
	<link id="al_create_light_table" />
	<link id="al_create_blender_table" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="alpalete.al_set_rgb_map">al_set_rgb_map</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_create_color_table.table">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_color_table.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_color_table.blend">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_color_table.callback">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_create_blender_table">
<short>Fills the specified color mapping table with lookup data for doing a paletted equivalent of whatever truecolor blender mode is currently selected.</short>
<descr>
	<p>Fills the specified color mapping table with lookup data for doing a paletted equivalent of whatever truecolor blender mode is currently selected. After calling <link id="altrutra.al_set_trans_blender">al_set_trans_blender</link>, <link id="altrutra.al_set_blender_mode">al_set_blender_mode</link>, or any of the other <link id="altrutra">truecolor blender mode routines</link>, you can use this function to create an 8-bit mapping table that will have the same results as whatever 24-bit blending mode you have enabled.</p>
</descr>
<seealso>
	<link id="al_create_trans_table" />
	<link id="al_create_light_table" />
	<link id="al_create_color_table" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="alpalete.al_set_rgb_map">al_set_rgb_map</link>
	<link id="altrutra">truecolor blender mode routines</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_create_blender_table.table">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_blender_table.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_blender_table.callback">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_color_map">
<short>Sets the global color mapping table.</short>
<descr>
	<p>Sets the global color mapping table. You must allocate your own <link id="AL_COLOR_MAP" /> either statically or dynamically and call al_set_color_map to it before using any translucent or lit drawing functions in a 256-color video mode!</p>
</descr>
<seealso>
	<link id="al_create_trans_table" />
	<link id="al_create_light_table" />
	<link id="al_create_color_table" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="albltspr.al_draw_lit_sprite">al_draw_lit_sprite</link>
	<link id="alpalete.al_set_rgb_map">al_set_rgb_map</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_map.color_map">
<short></short>
</element>

</module> <!-- al256tra -->


<!--
  ====================================================================
    albase
  ====================================================================
-->

<module name="albase">
<short>Basic declarations to interface with Allegro.</short>
<descr>
 <p>This unit defines some constants and data types to inerface with the Allegro's dynamic library..</p>
</descr>

<!-- constant Visibility: default -->
<element name="ALLEGRO_SHARED_LIBRARY_NAME">
<short>Name of the Allegro's dynamic library file.</short>
</element>

<!-- constant Visibility: default -->
<element name="ALL_PAS_SHARED_LIBRARY_NAME">
<short>Name of the Allegro.pas's dynamic library file.</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_UNKNOWN_SIZE">
<short>FOR INTERNAL USE</short>
<descr>
	<p>Avoids a compilation warning when using unknown sized arrays.</p>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_PTR">
<short>Generic pointer.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_CHARptr">
<short>Pointer to an <link id="AL_CHAR" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_UCHARptr">
<short>Pointer to an <link id="AL_UCHAR" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_INTptr">
<short>Pointer to an <link id="AL_INT" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_LONGptr">
<short>Pointer to an <link id="AL_LONG" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_ULONGptr">
<short>Pointer to an <link id="AL_ULONG" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_FLOATptr">
<short>Pointer to an <link id="AL_FLOAT" /> object.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_STRINGptr">
<short>Pointer to an <link id="AL_STRING" /> object.</short>
</element>

<!-- alias type Visibility: default -->
<element name="AL_CHAR">
<short>Character.</short>
<descr>
 <p>8 bit character. Allows values between -128 and 127.</p>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_UCHAR">
<short>Unsigned character.</short>
<descr>
 <p>Unsigned 8 bit character. Allows values between 0 and 255.</p>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_INT">
<short>Integer.</short>
<descr>
 <p>Integer. It is a 32 bit value.</p>
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_LONG">
<short>Long integer.</short>
<descr>
 Integer. Actually it is a 32 bit value but it may change in the future.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_ULONG">
<short>Unsigned long integer.</short>
<descr>
 Unsigned integer. Actually it is a 32 bit value but it may change in the future.
</descr>
</element>

<!-- alias type Visibility: default -->
<element name="AL_FLOAT">
<short>Floating point.</short>
</element>

<!-- alias type Visibility: default -->
<element name="AL_STRING">
<short>Allegro's character string type.</short>
</element>

<!-- procedure type Visibility: default -->
<element name="AL_SIMPLE_PROC">
<short>Procedure to be used as call-back.</short>
<descr>
 <p>This is used to define call-back parameter or pointers to call-back procedures.</p>
 <p>A call-back procedure must be declared as CDECL since Allegro is written in C.</p>
</descr>
</element>

<!-- procedure type Visibility: default -->
<element name="AL_PARAM_PROC">
<short>Procedure to be used as call-back.</short>
<descr>
 <p>This is used to define call-back parameter or pointers to call-back procedures. This call-back gets a parameter.</p>
 <p>A call-back procedure must be declared as CDECL since Allegro is written in C.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="AL_PARAM_PROC.x">
<short></short>
</element>

<!-- procedure type Visibility: default -->
<element name="AL_INT_PROC">
<short>Procedure to be used as call-back.</short>
<descr>
 <p>This is used to define call-back parameter or pointers to call-back procedures. This call-back gets a parameter.</p>
 <p>A call-back procedure must be declared as CDECL since Allegro is written in C.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="AL_INT_PROC.x">
<short></short>
</element>

<!-- function type Visibility: default -->
<element name="AL_SIMPLE_FUNC">
<short>Function to be used as call-back.</short>
<descr>
 <p>This is used to define call-back parameter or pointers to call-back functions.</p>
 <p class="warning">A call-back function must be declared as CDECL since Allegro is written in C.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="AL_SIMPLE_FUNC.Result">
<short></short>
</element>

</module> <!-- albase -->


<!--
  ====================================================================
    albitmap
  ====================================================================
-->

<module name="albitmap">
<short>Defines the bitmap.</short>
<descr>
	<p>Once you have selected a graphics mode, you can draw things onto the display via the <link id="algraph.al_screen">al_screen bitmap</link>. All the Allegro.pas graphics routines draw onto <link id="AL_BITMAP" /> structures, which are areas of memory containing rectangular images, stored as packed byte arrays (in 8-bit modes one byte per pixel, in 15- and 16-bit modes two bytes per pixel, in 24-bit modes 3 bytes per pixel and in 32-bit modes 4 bytes per pixel). You can create and manipulate bitmaps in system RAM, or you can write to the special <var>al_screen</var> bitmap which represents the video memory in your graphics card.</p>
 <p>Allegro.pas supports several different types of bitmaps:</p><ul>
  <li>The <link id="algraph.al_screen">al_screen bitmap</link>, which represents the hardware video memory. Ultimately you have to draw onto this in order for your image to be visible. It is destroyed by any subsequent calls to <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>.</li>
  <li>Memory bitmaps, which are located in system RAM and can be used to store graphics or as temporary drawing spaces for double buffered systems. These can be obtained by calling <link id="al_create_bitmap">al_create_bitmap</link>, <link id="albitmap.al_load_bitmap">al_load_bitmap</link>, or <link id="aldtfile">by loading a grabber datafile</link>.</li>
  <li>Sub-bitmaps. These share image memory with a parent bitmap (which can be the screen<!--, a video or system bitmap -->, a memory bitmap, or another sub-bitmap), so drawing onto them will also change their parent. They can be of any size and located anywhere within the parent bitmap, and can have their own clipping rectangles, so they are a useful way of dividing a bitmap into several smaller units, eg. splitting a large virtual screen into multiple sections<!-- (see examples/exscroll.c) -->.</li>
</ul>
<p>Make sure not to destroy a bitmap before all of its sub-bitmaps, otherwise bad things will happen when you try to access one of these sub-bitmaps.</p>
</descr>

<!-- pointer type Visibility: default -->
<element name="AL_BITMAPptr">
<short>Pointer to a <link id="AL_BITMAP">bitmap</link>.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_BITMAP">
<short>Stores the contents of a bitmap.</short>
<descr>
 <p>Stores the contents of a bitmap.</p>
 <p>There is some other stuff in the structure as well, but it is liable to change and you shouldn't use anything except the next. The w and h fields can be used to obtain the size of an existing bitmap:</p>
 <code>CONST
  BS = 'Bitmap size: (%dx%d)\n';
VAR
  bmp: AL_BITMAPptr;
  Message: AL_STRING;
BEGIN
  bmp = al_load_bitmap ('file.bmp', pal);
  Message := StrAlloc (StrLen (BS + '000x000')+1);
  StrFmt (Message, BS, [bmp^.w, bmp^.h]);
  al_allegro_message (Message);
  StrDispose (Message);
END.</code>
 <p>The clipping rectangle is inclusive on the left and top (0 allows drawing to position 0) but exclusive on the right and bottom (10 allows drawing to position 9, but not to 10). Note this is not the same format as that of the clipping API, which takes inclusive coordinates for all four corners. <b>All the values of this structure should be regarded as read-only</b><!--, with the exception of the line field, whose access is described in depth in the "Direct access to video memory" section of the manual-->. If you want to modify the clipping region, please refrain from changing this structure. Use <link id="aldraw.al_set_clip_rect">al_set_clip_rect</link> instead.</p>
</descr>
<seealso>
	<link id="AL_BITMAPptr" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.w">
<short>Width of the bitmap.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.h">
<short>Height of the bitmap.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.clip">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.cl">
<short>Clip rectangle left.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.cr">
<short>Clip rectangle rightt.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.ct">
<short>Clip rectangle top.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.cb">
<short>Clip rectangle bottom.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.vtable">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.write_bank">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.read_bank">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.dat">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.id">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.extra">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.x_ofs">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.y_ofs">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.seg">
<short>INTERNAL USE ONLY</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_BITMAP.line">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_VIDEO">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_SYSTEM">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_SUB">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_PLANAR">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_NOBLIT">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_LOCKED">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_AUTOLOCK">
<short>INTERNAL USE ONLY</short>
</element>

<!-- constant Visibility: default -->
<element name="AL_BMP_ID_MASK">
<short>INTERNAL USE ONLY</short>
</element>

<!-- function Visibility: default -->
<element name="al_create_bitmap">
<short>Creates a memory bitmap.</short>
<descr>
 <p>Creates a memory bitmap sized width by height. The bitmap will have clipping turned on, and the clipping rectangle set to the full size of the bitmap. The image memory will not be cleared, so it will probably contain garbage: you should clear the bitmap before using it. This routine always uses the global pixel format, as specified by calling <link id="algraph.al_set_color_depth">al_set_color_depth</link>. The minimum height of the AL_BITMAP must be 1 and width can't be negative. Example:</p>
 <code>VAR
  bmp: AL_BITMAPptr;
BEGIN
{ Create a 10 pixel tall bitmap, as wide as the screen. }
  bmp := al_create_bitmap (AL_SCREEN_W, 10);
  IF bmp = NIL THEN
  BEGIN
    al_message ('Couldn''t create bitmap!');
    EXIT;
  END;
{ Use the bitmap. }
    ...
{ Destroy it when we don't need it any more. }
  al_destroy_bitmap (bmp);
END.</code>
 <p>Remember to free the bitmap later to avoid memory leaks.</p>
</descr>
<seealso>
 <link id="al_create_bitmap_ex" /><link id="al_create_sub_bitmap" /><link id="al_destroy_bitmap" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_create_bitmap.Result">
<short>Returns a pointer to the created bitmap, or NIL if the bitmap could not be created.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_bitmap.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_bitmap.h">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_create_bitmap_ex">
<short>Creates a memory bitmap specifying color depth.</short>
<descr>
 <p>Creates a bitmap in a specific color depth (8, 15, 16, 24 or 32 bits per pixel). Example:</p>
 <code>VAR
  bmp: AL_BITMAPptr;
BEGIN
{  Create screen sized bitmap in 32 bits per pixel. }
  bmp := al_create_bitmap_ex (32, AL_SCREEN_W, AL_SCREEN_H);
  IF bmp = NIL THEN
  BEGIN
    al_message ('Couldn''t create bitmap!');
    EXIT;
  END;
{ Use the bitmap. }
    ...
{ Destroy it when we don't need it any more. }
  al_destroy_bitmap (bmp);
END.</code>
</descr>
<seealso>
	<link id="al_create_bitmap" /><link id="al_create_sub_bitmap" /><link id="al_destroy_bitmap" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_create_bitmap_ex.Result">
	<short>Returns a pointer to the created bitmap, or <var>NIL</var> if the bitmap could not be created.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_bitmap_ex.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_bitmap_ex.h">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_bitmap_ex.bpp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_create_sub_bitmap">
<short>Creates a sub-bitmap.</short>
<descr>
 <p>Creates a sub-bitmap, ie. a bitmap sharing drawing memory with a pre-existing bitmap, but possibly with a different size and clipping settings. When creating a sub-bitmap of the mode-X screen, the x position must be a multiple of four. The sub-bitmap width and height can extend beyond the right and bottom edges of the parent (they will be clipped), but the origin point must lie within the parent region.</p>
 <p> Remember to free the sub bitmap before freeing the parent bitmap to avoid memory leaks and potential crashes accessing memory which has been freed.</p>
</descr>
<seealso>
 <link id="al_create_bitmap" /><link id="al_create_bitmap_ex" /><link id="al_destroy_bitmap" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_create_sub_bitmap.Result">
	<short>Returns a pointer to the created sub bitmap, or <var>NIL</var> if the sub bitmap could not be created.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sub_bitmap.parent">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sub_bitmap.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sub_bitmap.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sub_bitmap.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sub_bitmap.h">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_destroy_bitmap">
<short>Destroys any type of created bitmap.</short>
<descr>
	<p>Destroys a memory bitmap, sub-bitmap, video memory bitmap, or system bitmap when you are finished with it. If you pass a <var>NIL</var> pointer this function won't do anything. See above for the restrictions as to when you are allowed to destroy the various types of bitmaps.</p>
 <p>The bitmap must not have a mouse cursor shown on it at the time it is destroyed.</p>
</descr>
<seealso>
 <link id="al_create_bitmap" /><link id="almouse.al_show_mouse">al_show_mouse</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_destroy_bitmap.bmp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_bitmap_color_depth">
<short>Returns the color depth of the specified bitmap.</short>
<descr>
 <p>Returns the color depth of the specified bitmap (8, 15, 16, 24, or 32). Example:</p>
 <code>IF al_bitmap_color_depth (al_screen) = 8 THEN
BEGIN
{ Access screen using optimized 8-bit code. }
END
ELSE BEGIN
{ Use generic slow functions. }
END;</code>
</descr>
<seealso>
 <link id="algraph.al_set_color_depth">al_set_color_depth</link><link id="al_bitmap_mask_color" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_bitmap_color_depth.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_bitmap_color_depth.bmp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_bitmap_mask_color">
<short>Returns the mask color of the specified bitmap.</short>
<descr>
	<p>Returns the mask color for the specified bitmap (the value which is skipped when drawing sprites). For 256-color bitmaps this is zero, and for truecolor bitmaps it is bright pink (maximum red and blue, zero green). A frequent use of this function is to clear a bitmap with the mask color so you can later use this bitmap with <link id="albltspr.al_masked_blit">al_masked_blit</link> or <link id="albltspr.al_draw_sprite">al_draw_sprite</link> after drawing other stuff on it. Example:</p>
 <code>{ Replace mask color with another color. }
  FOR y := 0 TO bmp^.h - 1 DO
    FOR x := 0 TO bmp^.w - 1 DO
      IF al_getpixel (bmp, x, y) = al_bitmap_mask_color (bmp) THEN
	al_putpixel (bmp, x, y, another_color);</code>
</descr>
<seealso>
	<link id="alsystem.al_set_color_depth">al_set_color_depth</link><link id="al_bitmap_color_depth" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_bitmap_mask_color.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_bitmap_mask_color.bmp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_same_bitmap">
<short>Tells if two bitmaps describe the same drawing surface.</short>
<descr>
	<p>Returns <var>TRUE</var> if the two bitmaps describe the same drawing surface, ie. the pointers are equal, one is a sub-bitmap of the other, or they are both sub-bitmaps of a common parent.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="al_is_same_bitmap.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_same_bitmap.bmp1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_same_bitmap.bmp2">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_sub_bitmap">
<short>Tells if a bitmap is a sub bitmap.</short>
<descr>
	<p>Returns <var>TRUE</var> if bmp is a sub-bitmap.</p>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="al_is_sub_bitmap.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_sub_bitmap.bmp">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_acquire_bitmap">
<short>Locks the bitmap before drawing onto it.</short>
<descr>
	<p>Acquires the specified video bitmap prior to drawing onto it. You never need to call the function explicitly as it is low level, and will only give you a speed up if you know what you are doing. Using it wrongly may cause slowdown, or even lock up your program.</p>
	<p><b>Note:</b> You do never need to use al_acquire_bitmap on a memory bitmap, i.e. a normal bitmap created with <link id="al_create_bitmap" />. It will simply do nothing in that case.</p>
	<p>It still can be useful, because e.g. under the current DirectDraw driver of Allegro, most drawing functions need to lock a video bitmap before drawing to it. But doing this is very slow, so you will get much better performance if you acquire the screen just once at the start of your main redraw function, then call multiple drawing operations which need the bitmap locked, and only release it when done.</p>
	<p>Multiple acquire calls may be nested, but you must make sure to match up the al_acquire_bitmap and <link id="al_release_bitmap" /> calls. Be warned that DirectX and X11 programs activate a mutex lock whenever a surface is locked, which prevents them from getting any input messages, so you must be sure to release all your bitmaps before using any timer, keyboard, or other non-graphics routines!</p>
	<p>Note that if you are using hardware accelerated VRAM->VRAM functions, you should not call al_acquire_bitmap. Such functions need an unlocked target bitmap under DirectX, so there is now just the opposite case from before - if the bitmap is already locked with al_acquire_bitmap, the drawing operation has to unlock it.</p>
	<p><b>Note:</b> For backwards compatibility, the unlocking behavior of such functions is permanent. That is, if you call al_acquire_bitmap first, then call e.g. an accelerated blit, the DirectX bitmap will be unlocked internally (it won't affect the nesting counter of acquire/release calls).</p>
	<p>There is no clear cross-platform way in this Allegro version to know which drawing operations need a locked/unlocked state. For example a normal rectfill most probably is accelerated under DirectX, and therefore needs the screen unlocked, but an <var>XOR</var> rectfill, or one with blending activated, most probably is not, and therefore locks the screen. And while the DirectX driver will do automatic unlocking, there is no such thing under X11, where the function is used to synchronize X11 calls from different threads. Your best bet is to never use al_acquire_bitmap - changes are you are doing something in the wrong way if you think you need it.</p>
</descr>
<errors>
	<p><b>Warning:</b> This function can be very dangerous to use, since the whole program may get locked while the bitmap is locked. So the lock should only be held for a short time, and you should not call anything but drawing operations onto the locked video bitmap while a lock is in place. Especially don't call things like <link id="almouse.al_show_mouse">al_show_mouse</link><!-- (or <link id="almouse.al_scare_mouse">al_scare_mouse</link> which calls that)--> or <link id="alkeybrd.al_readkey">al_readkey</link>, since it will most likely deadlock your entire program.</p>
</errors>
<seealso>
	<link id="al_release_bitmap" /><link id="algraph.al_acquire_screen">al_acquire_screen</link><link id="algraph.al_release_screen">al_release_screen</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_acquire_bitmap.bmp">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_release_bitmap">
<short>Releases a previously locked bitmap.</short>
<descr>
	<p>Releases a bitmap that was previously locked by calling <link id="al_acquire_bitmap" />. If the bitmap was locked multiple times, you must release it the same number of times before it will truly be unlocked.</p>
</descr>
<seealso>
	<link id="al_acquire_bitmap" /><link id="algraph.al_acquire_screen">al_acquire_screen</link><link id="algraph.al_release_screen">al_release_screen</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_release_bitmap.bmp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_generate_optimized_palette">
<short>Generates an optimized palette for a bitmap.</short>
<descr>
	<p>Generates a 256-color palette suitable for making a reduced color version of the specified truecolor image. The <var>rsvd</var> parameter points to a table indicating which colors it is allowed to modify: zero for free colors which may be set to whatever the optimiser likes, negative values for reserved colors which cannot be used, and positive values for fixed palette entries that must not be changed, but can be used in the optimisation.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alpalete.al_generate_332_palette" />
	<link id="algraph.al_set_color_depth">al_set_color_depth</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_generate_optimized_palette.Result">
<short>Returns the number of different colors recognised in the provided bitmap, zero if the bitmap is not a truecolor image or there wasn't enough memory to perform the operation, and negative if there was any internal error in the color reduction code.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_generate_optimized_palette.image">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_generate_optimized_palette.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_generate_optimized_palette.rsvdcols">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_bitmap">
<short>Loads any supported bitmap from a file.</short>
<descr>
	<p>Loads a bitmap from a file. The palette data will be stored in the second parameter, which should be an array of 256 RGB structures. At present this function supports BMP, LBM, PCX, and TGA files, determining the type from the file extension.</p>
	<p>If the file contains a truecolor image, you must set the video mode or call <link id="algraph.al_set_color_conversion">al_set_color_conversion</link> before loading it. In this case, if the destination color depth is 8-bit, the palette will be generated by calling <link id="al_generate_optimized_palette" /> on the bitmap; otherwise, the returned palette will be generated by calling <link id="alpalete.al_generate_322_palette">al_generate_332_palette</link>.</p>
	<p>The <var>pal</var> argument may be <var>NIL</var>. In this case, the palette data are simply not returned. Additionally, if the file is a truecolor image and the destination color depth is 8-bit, the color conversion process will use the current palette instead of generating an optimized one.</p>
	<p>Example:</p>
	<code>VAR
  bmp: AL_BITMAPptr;
  palette: AL_PALETTE;
BEGIN
  ...
 
  bmp := al_load_bitmap ('image.pcx', @palette);
  IF bmp = NIL THEN
  BEGIN
    al_message ('Couldn''t load image.pcx!');
    EXIT;
  END;

  ...

  al_destroy_bitmap (bmp);
END;</code>
</descr>
<seealso>
	<link id="al_destroy_bitmap" />
	<link id="al_save_bitmap" />
	<link id="algraph.al_set_color_depth">al_set_color_depth</link>
	<link id="algraph.al_set_color_conversion">al_set_color_conversion</link>
	<link id="al_generate_optimized_palette" />
	<link id="alpalete.al_generate_322_palette">al_generate_332_palette</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_bitmap.Result">
	<short>Returns a pointer to the bitmap or <var>NIL</var> on error. Remember that you are responsible for destroying the bitmap when you are finished with it to avoid memory leaks.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_bitmap.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_bitmap.pal">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_save_bitmap">
<short>Saves a bitmap into any supported file format.</short>
<descr>
	<p>Writes a bitmap into a file, using the specified palette, which should be an array of 256 RGB structures. The output format is determined from the filename extension: at present this function supports BMP, PCX and TGA formats.</p>
	<p>Two things to watch out for: on some video cards it may be faster to copy the screen to a memory bitmap and save the latter, and if you use this to dump the screen into a file you may end up with an image much larger than you were expecting, because Allegro often creates virtual screens larger than the visible screen. You can get around this by using a sub-bitmap to specify which part of the screen to save, eg:</p>
	<code>VAR
  bmp: AL_BITMAPptr;
  pal: AL_PALETTE;
BEGIN
   ...
  al_get_palette (@pal);
  bmp := al_create_sub_bitmap (al_screen, 0, 0, AL_SCREEN_W, AL_SCREEN_H);
  al_save_bitmap ('dump.pcx', bmp, @pal);
  al_destroy_bitmap (bmp);
  ...
END;</code>
</descr>
<seealso>
	<link id="al_load_bitmap" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_save_bitmap.Result">
<short>Returns non-zero on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_bitmap.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_bitmap.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_bitmap.pal">
<short></short>
</element>

</module> <!-- albitmap -->


<!--
  ====================================================================
    albltspr
  ====================================================================
-->

<module name="albltspr">
<short>Blitting images and drawing sprites.</short>
<descr>
	<p>As far as Allegro is concerned, a bitmap and a sprite are the same thing, but to many people the two words imply slightly different things. The function draw_sprite is called so rather than al_draw_bitmap partly because it indicates that it uses a masked drawing mode (if it existed, you could expect al_draw_bitmap to be a simple block copy), and partly for historical reasons. In Allegro 1.0 there were actually different structures for sprites and bitmaps, each with their own set of abilities. Allegro 2.0 merged these into a single more flexible structure, but retained some names like al_draw_sprite.</p>
	<p>In wider (non-Allegro) terms, the two words can mean quite different things. Generally you can say that sprites are a subset of bitmaps, but even that isn't true in 100% of cases.</p>
	<dl>
		<dt>Bitmap</dt><dd>a widely accepted term that will be understood by anyone even remotely connected with computer graphics. It simply means an image built up from a grid of pixels, ie. just about any picture that you are likely to come across on a computer (vector graphics formats are the exception, but those must be rendered into a bitmap format before they can be displayed by most hardware). A more accurate term but slightly rarer term with the same meaning is "pixmap" (pixel-map).</dd>
		<dt>Sprite</dt><dd>a particular usage of bitmapped images, restricted to video games (other types of programmer probably won't be familiar with this term). Originally on machines like the C64, sprites were a hardware feature that allowed a number of small bitmap images to be loaded into special registers, and they could then be superimposed over the main graphics display and moved around just by modifying the position register. They were used for the moving objects (player and enemy characters), and enabled the C64 to do much more impressive things than would have been possible if all the drawing had to be done directly by the puny CPU.</dd>
	</dl>
	<p>Later on, a lot of old C64 programmers upgraded to machines like the Atari ST, which didn't have any special sprite hardware, but they carried on referring to their main moving objects as sprites (the routine to draw such a thing would obviously be called draw_sprite). A sprite is really just a bitmap graphic which is drawn onto the screen, but when you call it a sprite rather than a bitmap, this suggests it is a gameplay element that can move freely around the world rather than being a static part of the environment, and that it will be drawn in a masked overlay mode rather than as a solid rectangle (there is also a strong implication that a sprite will be animated by cycling through a number of frames, but that isn't always the case).</p>
	<p>In recent years some people have started using <i>sprite</i> to refer to any character graphics, even if they are not in fact drawn as 2d bitmaps, eg. <i>"this game uses 3d polygonal player sprites"</i>. This is a confusing misuse of the word (Doom uses sprites, Quake does not), but it does happen.</p>
	<p>The origin of the term <i>"blit"</i> is also rather interesting. This was originally BitBlt, an abbreviation of BITmap BLock Transfer, which was a function designed (possibly) by the people at Xerox who did so much of the pioneering work on graphics display systems, and subsequently copied by virtually everybody doing computer graphics (the Microsoft Windows GDI still provides a BitBlt function with identical functionality to the original). This routine was a workhorse for all sorts of drawing operations, basically copying bitmap graphics from one place to another, but including a number of different ROP modes (Raster OPerations) for doing things like XOR, inverting pixels, etc. A whole family of related words grew up around the BitBlt function, but "blt" is impossible to speak (try saying "bltter" or "bltting" :-) so people added the vowel to make it easier to pronounce.</p>
	<p>Thusly, the act of calling the BitBlt function came to be known as <i>"doing a blit"</i>. The obvious next step was to rename the function itself to blit, which generally took place at the same time as people decided to simplify the original, removing the different ROP modes on the grounds that they aren't needed for games coding and don't work well with anything higher than monochrome images in any case. This leaves us with a function called blit(), which is an abbreviation for "block transfer". A strong case could be made for calling this blot() instead, but somehow that just doesn't sound the same!</p>
	<p>Anyway, all the routines in this chapter are affected by the clipping rectangle of the destination bitmap.</p>
</descr>

<!-- procedure Visibility: default -->
<element name="al_blit">
<short>Copies a rectangular area from one bitmap to another.</short>
<descr>
	<p>Copies a rectangular area of the source bitmap to the destination bitmap. The source_x and source_y parameters are the top left corner of the area to copy from the source bitmap, and dest_x and dest_y are the corresponding position in the destination bitmap. This routine respects the destination clipping rectangle, and it will also clip if you try to blit from areas outside the source bitmap. Example:</p>
	<code>VAR
  bmp: AL_BITMAPptr;
BEGIN
  ...
{ Blit src on the screen. }
  al_blit (bmp, al_screen, 0, 0, 0, 0, bmp^.w, bmp^.h);
{ Now copy a chunk to a corner, slightly outside. }
  al_blit (al_screen, al_screen, 100, 100, -10, -10, 25, 30);
END;</code>
	<p>You can blit between any parts of any two bitmaps, even if the two memory areas overlap (ie. source and dest are the same, or one is sub-bitmap of the other). You should be aware, however, that a lot of SVGA cards don't provide separate read and write banks, which means that blitting from one part of the screen to another requires the use of a temporary bitmap in memory, and is therefore extremely slow. As a general rule you should avoid blitting from the screen onto itself in SVGA modes.</p>
	<!-- p>In mode-X, on the other hand, blitting from one part of the screen to another can be significantly faster than blitting from memory onto the screen, as long as the source and destination are correctly aligned with each other. Copying between overlapping screen rectangles is slow, but if the areas don't overlap, and if they have the same plane alignment (ie. (source_x MOD 4) == (dest_x MOD 4)), the VGA latch registers can be used for a very fast data transfer. To take advantage of this, in mode-X it is often worth storing tile graphics in a hidden area of video memory (using a large virtual screen), and blitting them from there onto the visible part of the screen.</p -->
	<p>If the <link id="algraph.AL_GFX_HW_VRAM_BLIT">AL_GFX_HW_VRAM_BLIT</link> bit in the <link id="algraph.al_gfx_capabilities">al_gfx_capabilities</link> flag is set, the current driver supports hardware accelerated blits from one part of the screen onto another. This is extremely fast, so when this flag is set it may be worth storing some of your more frequently used graphics in an offscreen portion of the video memory.</p>
	<p>Unlike most of the graphics routines, al_blit() allows the source and destination bitmaps to be of different color depths, so it can be used to convert images from one pixel format to another. In this case, the behavior is affected by the <link id="algraph.AL_COLORCONV_KEEP_TRANS">AL_COLORCONV_KEEP_TRANS</link> and AL_COLORCONV_DITHER* flags of the current color conversion mode: see <link id="algraph.al_set_color_conversion">al_set_color_conversion</link> for more information.</p>
</descr>
<seealso>
	<link id="al_masked_blit" /><link id="al_stretch_blit" /><link id="al_draw_sprite" /><link id="algraph.al_gfx_capabilities">al_gfx_capabilities</link><link id="algraph.al_set_color_conversion">al_set_color_conversion</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.source_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.source_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.dest_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.dest_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_blit.height">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_stretch_blit">
<short>Scales a rectangular area from one bitmap to another.</short>
<descr>
	<p>Like <link id="al_blit" />, except it can scale images (so the source and destination rectangles don't need to be the same size) and requires the source and destination bitmaps to be of the same color depth. This routine doesn't do as much safety checking as the regular al_blit: in particular you must take care not to copy from areas outside the source bitmap, and you cannot blit between overlapping regions, ie. you must use different bitmaps for the source and the destination. Moreover, the source must be a memory bitmap. Example:</p>
	<code>VAR
  bmp: AL_BITMAPptr;
BEGIN
  ...
  
{ Stretch bmp to fill the screen. }
  al_stretch_blit (bmp, al_screen, 0, 0, bmp^.w, bmp^.h,
		   0, 0, AL_SCREEN_W, AL_SCREEN_H);
END.</code>
</descr>
<seealso>
	<link id="al_blit" /><link id="al_masked_stretch_blit" /><link id="al_stretch_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.source_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.source_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.source_width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.source_height">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.dest_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.dest_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.dest_width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_blit.dest_height">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_masked_blit">
<short>Copies a rectangle skipping pixels with the mask color.</short>
<descr>
	<p>Like <link id="al_blit" />, but skips transparent pixels, which are marked by a zero in 256-color modes or bright pink for truecolor data (maximum red and blue, zero green), and requires the source and destination bitmaps to be of the same color depth. The source and destination regions must not overlap. Example:</p>
	<code>VAR
  hud_overlay: AL_BITMAPptr;
BEGIN
  ...
{ Paint hud overlay on the screen. }
  al_masked_blit (hud_overlay, al_screen, 0, 0, 0, 0,
                  hud_overlay^.w, hud_overlay^.h);
END;</code>
	  <p>If the <link id="algraph.AL_GFX_HW_VRAM_BLIT_MASKED">AL_GFX_HW_VRAM_BLIT_MASKED</link> bit in the <link id="algraph.al_gfx_capabilities">al_gfx_capabilities</link> flag is set, the current driver supports hardware accelerated masked blits from one part of the screen onto another. This is extremely fast, so when this flag is set it may be worth storing some of your more frequently used sprites in an offscreen portion of the video memory.</p>
	  <p><b>Warning:</b> if the hardware acceleration flag is not set, al_masked_blit will not work correctly when used with a source image in system or video memory so the latter must be a memory bitmap. </p>
</descr>
<seealso>
	<link id="al_blit" /><link id="al_masked_stretch_blit" /><link id="al_draw_sprite" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.source_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.source_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.dest_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.dest_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_blit.height">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_masked_stretch_blit">
<short>Scales a rectangular area skipping pixels with the mask color.</short>
<descr>
	<p>Like <link id="al_masked_blit" />, except it can scale images (so the source and destination rectangles don't need to be the same size). This routine doesn't do as much safety checking as the regular al_masked_blit: in particular you must take care not to copy from areas outside the source bitmap. Moreover, the source must be a memory bitmap. Example:</p>
	<code>VAR
  hud_overlay: AL_BITMAPptr;
BEGIN
  ...
{ Paint hud overlay on the screen. }
  al_masked_blit (hud_overlay, al_screen, 0, 0,
                  hud_overlay^.w, hud_overlay^.h,
                  0, 0, SCREEN_W, SCREEN_H);
END;</code>
</descr>
<seealso>
	<link id="al_blit" /><link id="al_masked_blit" /><link id="al_draw_sprite" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.source_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.source_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.source_width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.source_height">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.dest_x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.dest_y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.dest_width">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_masked_stretch_blit.dest_height">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_sprite">
<short>Draws a copy of the sprite onto the destination bitmap.</short>
<descr>
	<p>Draws a copy of the sprite bitmap onto the destination bitmap at the specified position. This is almost the same as <link id="al_blit" /><var> (sprite, bmp, 0, 0, x, y, sprite.^w, sprite^.h)</var>, but it uses a masked drawing mode where transparent pixels are skipped, so the background image will show through the masked parts of the sprite. Transparent pixels are marked by a zero in 256-color modes or bright pink for truecolor data (maximum red and blue, zero green). Example:</p>
	<code>VAR
  spaceship: AL_BITMAPptr;
BEGIN
  ...
  al_draw_sprite (al_screen, spaceship, x, y);
END;</code>
	  <p>If the <link id="algraph.AL_GFX_HW_VRAM_BLIT_MASKED">AL_GFX_HW_VRAM_BLIT_MASKED</link> bit in the <link id="algraph.al_gfx_capabilities">al_gfx_capabilities</link> flag is set, the current driver supports hardware accelerated sprite drawing when the source image is a memory bitmap or a sub-bitmap of the screen. This is extremely fast, so when this flag is set it may be worth storing some of your more frequently used sprites in an offscreen portion of the video memory.</p>
	  <p><b>Warning:</b> if the hardware acceleration flag is not set, al_draw_sprite will not work correctly when used with a sprite image in system or video memory so the latter must be a memory bitmap.</p>
	  <p>Although generally not supporting graphics of mixed color depths, as a special case this function can be used to draw 256-color source images onto truecolor destination bitmaps, so you can use palette effects on specific sprites within a truecolor program.</p>
</descr>
<seealso>
	<link id="al_draw_sprite_v_flip" /><link id="al_stretch_sprite" /><link id="al_rotate_sprite" /><link id="al_masked_blit" /><link id="al_blit" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_stretch_sprite">
<short>Stretches a sprite to the destination bitmap.</short>
<descr>
	<p>Like <link id="al_draw_sprite" />, except it can stretch the sprite image to the specified width and height and requires the sprite image and destination bitmap to be of the same color depth. Moreover, the sprite image must be a memory bitmap. Example:</p>
	<code>{ Create tunnel like effect. }
  FOR step := 1 TO 15 DO
  BEGIN
    width := AL_SCREEN_W DIV step;
    height := AL_SCREEN_H DIV step;
    al_stretch_sprite (al_screen, image, AL_SCREEN_W DIV 2 - width DIV 2,
                       AL_SCREEN_H DIV 2 - height DIV 2, width, height);
  END;</code>
</descr>
<seealso>
	<link id="al_draw_sprite" /><link id="al_stretch_blit" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_stretch_sprite.h">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_sprite_h_flip">
<short>Draws the sprite transformed to the destination bitmap.</short>
<descr>
	<p>This is like <link id="al_draw_sprite" />, but it additionally flip the image horizontally. Flipping horizontally means that the x-axis is reversed between the source and the destination. This produces exact mirror images, which is not the same as rotating the sprite (and it is a lot faster than the rotation routine). The sprite must be a memory bitmap. Example:</p>
	<code>IF al_key^[AL_KEY_RIGHT] &lt;&gt; #0 THEN
  al_draw_sprite (al_screen, hero_right, pos_x, pos_y)
ELSE if al_key^[KEY_LEFT] &lt;&gt; #0 THEN
  al_draw_h_sprite (al_screen, hero_right, pos_x, pos_y);</code>
</descr>
<seealso>
	<link id="al_draw_sprite" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_h_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_h_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_h_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_h_flip.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_sprite_v_flip">
<short>Draws the sprite transformed to the destination bitmap.</short>
<descr>
	<p>This is like <link id="al_draw_sprite" />, but it additionally flip the image vertically. Flipping vertically means that the y-axis is reversed between the source and the destination. This produces exact mirror images, which is not the same as rotating the sprite (and it is a lot faster than the rotation routine). The sprite must be a memory bitmap. Example:</p>
	<code>IF al_key^[AL_KEY_UP] &lt;&gt; #0 THEN
    al_draw_sprite (al_screen, hero_up, pos_x, pos_y)
  ELSE if al_key^[KEY_DOWN] &lt;&gt; #0 THEN
    al_draw_v_sprite (al_screen, hero_up, pos_x, pos_y);
	</code>
</descr>
<seealso>
	<link id="al_draw_sprite" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_v_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_v_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_v_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_v_flip.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_sprite_vh_flip">
<short>Draws the sprite transformed to the destination bitmap.</short>
<descr>
	<p>This is like <link id="al_draw_sprite" />, but it additionally flip the image both horizontally and vertically. Flipping vertically means that the y-axis is reversed, while flipping horizontally means that the x-axis is reversed, between the source and the destination,  which is not the same as rotating the sprite (and it is a lot faster than the rotation routine). The sprite must be a memory bitmap.</p>
</descr>
<seealso>
	<link id="al_draw_sprite" /><link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_vh_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_vh_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_vh_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_sprite_vh_flip.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_trans_sprite">
<short>Draws a sprite blending it with the destination.</short>
<descr>
	<p>Uses the global color_map table or truecolor blender functions to overlay the sprite on top of the existing image. This must only be used after you have set up the color mapping table (for 256-color modes) or blender functions (for truecolor modes). Because it involves reading as well as writing the bitmap memory, translucent drawing is very slow if you draw directly to video RAM, so wherever possible you should use a memory bitmap instead. Example:</p>
	<code>{ Some one time initialisation code. }
VAR
  global_trans_table: AL_COLOR_MAP;
BEGIN
  al_create_trans_table (@global_trans_table, my_palette, 128, 128, 128, NIL);
          ...
  IF al_get_color_depth = 8 THEN
    al_set_color_map (@global_trans_table)
  ELSE
    al_set_trans_blender (128, 128, 128, 128);
          ...
    al_draw_trans_sprite (buffer, ghost_sprite, x, y);
          ...
END;</code>
	<p>The bitmap and sprite must normally be in the same color depth, but as a special case you can draw 32 bit RGBA format sprites onto any hicolor or truecolor bitmap, as long as you call <link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link> first, and you can draw 8-bit alpha images onto a 32-bit RGBA destination, as long as you call <link id="altrutra.al_set_write_alpha_blender">al_set_write_alpha_blender</link> first. As <link id="al_draw_sprite" /> this function skips transparent pixels, except if the source sprite is an 8-bit image; if this is the case, you should pay attention to properly set up your color map table for index 0.</p>
</descr>
<seealso>
	<link id="al_draw_sprite" />
	<link id="al_draw_lit_sprite" />
	<link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link>
	<link id="al256tra.al_set_color_map">al_set_color_map</link>
	<link id="altrutra.al_set_trans_blender">al_set_trans_blender</link>
	<link id="altrutra.al_set_write_trans_blender">al_set_write_trans_blender</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_sprite.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_lit_sprite">
<short>Draws a sprite tinted with a specific color.</short>
<descr>
	<p>In 256-color modes, uses the global color map table to tint the sprite image to the specified color or to light it to the level specified by 'color', depending on the function which was used to build the table (<link id="al256tra.al_create_trans_table">al_create_trans_table</link> or <link id="al256tra.al_create_light_table">al_create_light_table</link>), and draws the resulting image to the destination bitmap. In truecolor modes, uses the blender functions to light the sprite image using the alpha level specified by 'color' (the alpha level which was passed to the blender functions is ignored) and draws the resulting image to the destination bitmap. The 'color' parameter must be in the range [0-255] whatever its actual meaning is. This must only be used after you have set up the color mapping table (for 256-color modes) or blender functions (for truecolor modes). Example:</p>
	<code>{ Some one time initialisation code. }
VAR
  global_light_table: AL_COLOR_MAP;
BEGIN
  al_create_light_table (@global_trans_table, my_palette, 10, 10, 60, NIL);
          ...
  IF al_get_color_depth = 8 THEN
    al_set_color_map (@global_light_table)
  ELSE
    al_set_trans_blender (40, 40, 255, 255);
          ...
{ Lit the cape with a blueish light. }
  al_draw_lit_sprite (buffer, colored_cape, x, y);
          ...
END;</code>
</descr>
<seealso>
	<link id="al_draw_sprite" />
	<link id="al_draw_trans_sprite" />
	<link id="alsprrle.al_draw_lit_rle_sprite">al_draw_lit_rle_sprite</link>
	<link id="al256tra.al_set_color_map">al_set_color_map</link>
	<link id="altrutra.al_set_trans_blender">al_set_trans_blender</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_sprite.c">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rotate_sprite">
<short>Rotates a sprite.</short>
<descr>
	<p>Draws the sprite image onto the bitmap. It is placed with its top left corner at the specified position, then rotated by the specified angle around its centre. The angle is a <link id="alfixed.AL_FIXED">fixed point 16.16 number</link> in the same format used by the fixed point trig routines, with 256 equal to a full circle, 64 a right angle, etc. All rotation functions can draw between any two bitmaps, even screen bitmaps or bitmaps of different color depth.</p>
	<p>Positive increments of the angle will make the sprite rotate clockwise on the screen, as demonstrated by the Allegro example.</p>
</descr>
<seealso>
	<link id="al_draw_sprite" /><link id="al_rotate_scaled_sprite" /><link id="al_rotate_sprite_v_flip" /><link id="al_rotate_scaled_sprite_v_flip" /><link id="al_pivot_sprite" /><link id="al_pivot_sprite_v_flip" /><link id="al_pivot_scaled_sprite" /><link id="al_pivot_scaled_sprite_v_flip" /><link id="alfixed.al_itofix">al_itofix</link><link id="alfixed" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite.angle">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rotate_sprite_v_flip">
<short>Rotates and flips a sprite.</short>
<descr>
	<p>Like <link id="al_rotate_sprite" />, but flips the image vertically before rotating it. To flip horizontally, use this routine but add <link id="alfixed.al_itofix">al_itofix</link>(128) to the angle. To flip in both directions, use al_rotate_sprite and add al_itofix(128) to its angle.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_scaled_sprite_v_flip" /><link id="al_pivot_sprite_v_flip" /><link id="al_pivot_scaled_sprite_v_flip" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite_v_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite_v_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite_v_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite_v_flip.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_sprite_v_flip.angle">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rotate_scaled_sprite">
<short>Rotates and stretches a sprite.</short>
<descr>
	<p>Like <link id="al_rotate_sprite" />, but stretches or shrinks the image at the same time as rotating it.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_scaled_sprite_v_flip" /><link id="al_pivot_scaled_sprite" /><link id="al_pivot_scaled_sprite_v_flip" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.angle">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite.scale">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip">
<short>Rotates, stretches and flips a sprite.</short>
<descr>
	<p>Draws the sprite, similar to <link id="al_rotate_scaled_sprite" /> except that it flips the sprite vertically first.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_scaled_sprite" /><link id="al_rotate_sprite_v_flip" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.angle">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rotate_scaled_sprite_v_flip.scale">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_pivot_sprite">
<short>Rotates a sprite around a specified point.</short>
<descr>
	<p>Like <link id="al_rotate_sprite" />, but aligns the point in the sprite given by (cx, cy) to (x, y) in the bitmap, then rotates around this point.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_pivot_scaled_sprite" /><link id="al_pivot_sprite_v_flip" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.cx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.cy">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite.angle">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_pivot_sprite_v_flip">
<short>Rotates and flips a sprite around a specified point.</short>
<descr>
	<p>Like <link id="al_rotate_sprite_v_flip" />, but aligns the point in the sprite given by (cx, cy) to (x, y) in the bitmap, then rotates around this point.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_sprite_v_flip" /><link id="al_pivot_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.cx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.cy">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_sprite_v_flip.angle">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_pivot_scaled_sprite">
<short>Rotates and stretches a sprite around a specified point.</short>
<descr>
	<p>Like <link id="al_rotate_scaled_sprite" />, but aligns the point in the sprite given by (cx, cy) to (x, y) in the bitmap, then rotates and scales around this point.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_scaled_sprite" /><link id="al_pivot_sprite" /><link id="al_pivot_scaled_sprite_v_flip" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.cx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.cy">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.angle">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite.scale">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip">
<short>Rotates, stretches and flips a sprite around a specified point.</short>
<descr>
	<p>Like <link id="al_rotate_scaled_sprite_v_flip" />, but aligns the point in the sprite given by (cx, cy) to (x, y) in the bitmap, then rotates and scales around this point.</p>
</descr>
<seealso>
	<link id="al_rotate_sprite" /><link id="al_rotate_scaled_sprite_v_flip" /><link id="al_rotate_sprite_v_flip" /><link id="al_pivot_sprite" /><link id="al_pivot_scaled_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.sprite">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.cx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.cy">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.angle">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_pivot_scaled_sprite_v_flip.scale">
<short></short>
</element>

</module> <!-- albltspr -->



<!--
  ====================================================================
    alcolor
  ====================================================================
-->

<module name="alcolor">
<short>Color manipulation.</short>
<descr>
	<p>In a truecolor video mode the red, green, and blue components for each pixel are packed directly into the color value, rather than using a palette lookup table. In a 15-bit mode there are 5 bits for each color, in 16-bit modes there are 5 bits each of red and blue and six bits of green, and both 24 and 32-bit modes use 8 bits for each color (the 32-bit pixels simply have an extra padding byte to align the data nicely). The layout of these components can vary depending on your hardware, but will generally either be RGB or BGR. Since the layout is not known until you select the video mode you will be using, you must call <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link> before using any of the following routines!</p>
</descr>

<!-- pointer type Visibility: default -->
<element name="AL_RGBptr">
<short>Pointer to a <link id="AL_RGB">RGB description</link>.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_RGB">
<short>Palette entry.</short>
<descr>
	<p>Palette entry. It contains an additional field for the purpose of padding but you should not usually care about it. Read chapter <link id="alpalete">Palette routines</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="alpalete" /><link id="alpalete.AL_PALETTE">AL_PALETTE</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_RGB.r">
<short>Red component.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RGB.g">
<short>Green component.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RGB.b">
<short>Blue component.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RGB.filler">
<short>INTERNAL USE ONLY</short>
</element>

<!-- function Visibility: default -->
<element name="al_makecol">
<short>Converts an RGB value into the current pixel format.</short>
<descr>
	<p>Converts colors from a hardware independent format (red, green, and blue values ranging 0-255) to the pixel format required by the current video mode, calling the preceding 8, 15, 16, 24, or 32-bit makecol functions as appropriate. Example:</p>
	<code>{ Regardless of color depth, this will look green. }
  green_color := al_makecol (0, 255, 0);</code>
</descr>
<seealso>
	<link id="al_makeacol" /><link id="al_makecol_depth" /><link id="algraph.al_set_color_depth">al_set_color_depth</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_makecol.Result">
<short>Returns the requested RGBA quadruplet.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol.b">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_makecol8">
<short>Converts an RGB value into a display dependent pixel format.</short>
<descr>
	<p>This function convert colors from a hardware independent form (red, green, and blue values ranging 0-255) into 8 bit pixel formats. Converting to an 8-bit color involves searching the palette to find the closest match, which is quite slow unless you have set up an <link id="al256tra.al_create_color_table">RGB mapping table</link>. Example:</p>
	<code>{ 8 bit color version of green. }
  green_color := al_makecol8 (0, 255, 0);</code>
</descr>
<seealso>
	<link id="al_makecol" /><link id="al_makecol_depth" /><link id="algraph.al_set_color_depth">al_set_color_depth</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_makecol8.Result">
<short>Returns the requested RGB triplet in the 8 bit color depth.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol8.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol8.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol8.b">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_makecol_depth">
<short>Converts an RGB value into the specified pixel format.</short>
<descr>
	<p>Converts colors from a hardware independent format (red, green, and blue values ranging 0-255) to the pixel format required by the specified color depth. Example:</p>
	<code>{ Compose the green color for 15 bit color depth. }
  green_15bit := al_makecol_depth (15, 0, 255, 0);</code>
</descr>
<seealso>
	<link id="al_makecol" /><link id="al_makeacol" /><link id="algraph.al_set_color_depth">al_set_color_depth</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_makecol_depth.Result">
<short>Returns the requested RGB triplet in the specified color depth.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol_depth.color_depth">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol_depth.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol_depth.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makecol_depth.b">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_makeacol">
<short>Converts RGBA colors into display dependent pixel formats.</short>
<descr>
	<p>Convert RGBA colors into display dependent pixel formats. In anything less than a 32-bit mode, these are the same as calling <link id="al_makecol" /> or <link id="al_makecol_depth" />, but by using this routine it is possible to create 32-bit color values that contain a true 8 bit alpha channel along with the red, green, and blue components. You should only use RGBA format colors as the input to <link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link> or <link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link> after calling <link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link>, rather than drawing them directly to the screen.</p>
</descr>
<seealso>
	<link id="al_makecol" /><link id="al_makecol_depth" />
	<link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link>
	<link id="altrutra.al_set_write_alpha_blender">al_set_write_alpha_blender</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_makeacol.Result">
<short>Returns the requested RGBA quadruplet.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol.a">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_makeacol_depth">
<short>Converts RGBA colors into display dependent pixel formats.</short>
<descr>
	<p>Convert RGBA colors into display dependent pixel formats. In anything less than a 32-bit mode, these are the same as calling <link id="al_makecol" /> or <link id="al_makecol_depth" />, but by using this routine it is possible to create 32-bit color values that contain a true 8 bit alpha channel along with the red, green, and blue components. You should only use RGBA format colors as the input to <link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link> or <link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link> after calling <link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link>, rather than drawing them directly to the screen.</p>
</descr>
<seealso>
	<link id="al_makecol" /><link id="al_makecol_depth" />
	<link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link>
	<link id="altrutra.al_set_write_alpha_blender">al_set_write_alpha_blender</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_makeacol_depth.Result">
<short>Returns the requested RGBA quadruplet.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol_depth.color_depth">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol_depth.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol_depth.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol_depth.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_makeacol_depth.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_hsv_to_rgb">
<short>Converts color values between the HSV and RGB colorspaces.</short>
<descr>
	<p>Convert color values between the HSV and RGB colorspaces. The RGB values range from 0 to 255, hue is from 0 to 360, and saturation and value are from 0 to 1. Example:</p>
	<code>VAR
  r, g, b: AL_INT;
  hue, saturation, value: AL_FLOAT;
BEGIN
          ...
{ Convert a reddish color to HSV format. }
  al_rgb_to_hsv (255, 0, 128, @hue, @saturation, @value);
{ Now put our tin foil hat, and verify that. }
  al_hsv_to_rgb (hue, saturation, value, @r, @g, @b);
END;</code>
</descr>
<seealso>
	<link id="al_rgb_to_hsv" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.h">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.s">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.v">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hsv_to_rgb.b">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rgb_to_hsv">
<short>Converts color values between the HSV and RGB colorspaces.</short>
<descr>
	<p>Convert color values between the HSV and RGB colorspaces. The RGB values range from 0 to 255, hue is from 0 to 360, and saturation and value are from 0 to 1. Example:</p>
	<code>VAR
  r, g, b: AL_INT;
  hue, saturation, value: AL_FLOAT;
BEGIN
          ...
{ Convert a reddish color to HSV format. }
  al_rgb_to_hsv (255, 0, 128, @hue, @saturation, @value);
{ Now put our tin foil hat, and verify that. }
  al_hsv_to_rgb (hue, saturation, value, @r, @g, @b);
END;</code>
</descr>
<seealso>
	<link id="al_hsv_to_rgb" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.h">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.s">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rgb_to_hsv.v">
<short></short>
</element>

</module> <!-- alcolor -->


<!--
  ====================================================================
    alconfig
  ====================================================================
-->

<module name="alconfig">
<short>Configuration routines.</short>
<descr>
	<p>Various parts of Allegro, such as the <link id="alsound">sound routines</link> and the <link id="aljstick.al_load_joystick_data">al_load_joystick_data</link> function, require some configuration information. This data is stored in text files as a collection of `variable=value' lines, along with comments that begin with a `#' character and continue to the end of the line. The configuration file may optionally be divided into sections, which begin with a `[sectionname]' line. Each section has a unique namespace, to prevent variable name conflicts, but any variables that aren't in a section are considered to belong to all the sections simultaneously.</p>
	<p>By default the configuration data is read from a file called `allegro.cfg', which can be located either in the same directory as the program executable, or the directory pointed to by the ALLEGRO environment variable. Under Unix, it also checks for `~/allegro.cfg', `~/.allegrorc', `/etc/allegro.cfg', and `/etc/allegrorc', in that order; under BeOS only the last two are also checked. MacOS X also checks in the Contents/Resources directory of the application bundle, if any, before doing the checks above.</p>
	<p>If you don't like this approach, you can specify any filename you like, or use a block of binary configuration data provided by your program (which could for example be loaded from a datafile).<!-- You can also extend the paths searched for allegro resources with set_allegro_resource_path().--></p>
	<p>You can store whatever custom information you like in the config file, along with <link id="standard_config_variables">the standard variables</link> that are used by Allegro. Allegro comes with a setup directory where you can find configuration programs. The standalone setup program is likely to be of interest to final users. It allows any user to create an `allegro.cfg' file without the need to touch a text editor and enter values by hand. It also provides a few basic tests like sound playing for soundcard testing. You are welcome to include the setup program with your game, either as is or with modified graphics to fit better your game.</p>
</descr>

<!-- procedure Visibility: default -->
<element name="al_set_config_file">
<short>Sets the configuration file.</short>
<descr>
	<p>Sets the configuration file to be used by all subsequent config functions. If you don't call this function, Allegro will use the default `allegro.cfg' file, looking first in the same directory as your program and then in the directory pointed to by the ALLEGRO environment variable and the usual platform-specific paths for configuration files. For example it will look for `/etc/allegro.cfg' under Unix.</p>
	<p>All pointers returned by previous calls to <link id="al_get_config_string" /> and other related functions are invalidated when you call this function! You can call this function before <link id="alsystem.al_install">al_install</link> to change the configuration file<!--, but after set_uformat() if you want to use a text encoding format other than the default-->.</p>
</descr>
<seealso>
	<link id="al_set_config_data" /><link id="al_override_config_file" /><link id="al_push_config_state" /><link id="al_set_config_string" /><link id="al_get_config_string" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_file.filename">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_data">
<short>Sets a block of configuration data.</short>
<descr>
	<p>Specifies a block of data to be used by all subsequent config functions, which you have already loaded from disk (eg. as part of some more complicated format of your own, or in a grabber datafile). This routine makes a copy of the information, so you can safely free the data after calling it.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_override_config_data" /><link id="al_push_config_state" /><link id="al_set_config_string" /><link id="al_get_config_string" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_data.data">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_data.lng">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_override_config_file">
<short>Specifies a file containing config overrides.</short>
<descr>
	<p>Specifies a file containing config overrides. These settings will be used in addition to the parameters in the main config file, and where a variable is present in both files this version will take priority. This can be used by application programmers to override some of the config settings from their code, while still leaving the main config file free for the end user to customise. For example, you could specify a particular sample frequency and IBK instrument file, but the user could still use an `allegro.cfg' file to specify the port settings and irq numbers.</p>
	<p>The override config file will not only take precedence when reading, but will also be used for storing values. When you are done with using the override config file, you can call al_override_config_file with a NIL parameter, so config data will be directly read from the current config file again.</p>
	<p>Note: The override file is completely independent from the current configuration. You can e.g. call <link id="al_set_config_file" />, and the override file will still be active. Also the <link id="al_flush_config_file" /> function will only affect the current config file (which can be changed with al_set_config_file), never the overriding one specified with this function. The modified override config is written back to disk whenever you call al_override_config_file.</p>
	<p>Example:</p>
	<code>al_override_config_file ('my.cfg');
  
{ This will read from my.cfg, and if it doesn't find a
  setting, will read from the current config file instead. }
  language := al_get_config_string ('system', 'language', NIL);
  
{ This will always write to my.cfg, no matter if the
  settings is already present or not. }
  al_set_config_string ('system', 'language', 'RU');

{ This forces the changed setting to be written back to
  disk. Else it is written back at the next call to
  al_override_config_file, or when Allegro shuts down. }
  al_override_config_file (NIL);</code>
	<p>Note that this function and <link id="al_override_config_data" /> are mutually exclusive, i.e. calling one will cancel the effects of the other.</p>
</descr>
<seealso>
	<link id="al_override_config_data" /><link id="al_set_config_file" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_override_config_file.filename">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_override_config_data">
<short>Specifies a block of data containing config overrides.</short>
<descr>
	<p>Version of <link id="al_override_config_file" /> which uses a block of data that has already been read into memory. The length of the block has to be specified in bytes. Example:</p>
	<code>CONST
{ Force German as system language, Spanish keyboard map. }
  override_data = '[system]'+#13+"language=DE"+#13+'keyboard=ES';
  
  ...
  
  al_override_config_data (override_data, Length (override_data));</code>
	<p>Note that this function and <link id="al_override_config_file" /> are mutually exclusive, i.e. calling one will cancel the effects of the other.</p>
</descr>
<seealso>
	<link id="al_override_config_file" /><link id="al_set_config_data" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_override_config_data.data">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_override_config_data.lng">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_flush_config_file">
<short>Flushes the current config file to disk.</short>
<descr>
	<p>Writes the current config file to disk if the contents have changed since it was loaded or since the latest call to the function.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_override_config_file" /><link id="al_push_config_state" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_push_config_state">
<short>Pushes the current configuration state.</short>
<descr>
	<p>Pushes the current configuration state (filename, variable values, etc). onto an internal stack, allowing you to select some other config source and later restore the current settings by calling <link id="al_pop_config_state" />. This function is mostly intended for internal use by other library functions, for example when you specify a config filename to the <link id="aljstick.al_save_joystick_data">al_save_joystick_data</link> function, it pushes the config state before switching to the file you specified.</p>
</descr>
<seealso>
	<link id="al_pop_config_state" /><link id="al_set_config_file" /><link id="aljstick.al_save_joystick_data">al_save_joystick_data</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_pop_config_state">
<short>Pops a previously pushed configuration state.</short>
<descr>
	<p>Pops a configuration state previously stored by <link id="al_push_config_state" />, replacing the current config source with it.</p>
</descr>
<seealso>
	<link id="al_push_config_state" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_string">
<short>Retrieves a string from the configuration file.</short>
<descr>
	<p>Retrieves a string variable from the current config file. The section name may be set to NIL to read variables from the root of the file, or used to control which set of parameters (eg. sound or joystick) you are interested in reading. Example:</p>
	<code>VAR
  lang: AL_STRING;

  ...

  lang := al_get_config_string ('system', 'language', 'EN');</code>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_argv" /><link id="al_get_config_int" /><link id="al_get_config_float" /><link id="al_get_config_hex" /><link id="al_get_config_id" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_string.Result">
<short>Returns a pointer to the constant string found in the configuration file. If the named variable cannot be found, or its entry in the config file is empty, the value of `def' is returned.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_string.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_string.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_string.def">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_int">
<short>Retrieves an integer from the configuration file.</short>
<descr>
	<p>Reads an integer variable from the current config file. See the comments about <link id="al_get_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_get_config_argv" /><link id="al_get_config_float" /><link id="al_get_config_hex" /><link id="al_get_config_id" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_int.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_int.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_int.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_int.def">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_hex">
<short>Retrieves a hexadecimal value from the configuration file.</short>
<descr>
	<p>Reads an integer variable from the current config file, in hexadecimal format. See the comments about <link id="al_get_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_get_config_argv" /><link id="al_get_config_float" /><link id="al_get_config_int" /><link id="al_get_config_id" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_hex.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_hex.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_hex.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_hex.def">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_float">
<short>Retrieves a float from the configuration file.</short>
<descr>
	<p>Reads a floating point variable from the current config file. See the comments about <link id="al_get_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_get_config_argv" /><link id="al_get_config_hex" /><link id="al_get_config_int" /><link id="al_get_config_id" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_float.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_float.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_float.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_float.def">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_id">
<short>Retrieves a driver ID from a configuration file.</short>
<descr>
	<p>Reads a 4-letter driver ID variable from the current config file. See the comments about <link id="al_get_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_get_config_argv" /><link id="al_get_config_hex" /><link id="al_get_config_int" /><link id="al_get_config_float" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_id.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_id.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_id.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_id.def">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_config_argv">
<short>Reads a token list from the configuration file.</short>
<descr>
	<p>Reads a token list (words separated by spaces) from the current config file. The token list is stored in a temporary buffer that will be clobbered by the next call to al_get_config_argv, so the data should not be expected to persist.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_get_config_float" /><link id="al_get_config_hex" /><link id="al_get_config_int" /><link id="al_get_config_id" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_config_argv.Result">
<short>Returns an argv style argument list and sets `argc' to the number of retrieved tokens. If the variable is not present, returns NIL and sets argc to zero.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_argv.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_argv.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_config_argv.argc">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_string">
<short>Writes a string variable to the current config file.</short>
<descr>
 <p>Writes a string variable to the current config file, replacing any existing value it may have, or removes the variable if <var>val</var> is <var>NIL</var>. The section name may be set to <var>NIL</var> to write the variable to the root of the file, or used to control which section the variable is inserted into. The altered file will be cached in memory, and not actually written to disk until you call <link id="alsystem.al_exit">al_exit</link>. Note that you can only write to files in this way, so the function will have no effect if the current config source was specified with <link id="al_set_config_data" /> rather than <link id="al_set_config_file" />.</p>
 <p>As a special case, variable or section names that begin with a '#' character are treated specially and will not be read from or written to the disk. Addon packages can use this to store version info or other status information into the config module, from where it can be read with the <link id="al_get_config_string" /> function.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_string" /><link id="al_set_config_float" /><link id="al_set_config_hex" /><link id="al_set_config_int" /><link id="al_set_config_id" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_string.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_string.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_string.val">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_int">
<short>Writes an integer in the configuration file.</short>
<descr>
	<p>Writes an integer variable to the current config file. See the comments about <link id="al_set_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_int" /><link id="al_set_config_string" /><link id="al_set_config_float" /><link id="al_set_config_hex" /><link id="al_set_config_id" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_int.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_int.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_int.val">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_hex">
<short>Writes a hexadecimal integer in the configuration file.</short>
<descr>
	<p>Writes an integer variable to the current config file, in hexadecimal format. See the comments about <link id="al_set_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_hex" /><link id="al_set_config_string" /><link id="al_set_config_float" /><link id="al_set_config_int" /><link id="al_set_config_id" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_hex.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_hex.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_hex.val">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_float">
<short>Writes a float in the configuration file.</short>
<descr>
	<p>Writes a floating point variable to the current config file. See the comments about <link id="al_set_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_float" /><link id="al_set_config_string" /><link id="al_set_config_hex" /><link id="al_set_config_int" /><link id="al_set_config_id" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_float.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_float.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_float.val">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_config_id">
<short>Writes a driver ID in the configuration file.</short>
<descr>
	<p>Writes a 4-letter driver ID variable to the current config file. See the comments about <link id="al_set_config_string" />.</p>
</descr>
<seealso>
	<link id="al_set_config_file" /><link id="al_get_config_hex" /><link id="al_set_config_string" /><link id="al_set_config_float" /><link id="al_set_config_hex" /><link id="al_set_config_int" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_id.section">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_id.name">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_config_id.val">
<short></short>
</element>

</module> <!-- alconfig -->


<!--
  ====================================================================
    aldigi
  ====================================================================
-->

<module name="aldigi">
<short>Digital samples routines</short>
<descr>
</descr>

<!-- constant Visibility: default -->
<element name="AL_DIGI_VOICES">
<short>Maximun number of voices allowed.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_SAMPLEptr">
	<short>Pointer to a <link id="AL_SAMPLE" />.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_SAMPLE">
<short>Stores sound data.</short>
<descr>
	<p>A sample structure, which holds sound data, used by the digital sample routines. You can consider all of these fields as read only except priority, loop_start and loop_end, which you can change them for example after <link id="al_load_sample">loading a sample</link> from disk.</p>
	<p>The priority is a value from 0 to 255 (by default set to 128) and controls how hardware voices on the sound card are allocated if you attempt to play more than the driver can handle. This may be used to ensure that the less important sounds are cut off while the important ones are preserved.</p>
	<p>The variables loop_start and loop_end specify the loop position in sample units, and are set by default to the start and end of the sample.</p>
	<p>If you are <link id="al_create_sample">creating your own samples on the fly</link>, you might also want to modify the raw data of the sample pointed by the data field. The sample data are always in unsigned format. This means that if you are loading a PCM encoded sound file with signed 16-bit samples, you would have to XOR every two bytes (i.e. every sample value) with 0x8000 to change the signedness.</p>
</descr>
<seealso>
	<link id="al_load_sample" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.bits">
<short>8 or 16.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.stereo">
<short>Sample type flag.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.freq">
<short>Sample frequency.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.priority">
<short>0..255</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.len">
<short>Length (in samples).</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.loop_start">
<short>Loop start position.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.loop_end">
<short>Loop finish position.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.param">
<short>INTERNAL USE ONLY.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_SAMPLE.data">
<short>Raw sample data.</short>
</element>

<!-- function type Visibility: default -->
<element name="AL_SAMPLE_LOAD_FUNC">
<short>Defines the loader function.</short>
<seealso>
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_SAMPLE_LOAD_FUNC.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_SAMPLE_LOAD_FUNC.filename">
<short></short>
</element>

<!-- function type Visibility: default -->
<element name="AL_SAMPLE_SAVE_FUNC">
<short>Defines the loader function.</short>
<seealso>
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_SAMPLE_SAVE_FUNC.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_SAMPLE_SAVE_FUNC.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_SAMPLE_SAVE_FUNC.spl">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_sample">
<short>Loads a sample from a file.</short>
<descr>
	<p>Loads a sample from a file, supporting both mono and stereo WAV and mono VOC files, in 8 or 16-bit formats, as well as formats handled by functions registered using <link id="al_register_sample_file_type" />. Example:</p>
	<code>VAR
  sample: AL_SAMPLEptr;
BEGIN
  sample := al_load_sample (user_input);
  IF sample = NIL THEN
  BEGIN
    al_message ('Couldn''t load sample');
    EXIT;
  END;
END;</code>
</descr>
<errors>
	Remember to free this sample later to avoid memory leaks.
</errors>
<seealso>
	<link id="al_destroy_sample" />
	<link id="al_load_voc" />
	<link id="al_load_wav" />
	<link id="al_play_sample" />
	<link id="al_save_sample" />
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_sample.Result">
<short>Returns a pointer to the <link id="AL_SAMPLE" /> or NIL on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_sample.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_wav">
<short>Loads a sample from a RIFF WAV file.</short>
<descr>
	<p>Loads a sample from a RIFF WAV file. Example:</p>
	<code>VAR
  sample: AL_SAMPLEptr;
BEGIN
  sample := al_load_wav ('scream.wav');
  IF sample = NIL THEN
  BEGIN
    al_message ('Couldn''t scare user!');
    EXIT;
  END;
END;</code>
</descr>
<errors>
	Remember to free this sample later to avoid memory leaks.
</errors>
<seealso>
	<link id="al_load_sample" />
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_wav.Result">
<short>Returns a pointer to the <link id="AL_SAMPLE" /> or NIL on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_wav.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_voc">
<short>Loads a sample from a Creative Labs VOC file. </short>
<descr>
	<p>Loads a sample from a Creative Labs VOC file. Example:</p>
	<code>VAR
  sample: AL_SAMPLEptr;
BEGIN
  sample := al_load_wav ('alarm.voc');
  IF sample = NIL THEN
  BEGIN
    al_message ('Couldn''t alert user!');
    EXIT;
  END;
END;</code>
</descr>
<errors>
	Remember to free this sample later to avoid memory leaks.
</errors>
<seealso>
	<link id="al_load_sample" />
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_voc.Result">
<short>Returns a pointer to the <link id="AL_SAMPLE" /> or NIL on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_voc.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_create_sample">
<short>Constructs a new sample structure of the specified type.</short>
<descr>
	<p>Constructs a new sample structure of the specified type. Read <link id="AL_SAMPLE" /> for an internal description of the structure.</p>
</descr>
<errors>
	Remember to free this sample later to avoid memory leaks.
</errors>
<seealso>
	<link id="al_load_sample" />
	<link id="al_destroy_sample" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_create_sample.Result">
<short>Returns a pointer to the created sample, or NILL if the sample could not be created.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sample.bits">
<short>8 or 16.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sample.stereo">
<short>Zero for mono samples and non-zero for stereo samples.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sample.freq">
<short>The frequency in hertz.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_sample.len">
<short>The number of samples you want to allocate for the full sound buffer.</short>
</element>

<!-- function Visibility: default -->
<element name="al_save_sample">
<short>Writes a sample into a file.</short>
<descr>
	<p>Writes a sample into a file. The output format is determined from the filename extension. At present Allegro does not natively support the writing of any sample formats, so you must register a custom saver routine with <link id="al_register_sample_file_type" />. Example:</p>
	<code>IF al_save_sample ('sound.wav', sample) &lt;&gt; 0 THEN
  BEGIN
    al_message ('Couldn''t save sample!');
    EXIT;
  END;</code>
</descr>
<seealso>
	<link id="al_load_sample" />
	<link id="al_register_sample_file_type" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_save_sample.Result">
<short>Returns zero on success, non-zero otherwise.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_sample.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_sample.spl">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_destroy_sample">
<short>Destroys a sample structure when you are done with it.</short>
<descr>
	<p>Destroys a sample structure when you are done with it. It is safe to call this even when the sample might be playing, because it checks and will kill it off if it is active. Use this to avoid memory leaks in your program.</p>
</descr>
<seealso>
	<link id="al_create_sample" />
	<link id="al_load_sample" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_destroy_sample.spl">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_play_sample">
<short>Plays a sample.</short>
<descr>
	<p>Triggers a sample at the specified volume, pan position, and frequency. The parameters `vol' and `pan' range from 0 (min/left) to 255 (max/right). Frequency is relative rather than absolute: 1000 represents the frequency that the sample was recorded at, 2000 is twice this, etc. If `loop' is not zero, the sample will repeat until you call <link id="al_stop_sample" /><!--, and can be manipulated while it is playing by calling adjust_sample()-->. Example:</p>
	<code>{ Scream from the left speaker, twice the freq. }
  al_play_sample (scream, 255, 0, 2000, 0);</code>
</descr>
<seealso>
	<link id="alsound.al_install_sound">al_install_sound</link>
	<link id="al_load_sample" />
	<link id="al_stop_sample" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_play_sample.Result">
<short>Returns the voice number that was allocated for the sample or negative if no voices were available.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_sample.spl">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_sample.vol">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_sample.pan">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_sample.freq">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_sample.loop">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_stop_sample">
<short>Kills off a sample.</short>
<descr>
	<p>Kills off a sample, which is required if you have set a sample going in looped mode. If there are several copies of the sample playing, it will stop them all.</p>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="al_stop_sample.spl">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_register_sample_file_type">
<short>Registers custom loading/saving sample routines.</short>
<descr>
	<p>Informs the <link id="al_load_sample" /> function of a new sample file type, providing routines to read and write samples in this format (either function may be NIL). Example:</p>
	<code>FUNCTION load_mp3 (filename: STRING): AL_SAMPLEptr; CDECL;
BEGIN
             ...
END;

             ...
  al_register_sample_file_type ('mp3', @load_mp3, NIL);</code>
</descr>
<errors>
	Do not forget to declare the function as CDECL.
</errors>
<seealso>
	<link id="al_load_sample" />
	<link id="al_save_sample" />
	<link id="AL_SAMPLE_LOAD_FUNC" />
	<link id="AL_SAMPLE_SAVE_FUNC" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_register_sample_file_type.ext">
<short>Extension that identifies the file format.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_register_sample_file_type.load">
<short>Pointer to the loader funcion.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_register_sample_file_type.save">
<short>Pointer to the saver function.</short>
</element>

</module> <!-- aldigi -->


<!--
  ====================================================================
    aldraw
  ====================================================================
-->

<module name="aldraw">
<short>Drawing functions.</short>
<descr>
	<p><!-- Except for _putpixel(), -->All these routines are affected by the current drawing mode and the clipping rectangle of the destination bitmap. Unless specified otherwise, all coordinates for drawing operations are inclusive, and they, as well as lengths, are specified in pixel units.</p>
</descr>

<!-- procedure Visibility: default -->
<element name="al_set_clip_rect">
<short>Sets the clipping rectangle of a bitmap.</short>
<descr>
	<p>Each bitmap has an associated clipping rectangle, which is the area of the image that it is ok to draw onto. Nothing will be drawn to positions outside this space. This function sets the clipping rectangle for the specified bitmap. Pass the coordinates of the top-left and bottom-right corners of the clipping rectangle in this order; these are both inclusive, i.e. al_set_clip_rect(bitmap, 16, 16, 32, 32) will allow drawing to (16, 16) and (32, 32), but not to (15, 15) and (33, 33).</p>
	<p>Drawing operations will be performed (at least partially) on the bitmap as long as the first coordinates of its clipping rectangle are not greater than the second coordinates and its intersection with the actual image is non-empty. If either condition is not fulfilled, drawing will be turned off for the bitmap, e.g.</p>
	<code>al_set_clip_rect (bmp, 0, 0, -1, -1); { disable drawing on bmp }</code>
	<p>Note that passing "out-of-bitmap" coordinates is allowed, but they are likely to be altered<!-- (and so the coordinates returned by get_clip_rect() will be different) -->. However, such modifications are guaranteed to preserve the external effect of the clipping rectangle, that is not to modify the actual area of the image that it is ok to draw onto.</p>	
</descr>
<seealso>
	<link id="al_add_clip_rect" />
	<link id="al_set_clip_state" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_rect.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_rect.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_rect.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_rect.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_rect.y2">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_add_clip_rect">
<short>Intersects a bitmap's clipping rectangle with the given area.</short>
<descr>
	<p>Sets the clipping rectangle of the specified bitmap as the intersection of its current clipping rectangle and the rectangle described by the four coordinates.</p>
</descr>
<seealso>
	<link id="al_set_clip_rect" />
	<link id="al_set_clip_state" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_add_clip_rect.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_add_clip_rect.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_add_clip_rect.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_add_clip_rect.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_add_clip_rect.y2">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_clip_state">
<short>Turns on or off the clipping of a bitmap.</short>
<descr>
	<p>Turns on or off clipping for the specified bitmap. Turning clipping off may slightly speed up some drawing operations (usually a negligible difference, although every little helps) but will result in your program dying a horrible death if you try to draw beyond the edges of the bitmap.</p>
</descr>
<seealso>
	<link id="al_set_clip_rect" />
	<link id="al_add_clip_rect" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_state.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_clip_state.state">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_SOLID">
<short>The default, solid color drawing</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_XOR">
<short>Exclusive-or drawing</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_COPY_PATTERN">
<short>Multicolored pattern fill</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_SOLID_PATTERN">
<short>Single color pattern fill</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_MASKED_PATTERN">
<short>Masked pattern fill</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DRAW_MODE_TRANS">
<short>Translucent color blending</short>
<descr>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_drawing_mode">
<short>Sets the graphics drawing mode.</short>
<descr>
	<p>Sets the graphics drawing mode. This only affects the geometric routines like pixels, lines, rectangles, circles, polygons, floodfill, etc, not the text output, blitting, or sprite drawing functions. The mode should be one of the following constants:</p>
	<table>
		<tr><td>AL_DRAW_MODE_SOLID</td><td>the default, solid color drawing</td></tr>
		<tr><td>AL_DRAW_MODE_XOR</td><td>exclusive-or drawing</td></tr>
		<tr><td>AL_DRAW_MODE_COPY_PATTERN</td><td>multicolored pattern fill</td></tr>
		<tr><td>AL_DRAW_MODE_SOLID_PATTERN</td><td>single color pattern fill</td></tr>
		<tr><td>AL_DRAW_MODE_MASKED_PATTERN</td><td>masked pattern fill</td></tr>
		<tr><td>AL_DRAW_MODE_TRANS</td><td>translucent color blending</td></tr>
	</table>
	<p>In AL_DRAW_MODE_SOLID, pixels of the bitmap being drawn onto are simply replaced by those produced by the drawing function.</p>
	<p>In AL_DRAW_MODE_XOR, pixels are written to the bitmap with an exclusive-or operation rather than a simple copy, so drawing the same shape twice will erase it. Because it involves reading as well as writing the bitmap memory, xor drawing is a lot slower than the normal replace mode.</p>
	<p>With the patterned modes, you provide a pattern bitmap which is tiled across the surface of the shape. Allegro stores a pointer to this bitmap rather than copying it, so you must not destroy the bitmap while it is still selected as the pattern. The width and height of the pattern must be powers of two, but they can be different, eg. a 64x16 pattern is fine, but a 17x3 one is not. The pattern is tiled in a grid starting at point (x_anchor, y_anchor). Normally you should just pass zero for these values, which lets you draw several adjacent shapes and have the patterns meet up exactly along the shared edges. Zero alignment may look peculiar if you are moving a patterned shape around the screen, however, because the shape will move but the pattern alignment will not, so in some situations you may wish to alter the anchor position.</p>
	<p>When you select AL_DRAW_MODE_COPY_PATTERN, pixels are simply copied from the pattern bitmap onto the destination bitmap. This allows the use of multicolored patterns, and means that the color you pass to the drawing routine is ignored. This is the fastest of the patterned modes.</p>
	<p>In AL_DRAW_MODE_SOLID_PATTERN, each pixel in the pattern bitmap is compared with the mask color, which is zero in 256-color modes or bright pink for truecolor data (maximum red and blue, zero green). If the pattern pixel is solid, a pixel of the color you passed to the drawing routine is written to the destination bitmap, otherwise a zero is written. The pattern is thus treated as a monochrome bitmask, which lets you use the same pattern to draw different shapes in different colors, but prevents the use of multicolored patterns.</p>
	<p>AL_DRAW_MODE_MASKED_PATTERN is almost the same as AL_DRAW_MODE_SOLID_PATTERN, but the masked pixels are skipped rather than being written as zeros, so the background shows through the gaps.</p>
	<p>In AL_DRAW_MODE_TRANS, the global color_map table or truecolor blender functions are used to overlay pixels on top of the existing image. This must only be used after you have set up the color mapping table (for 256 color modes) or blender functions (for truecolor modes). Because it involves reading as well as writing the bitmap memory, translucent drawing is very slow if you draw directly to video RAM, so wherever possible you should use a memory bitmap instead.</p>	
</descr>
<seealso>
	<link id="al_xor_mode" />
	<link id="al_solid_mode" />
	<link id="al256tra.al_set_color_map">al_set_color_map</link>
	<link id="altrutra.al_set_trans_blender">al_set_trans_blender</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_drawing_mode.mode">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_drawing_mode.pattern">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_drawing_mode.x_anchor">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_drawing_mode.y_anchor">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_xor_mode">
<short>Shortcut for toggling xor drawing mode on and off.</short>
<descr>
	<p>This is a shortcut for toggling xor drawing mode on and off. Calling al_xor_mode(TRUE) is equivalent to <link id="al_drawing_mode" />(<link id="AL_DRAW_MODE_XOR" />, NIL, 0, 0). Calling al_xor_mode(FALSE) is equivalent to <link id="al_drawing_mode" />(<link id="AL_DRAW_MODE_SOLID" />, NIL, 0, 0).</p>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_xor_mode.aOn">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_solid_mode">
<short>Shortcut for selecting solid drawing mode.</short>
<descr>
	<p>This is a shortcut for selecting solid drawing mode. It is equivalent to calling <link id="al_drawing_mode" />(<link id="AL_DRAW_MODE_SOLID" />, NIL, 0, 0).</p>
</descr>
<seealso>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_clear_bitmap">
<short>Clears the bitmap to color 0.</short>
<descr>
</descr>
<seealso>
	<link id="al_clear_to_color" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_clear_bitmap.bitmap">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_clear_to_color">
<short>Clears the bitmap to the specified color.</short>
<descr>
	<p>Clears the bitmap to the specified color. Example:</p>
	<code>{ Clear the screen to red. }
  al_clear_to_color (bmp, al_makecol (255, 0, 0));</code>
</descr>
<seealso>
	<link id="al_clear_bitmap" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_clear_to_color.bitmap">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_clear_to_color.color">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_getpixel">
<short>Reads a pixel from a bitmap.</short>
<descr>
	<p>Reads a pixel from point (x, y) in the bitmap.</p>
</descr>
<seealso>
	<link id="al_putpixel" />
	<link id="alcolor" />
	<link id="alpalete" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_getpixel.Result">
	<short>Returns -1 if the point lies outside the bitmap (ignoring the clipping rectangle), otherwise the value of the pixel in the color format of the bitmap. <b>Warning:</b> -1 is also a valid value for pixels contained in 32-bit bitmaps with alpha channel (when R,G,B,A are all equal to 255) so you can't use the test against -1 as a predicate for such bitmaps.<!-- In this cases, the only reliable predicate is is_inside_bitmap(). --></short>
</element>

<!-- argument Visibility: default -->
<element name="al_getpixel.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_getpixel.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_getpixel.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_putpixel">
<short>Writes a pixel into a bitmap.</short>
<descr>
	<p>Writes a pixel to the specified position in the bitmap, using the current drawing mode and the bitmap's clipping rectangle. Example:</p>
	<code>al_putpixel (AL_SCREEN, 10, 30, some_color);</code>
</descr>
<seealso>
	<link id="al_getpixel" />
	<link id="alcolor.al_makecol">al_makecol</link>
	<link id="al_drawing_mode" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_putpixel.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_putpixel.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_putpixel.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_putpixel.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_vline">
<short>Draws a vertical line onto the bitmap.</short>
<descr>
	<p>Draws a vertical line onto the bitmap, from point (x, y1) to (x, y2).</p>
</descr>
<seealso>
	<link id="al_hline" />
	<link id="al_line" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_vline.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_vline.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_vline.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_vline.y2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_vline.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_hline">
<short>Draws a horizontal line onto the bitmap.</short>
<descr>
	<p>Draws a horizontal line onto the bitmap, from point (x1, y) to (x2, y).</p>
</descr>
<seealso>
	<link id="al_vline" />
	<link id="al_line" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_hline.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hline.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hline.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hline.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_hline.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_line">
<short>Draws a line onto the bitmap.</short>
<descr>
	<p>Draws a line onto the bitmap, from point (x1, y1) to (x2, y2).</p>
</descr>
<seealso>
	<link id="al_fastline" />
	<link id="al_vline" />
	<link id="al_hline" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_line.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_line.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_line.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_line.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_line.y2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_line.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fastline">
<short>Faster version of line().</short>
<descr>
	<p>Faster version of the previous function. Note that pixel correctness is not guaranteed for this function.</p>
</descr>
<seealso>
	<link id="al_line" />
	<link id="al_vline" />
	<link id="al_hline" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.y2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fastline.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rect">
<short>Draws an outline rectangle.</short>
<descr>
	<p>Draws an outline rectangle with the two points as its opposite corners.</p>
</descr>
<seealso>
	<link id="al_rectfill" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.y2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rect.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rectfill">
<short>Draws a solid filled rectangle.</short>
<descr>
	<p>Draws a solid, filled rectangle with the two points as its opposite corners.</p>
</descr>
<seealso>
	<link id="al_rect" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.y1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.y2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_rectfill.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_circle">
<short>Draws a circle.</short>
<descr>
	<p>Draws a circle with the specified centre and radius.</p>
</descr>
<seealso>
	<link id="al_circlefill" />
	<link id="al_ellipse" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_circle.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circle.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circle.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circle.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circle.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_circlefill">
<short>Draws a filled circle.</short>
<descr>
	<p>Draws a filled circle with the specified centre and radius.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_ellipsefill" />
	<link id="al_circle" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_circlefill.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circlefill.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circlefill.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circlefill.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_circlefill.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_ellipse">
<short>Draws an ellipse.</short>
<descr>
	<p>Draws an ellipse with the specified centre and radius.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_ellipsefill" />
	<link id="al_circle" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.rx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.ry">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipse.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_ellipsefill">
<short>Draws a filled ellipse.</short>
<descr>
	<p>Draws a filled ellipse with the specified centre and radius.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_ellipse" />
	<link id="al_circle" />
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.rx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.ry">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ellipsefill.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_floodfill">
<short>Floodfills an enclosed area.</short>
<descr>
	<p>Floodfills an enclosed area, starting at point (x, y), with the specified color.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_floodfill.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_floodfill.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_floodfill.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_floodfill.color">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_polygon">
<short>Draws a filled polygon.</short>
<descr>
	<p>Draws a filled polygon with an arbitrary number of corners. Pass the number of vertices and an array containing a series of x, y points (a total of vertices*2 values). Example:</p>
	<code>VAR
  points: ARRAY [0..11] OF AL_INT = ( 50, 50,   100, 100,  100, 150,
				      50, 200,  0,   150,  0,   100 );
BEGIN
  ...
  al_clear_to_color (al_screen, al_makecol (255, 255, 255));
  al_polygon (al_screen, 6, points, al_makecol(0, 0, 0));
  ...
END.</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_drawing_mode" />
	<link id="alcolor.al_makecol">al_makecol</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_polygon.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_polygon.vertices">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_polygon.points">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_polygon.color">
<short></short>
</element>

</module> <!-- aldraw -->


<!--
  ====================================================================
    aldtfile
  ====================================================================
-->

<module name="aldtfile">
<short>Datafile management</short>
<descr>
	<p>Datafiles are created by the grabber utility (see grabber.txt at the tools directory for more information), and have a `.dat' extension. They can contain bitmaps, palettes, fonts, samples, MIDI music, FLI/FLC animations, and any other binary data that you import. You could distribute your bitmaps and samples in a myriad of separate files, but packing them in a few `.dat' binaries has a few advantages:</p>
	<ul>
		<li>On some platforms loading a single big datafile at once is faster than loading individual resources one by one.</li>
		<li>Instead of several loops for your resources, you can write a single line of code with just a single point of failure to take care of.</li>
		<li>You can potentially reduce the size of your data by enabling compression on your datafiles. Less download time for your end users, less wait during loading screens!</li>
		<li>If you don't need to load the whole datafile at once, you can still enable individual file compression. It is slightly worse than global compression, but it is very fast with loading times because Allegro can easily seek inside the datafile to find a specific object.</li>
		<li>Even without encryption, most end users of your application won't be able to look at or modify the resources for your game. A missing sound file or a modified bitmap could potentially crash the game if you haven't considered this in your loading code!</li>
		<li>It looks much more professional and convenient to distribute levels! For example, if you found a bug in a level of your game, just distribute your new `level4.dat' and tell users to overwrite their old version. </li>
	</ul>
	<p>Allegro allows you to load datafiles once and forget about them. But if you have many levels it can be wise to load only the resources required for the current level. You can accomplish the later by separating levels in different datafiles, or using functions like <link id="al_load_datafile_object" /> to avoid loading everything at once.<!--> You can even read directly from a specific datafile object with the pack_fopen() function. --></p>
	<!-- On some platforms you can attach datafiles to your binary, potentially reducing your game distribution down to a single executable file. Try the example exexedat on your platform to see if this is possible. However, this is not recommended for big programs: a single update to your code or binary data would force end users to download again a potentially big file, no matter how small your change is. The same warning goes for the tools dat2s or dat2c, which convert datafiles into assembler and C code respectively, prepared to be included directly in your binary. -->
	<p>Remember that with Allegro truecolor images can only be loaded after you have set a graphics mode. This is true for datafiles too. Load all your data after you have set the graphics mode, otherwise the pixel format (RGB or BGR) will not be known and the datafile may be converted wrongly.<!-- Oh, and read carefully the warning of fixup_datafile() if you plan on switching resolutions during runtime. --></p>
	<!-- Note: even though Allegro datafiles provide encryption, you should consider it weak, so don't plan on hiding there the plans for a Death Star or something. Determinate knowledgeable users will be able to rip your resources no matter how hard you try to hide them! Use the encryption only as a slight deterrent towards unwanted tampering of your data. How to crack an encrypted datafile is left as an exercise to the reader, though. -->
	<p>Using datafiles once they are loaded is quite simple: you access the elements of the <link id="AL_DATAFILE" /> as a normal array. Read the <link id="AL_DATAFILE" /> description for several examples on how to access their data.</p>
</descr>

<!-- pointer type Visibility: default -->
<element name="AL_DATAFILE_PROPERTYptr">
	<short>Pointer to <link id="AL_DATAFILE_PROPERTY" /></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="AL_DATAFILE_PROPERTY">
<short>Stores a property of a datafile object.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_PROPERTY.dat">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_PROPERTY.ftype">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_DATAFILE_PROPERTY_LISTptr">
	<short>Pointer to <link id="AL_DATAFILE_PROPERTY_LIST" /></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="AL_DATAFILE_PROPERTY_LIST">
<short>Stores a list of propertyes of a datafile object.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_DATAFILEptr">
	<short>Pointer to a <link id="AL_DATAFILE">datafile</link>.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="AL_DATAFILE">
<short>Stores an Allegro datafile in memory.</short>
<descr>
	<p>In order to access the contents of a datafile, you will need to know where each object is located. The easiest way to do this is by integer index, using an automatically generated header file. With the grabber, type a name into the "Header:" field, and the object indexes will be written to this file whenever the datafile is saved. With the dat utility, use the '-h' option, eg. "dat filename.dat -h filename.h". The header will define C preprocessor symbols for each object in the datafile, for example:</p>
	<pre>#define SOME_DATA                        0        /* DATA */
#define SOME_MORE_DATA                   1        /* DATA */</pre>
	<p>Then you can translate this file to Pascal using the h2pas utility or by hand.</p>
	<code>CONST
  SOME_DATA = 0; { DATA }
  SOME_MORE_DATA = 1; { DATA }</code>
	<p>To prevent name conflicts, you can specify a prefix string for these definitions by typing it into the "Prefix:" field in the grabber or using the '-p' option to dat.</p>
	<p>To load a datafile into memory, call the function <link id="al_load_datafile" />. This will load the entire file, returning a pointer to it, or NIL on error. When the data is no longer required, the entire thing can be destroyed by calling <link id="al_unload_datafile" />. When you load a datafile, you will obtain a pointer to an array of <link id="AL_DATAFILE_OBJECT" /> structures. The only really important piece of information here is the <link id="AL_DATAFILE_OBJECT.dat" /> field, which points to the contents of the object. What type of data this is will depend on the type of object: for bitmaps it will be an Allegro <link id="albitmap.AL_BITMAP">AL_BITMAP</link> structure, for RLE sprites an <link id="alsprrle.AL_RLE_SPRITE">AL_RLE_SPRITE</link>, for fonts a <link id="alfont.AL_FONT">AL_FONT</link> structure, etc. In most cases you can pass this pointer directly to the relevant Allegro library functions, but some times you will need to assign it to an object.</p>
	<p>For example, if you have a datafile called `myfile.dat', which contains a bitmap called COOL_PICTURE, and you have used it to produce a header called `myfile.inc', you could display the bitmap with the code:</p>
	<code>...
{$I myfile.inc}

PROCEDURE ShowTheBitmap;
VAR
  Dat: AL_DATAFILEptr;
  Bmp: AL_BITMAPptr;
BEGIN
  Dat := al_load_datafile ('myfile.dat');
  IF (Dat = NIL) THEN
  BEGIN
  { Report an error! }
    EXIT;
  END;
  Bmp := Dat^[COOL_PICTURE].dat;
  al_blit (Bmp, al_screen, 0, 0, 0, 0, Bmp^.w, Bmp^.h);
  al_unload_datafile (Dat);
END;</code>
	<p>If a datafile contains nested child datafiles, the header will prefix the names of objects in the sub-files with the name of their parent datafile. It will also define a count of the number of objects in the child file, which may be useful if for example the child datafile contains several bitmaps which form a <i>run</i> animation, and you want your code to automatically adjust to the number of frames in the datafile.</p>
	<p>For example, the following datafile:</p>
	<pre>"FILE" - NESTED_FILE
  |- "BMP" - A_BITMAP
  |- "FONT" - A_FONT
"DATA" - SOME_DATA
"DATA" - SOME_MORE_DATA</pre>
	<p>Will produce the header:</p>
	<pre>#define NESTED_FILE                      0        /* FILE */

#define NESTED_FILE_A_BITMAP             0        /* BMP  */
#define NESTED_FILE_A_FONT               1        /* FONT */
#define NESTED_FILE_COUNT                2

#define SOME_DATA                        1        /* DATA */
#define SOME_MORE_DATA                   2        /* DATA */</pre>
       <p>The main datafile contains three objects (NESTED_FILE, SOME_DATA, and SOME_MORE_DATA) with consecutive indexes, while the child datafile contains the two objects A_BITMAP and A_FONT. To access these objects you need to reference both the parent and child datafiles, eg:</p>
       <code>VAR
  Dat, Nested: AL_DATAFILEptr;
  TheFont: AL_FONTptr;
BEGIN
  Dat := al_load_datafile ('whatever.dat');
  Nested := Dat^[NESTED_FILE].dat;
  TheFont := Nested^[NESTED_FILE_A_FONT].dat;
  al_unload_datafile (Dat);
END;</code>
<!--
If you need to access object property strings from within your program, you can use the function:

       char *get_datafile_property(DATAFILE *dat, int type);

This will return a pointer to the property string if it can be found, and an empty string (not null!) if it does not exist. One possible use of this function is to locate objects by name, rather than using the indexes from a header file. The datafile array is ended by an object of type DAT_END, so to search the datafile dat for the object "my_object" you could use the code:

       const int name_type = DAT_ID('N','A','M','E');
       for (i=0; dat[i].type != DAT_END; i++) {
          if (stricmp(get_datafile_property(dat+i, name_type),
                      "my_object") == 0) {
             /* found the object at index i */
          }
       }
       /* not found... */

If you prefer to access objects by name rather than index number, you can use the function:

       DATAFILE *find_datafile_object(DATAFILE *dat, char *objectname);

This will search an already loaded datafile for an object with the specified name, returning a pointer to it, or NULL if the object cannot be found. It understands '/' and '#' separators for nested datafile paths.
-->
	<p>It is also possible to selectively load individual objects from a datafile, with the function <link id="al_load_datafile_object" />. This searches the datafile for an object with the specified name, so obviously it won't work if you strip the name properties out of the file. Because this function needs to seek through the data, it will be extremely slow if you have saved the file with global compression. If you are planning to load objects individually, you should save the file uncompressed or with individual compression per-object. Because the returned datafile points to a single object rather than an array of objects, you should access it with the pointer access syntax rather than array access syntax, and when you are done you should free the object with the function <link id="al_unload_datafile_object" />. Example:</p>
	<code>VAR
  MusicObject: AL_DATAFILE_OBJECTptr;
		...
  MusicObject := al_load_datafile_object ('datafile.dat', 'MUSIC');
  al_play_midi (MusicObject^.dat);
	...
  al_unload_datafile_object (MusicObject);</code>
<!--
Alternatively, the packfile functions can open and read directly from the contents of a datafile object. You do this by calling pack_fopen() with a fake filename in the form "filename.dat#object_name". The contents of the object can then be read in an identical way to a normal disk file, so any of the file access functions in Allegro (eg. load_pcx() and set_config_file()) can be used to read from datafile objects. Note that you can't write to datafiles in this way: the fake file is read only. Also, you should save the file uncompressed or with per-object compression if you are planning on using this feature. Finally, be aware that the special Allegro object types aren't the same format as the files you import the data from, so if for example you want to use load_pcx to read an image from a datafile, you should import it as a binary data chunk rather than as a BITMAP object.

If you have appended a datafile to the end of your executable with the exedat utility, use load_datafile("#") to read the entire thing into memory, load_datafile_object("#", "object_name") to load a specific object, and pack_fopen("#object_name", F_READ) to read one of the objects directly with your own code. Note that unless you use the previous functions to load the appended data, the OS will not load it into memory just because you are running the program, so you shouldn't have problems attaching datafiles to your binary larger than the available system memory.
-->
	<p>By default, all graphic objects loaded from a datafile will be converted into the current color depth. This conversion may be both lossy and very slow, particularly when reducing from truecolor to 256 color formats, so you may wish to disable it by calling <link id="algraph.al_set_color_conversion">al_set_color_conversion</link> (<link id="algraph.AL_COLORCONV_NONE">AL_COLORCONV_NONE</link>) or  <link id="algraph.al_set_color_conversion">al_set_color_conversion</link> (<link id="algraph.AL_COLORCONV_PARTIAL">AL_COLORCONV_PARTIAL</link>) before your call to <link id="al_load_datafile" />.</p>
<!--
Custom datafile objects

Some of the objects in a datafile, for example palettes and FLI animations, are simply treated as blocks of binary data, but others are loaded into special formats such as bitmap structures or compiled sprites. It is possible to extend the datafile system to support your own custom object types, eg. map objects for a tile based engine, or level data for a platform game. Obviously the grabber has no way of understanding this data, but it will allow you to import binary data from external files, so you can grab information produced by your own utilities. If you are happy with the data being loaded as a simple binary block, that is all you need to do, but if you need to load it into a specific structure, read on...

Your custom objects must be given a unique type ID, which is formed from four ASCII characters (by convention all uppercase A-Z). If you don't use all four characters, the string should be padded with spaces (ASCII 32). You should use this ID when creating the objects in the grabber (select New/Other and type in the ID string), and in your code you should define an identifier for the type, eg:

       #define DAT_MAPDATA  DAT_ID('M','A','P','D')

You then need to write functions for loading and destroying objects of this type, in the form:

       void *load_mapdata(PACKFILE *f, long size)
       {
          /* Allegro will call this function whenever an object of your custom 
           * type needs to be loaded from a datafile. It will be passed a 
           * pointer to the file from which the data is to be read, and the size 
           * of the object in bytes. It should return a pointer to the loaded 
           * data, which will be stored in the dat field of the datafile object 
           * structure, or NULL if an error occurs. The file will have been 
           * opened as a sub-chunk of the main datafile, so it is safe to read 
           * past the end of the object (if you attempt this, Allegro will 
           * return EOF), and it is also safe to return before reading all the 
           * data in the chunk (if you do this, Allegro will skip any unused 
           * bytes before starting to read the next object). You should _not_ 
           * close the file when you are done: this will be handled by the 
           * calling function. To clarify how all this works, here's an example 
           * implementation of a null-terminated string object:
           */

          #define MAX_LEN  256

          char buf[MAX_LEN];
          char *p;
          int i, c;

          for (i=0; i&lt;;MAX_LEN-1; i++) {
             if ((c = pack_getc(f)) == EOF)
                break;

             buf[i] = c;
          }

          buf[i] = 0;

          p = malloc(i+1);
          strcpy(p, buf);

          return p;
       }

       void destroy_mapdata(void *data)
       {
          /* Allegro will call this function whenever an object of your custom 
           * type needs to be destroyed. It will be passed a pointer to the 
           * object (as returned by the load function), and should free whatever 
           * memory the object is using. For example, the simple string object 
           * returned by the above loader could be destroyed with the code:
           */

          if (data)
             free(data);
       }

Finally, before you load your datafile you must tell Allegro about the custom format, by calling:

       register_datafile_object(DAT_MAPDATA, load_mapdata, destroy_mapdata);

It is also possible to integrate support for custom object types directly into the grabber and dat utilities, by copying some special files into the tools/plugins directory. This can be used to add whole new object types and menu commands, or to provide additional import/export routines for the existing formats. See `tools/plugins/plugins.txt' for an overview of how to write your own grabber plugins.
-->
</descr>
<seealso>
	<link id="al_load_datafile" />
	<link id="aldtfile">Datafile routines overview</link>
</seealso>
</element>

<!-- Record type Visibility: default -->
<element name="AL_DATAFILE_OBJECT">
	<short>Stores a simple datafile object.</short>
<descr>
</descr>
<seealso>
	<link id="AL_DATAFILE" />
	<link id="al_load_datafile_object" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_OBJECT.dat">
<short>Pointer to the actual data.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_OBJECT.ftype">
<short>Type of the data.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_OBJECT.size">
<short>Size of the data in bytes.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_DATAFILE_OBJECT.prop">
<short>List of object properties.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_DATAFILE_OBJECTptr">
	<short>Pointer to a <link id="AL_DATAFILE_OBJECT" />.</short>
<descr>
</descr>
<seealso>
	<link id="AL_DATAFILE" />
	<link id="al_load_datafile_object" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_load_datafile">
<short>Loads a datafile into memory.</short>
<descr>
	<p>Loads a datafile into memory in one go.<!-- If the datafile has been encrypted, you must first call packfile_password() to set the appropriate key.--> If the datafile contains truecolor graphics, you must set the video mode or call <link id="algraph.al_set_color_conversion">al_set_color_conversion</link> before loading it. Example:</p>
	<code>VAR
  Dat: AL_DATAFILEptr;
BEGIN
{ Load the resources for our game. }
  Dat := al_load_datafile ('game.dat');
  IF Dat = NIL THEN
  BEGIN
    ErrorMessage ('Couldn''t load sound resources!');
    EXIT;
  END;
{ Use resources. }
  ...
{ Destroy them when we don't need them any more. }
  al_unload_datafile (Dat);
END.</code>
</descr>
<errors>
	<p>Remember to free this DATAFILE later to avoid memory leaks.</p>
</errors>
<seealso>
	<link id="al_unload_datafile" />
	<link id="al_load_datafile_object" />
	<link id="algraph.al_set_color_conversion">al_set_color_conversion</link>
	<!-- fixup_datafile, packfile_password, find_datafile_object, register_datafile_object, -->
	<link id="AL_DATAFILE" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_datafile.Result">
<short>Returns a pointer to the <link id="AL_DATAFILE"/>, or NIL on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_datafile.filename">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_unload_datafile">
<short>Frees all the objects in a datafile.</short>
<descr>
	<p>Frees all the objects in a datafile. Use this to avoid memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_datafile" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_unload_datafile.dat">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_datafile_object">
<short>Loads a specific object from a datafile.</short>
<descr>
	<p>Loads a specific object from a datafile. This won't work if you strip the object names from the file, and it will be very slow if you save the file with global compression. Example:</p>
	<code>{ Load only the music from the datafile. }
  MusicObject := al_load_datafile_object ('datafile.dat', 'MUSIC');
{ Play it and wait a moment for it. }
  al_play_midi (MusicObject^.dat);
          ...
{ Destroy unneeded music. }
  al_unload_datafile_object (MusicObject);</code>
</descr>
<errors>
	<p>Remember to free this <link id="AL_DATAFILE" /> later to avoid memory leaks, but use the correct unloading function!</p>
</errors>
<seealso>
	<link id="al_unload_datafile_object" />
	<link id="al_load_datafile" />
	<link id="algraph.al_set_color_conversion">al_set_color_conversion</link>
	<!-- packfile_password, find_datafile_object, register_datafile_object, -->
	<link id="AL_DATAFILE" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_datafile_object.Result">
<short>Returns a pointer to a single <link id="AL_DATAFILE" /> element whose `dat' member points to the object, or NIL if there was an error or there was no object with the requested name.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_datafile_object.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_datafile_object.objectname">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_unload_datafile_object">
<short>Frees an object previously loaded by <link id="al_load_datafile_object" />.</short>
<descr>
	<p>Frees an object previously loaded by <link id="al_load_datafile_object" />. Use this to avoid memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_datafile_object" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_unload_datafile_object.dat">
<short></short>
</element>

</module> <!-- aldtfile -->


<!--
  ====================================================================
    alfile
  ====================================================================
-->

<module name="alfile">
<short>File and compression routines</short>
<descr>
	<p>The following routines implement a fast buffered file I/O system, which supports the reading and writing of compressed files using a ring buffer algorithm based on the LZSS compressor by Haruhiko Okumura. This does not achieve quite such good compression as programs like zip and lha, but unpacking is very fast and it does not require much memory. Packed files always begin with the 32-bit value <link id="AL_F_PACK_MAGIC" />, and autodetect files with the value <link id="AL_F_NOPACK_MAGIC" />.</p>
	<p>Only the <var>AL_F_*</var> constants are guaranteed to work. Do not use any other flags from DOS/Windows or your code will not compile on another platform.<!-- FA_RDONLY is for directory entries with read-only flag on DOS-like systems or unwritable by current user on Unix-like systems. Hidden files are directory entries that have the hidden flag set (DOS/Windows) or have names starting with '.' (UNIX, excluding '.' and '..'). Flags can be combined using '|' (binary OR operator).--></p>
	<!-- When passed to the functions as the 'attrib' parameter, these flags represent an upper set in which the actual flag set of a matching file must be included. That is, in order for a file to be matching, its attributes may contain any of the specified flags but must not contain any of the unspecified flags. In other words, you explictly exclude the flags that you do not specify. Thus if you pass 'FA_DIREC | FA_RDONLY', normal files and directories will be included as well as read-only files and directories, but not hidden files and directories. Similarly, if you pass 'FA_ARCH' then both archived and non-archived files will be included. If FA_NONE is passed all attributes are excluded and only files with no attributes are returned. Conversely, if you pass FA_ALL, no attributes are excluded so all files are returned (which is what you would usually want). -->
	<!-- Functions which accept wildcards as file names support the meta characters `*' (which means, zero or any quantity of characters) and `?' (which means any character, but only one). -->
</descr>

<!-- procedure Visibility: default -->
<element name="al_get_executable_name">
<short>Obtains the full path to the current executable.</short>
<descr>
	<p>Fills <var>aOutput</var> with the full path to the current executable, writing at most <var>size</var> bytes. This generally comes from <var>argv</var> but on Unix systems it tries to get the information from the <var>/proc</var> filesystem first, searching the directories specified in <var>$PATH</var> if necessary. If this fails too, it tries to find the executable name from the output of the <var>ps</var> command, using <var>argv</var> only as a last resort if all other options fail. Example:</p>
	<code>VAR		
  Name, Text: ARRAY [200] OF CHAR;
          ...
  al_get_executable_name (name, 200);
  StrFmt (Text, 'Running ''%s''\n', Name);	  
  al_message (Text);</code>
	<remark>It is recommendable to use the <var>param (0)</var> function insead of <var>al_get_executable_name</var>.</remark>
	<remark>This function may change in future versions.</remark>
</descr>
</element>

<!-- argument Visibility: default -->
<element name="al_get_executable_name.aOutput">
<short>To store the result.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_executable_name.size">
<short>Size of aOutput in bytes.</short>
</element>

<!-- function Visibility: default -->
<element name="al_replace_filename">
<short>Replaces <var>path+filename</var> with a new filename tail.</short>
<descr>
	<p>Replaces the specified <var>path+filename</var> with a new filename tail, storing at most <var>size</var> bytes into the <var>dest</var> buffer. You can use the same buffer both as input and output because Allegro internally works on a copy of the input before touching <var>dest</var>. Example:</p>
	<code>VAR		
  Name, Text: ARRAY [200] OF CHAR;
          ...
  al_get_executable_name (name, 200);
  al_replace_filename (name, name, 'sound.dat', 200);</code>
	<remark>This function may change in future versions.</remark>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_replace_filename.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_filename.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_filename.path">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_filename.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_filename.size">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_replace_extension">
<short>Replaces <var>filename+extension</var> with a new extension tail.</short>
<descr>
	<p>Replaces the specified <var>filename+extension</var> with a new extension tail, storing at most <var>size</var> bytes into the <var>dest</var> buffer. If the filename doesn't have any extension at all, <var>ext</var> will be appended to it, adding a dot character if needed. You can use the same buffer both as input and output because Allegro internally works on a copy of the input before touching <var>dest</var>. Example:</p>
	<code>al_replace_extension (buf, 'C:\\game\\prog.exe', 'dat', 200);</code>
	<remark>This function may change in future versions.</remark>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_replace_extension.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_extension.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_extension.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_extension.ext">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_replace_extension.size">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_READ">
<short>Open file for reading.</short>
<descr>
	<p>Tells to <link id="al_pack_fopen" /> that the opened file will be for reading.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_WRITE">
<short>Open file for writing, overwriting any existing data.</short>
<descr>
	<p>Tells to <link id="al_pack_fopen" /> that the opened file will be for writing.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_READ_PACKED">
<short>Open file for read a packed file.</short>
<descr>
	<p>Tells to <link id="al_pack_fopen" /> that the opened file will be for reading and it's packed.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_WRITE_PACKED">
<short>Open file for write a packed file.</short>
<descr>
	<p>Tells to <link id="al_pack_fopen" /> that the opened file will be for writing and it's packed.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_WRITE_NOPACK">
<short>Open file for write an unpacked file.</short>
<descr>
	<p>Tells to <link id="al_pack_fopen" /> that the opened file will be for writing and it isn't packed.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_PACK_MAGIC">
<short>Magic number for packed files.</short>
<descr>
	<p>Used to mark packed files.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_NOPACK_MAGIC">
<short>Magic number for unpacked files.</short>
<descr>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_F_EXE_MAGIC">
<short>Magic number for appended data.</short>
<descr>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- alias type Visibility: default -->
<element name="AL_PACKFILEptr">
	<short>Packfile structure, similar to the libc <var>FILE</var> structure.</short>
<descr>
	<p>A packfile structure, similar to the libc <var>FILE</var> structure. Read the beginning of chapter <link id="alfile">File and compression routines</link> for a description on how to obtain/use this structure. Note that prior to version 4.1.18, some internal fields were accidentally documented - but <var>AL_PACKFILEptr</var> should be treated as an opaque structure, just like the libc <var>FILE</var> type.</p>
</descr>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fopen">
<short>Opens a file according to mode.</short>
<descr>
	<p>Opens a file according to mode, which may contain any of the flags:</p>
	<ul>
		<li>`r' - open file for reading.</li>
		<li>`w' - open file for writing, overwriting any existing data.</li>
		<li>`p' - open file in packed mode. Data will be compressed as it is written to the file, and automatically uncompressed during read operations. Files created in this mode will produce garbage if they are read without this flag being set.</li>
		<li>`!' - open file for writing in normal, unpacked mode, but add the value F_NOPACK_MAGIC to the start of the file, so that it can later be opened in packed mode and Allegro will automatically detect that the data does not need to be decompressed.</li>
	</ul>
	<p>Instead of these flags, one of the constants <link id="AL_F_READ" />, <link id="AL_F_WRITE" />, <link id="AL_F_READ_PACKED" />, <link id="AL_F_WRITE_PACKED" /> or <link id="AL_F_WRITE_NOPACK" /> may be used as the mode parameter.</p>
	<p>The packfile functions also understand several "magic" filenames that are used for special purposes. These are:</p>
	<ul>
		<li>`#' - read data that has been appended to your executable file with the exedat utility, as if it was a regular independent disk file.</li>
		<li>`filename.dat#object_name' - open a specific object from a <link id="aldtfile">datafile</link>, and read from it as if it was a regular file. You can treat nested datafiles exactly like a normal directory structure, for example you could open `filename.dat#graphics/level1/mapdata'.</li>
		<li>`#object_name' - combination of the above, reading an object from a datafile that has been appended onto your executable.</li>
	</ul>
	<p>With these special filenames, the contents of a datafile object or appended file can be read in an identical way to a normal disk file, so any of the file access functions in Allegro (eg. <link id="albitmap.al_load_bitmap">al_load_bitmap()</link> and <link id="alconfig.al_set_config_file">al_set_config_file()</link>) can be used to read from them. Note that you can't write to these special files, though: the fake file is read only. Also, you must save your datafile uncompressed or with per-object compression if you are planning on loading individual objects from it (otherwise there will be an excessive amount of seeking when it is read).</p>
	<p>Finally, be aware that the special Allegro object types aren't the same format as the files you import the data from. When you import data like bitmaps or samples into the grabber, they are converted into a special Allegro-specific format, but the `#' marker file syntax reads the objects as raw binary chunks. This means that if, for example, you want to use <var>al_load_bitmap()</var> to read an image from a datafile, you should import it as a binary block rather than as a <link id="albitmap.AL_BITMAP">AL_BITMAP</link> object.</p>
	<p>Example:</p>
	<code>VAR
  InputFile: AL_PACKFILEptr;
BEGIN
  InputFile := al_pack_fopen ('scores.dat', AL_F_READ_PACKED);
  IF InputFile = NIL THEN
  BEGIN
    AbortOnError ('Couldn''t read "scores.dat"!');
    EXIT;
  END;
{ Read stuff }
END.</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fclose" />
	<link id="al_pack_fread" />
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fopen.Result">
  <short>On success, returns a pointer to an <var>AL_PACKFILE</var> structure, and on error it returns <var>NIL</var>.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fclose">
<short>Closes a stream previously opened.</short>
<descr>
	<p>Closes the stream `f' previously opened with <link id="al_pack_fopen" /><!-- or pack_fopen_vtable() -->. After you have closed the stream, performing operations on it will yield errors in your application (e.g. crash it) or even block your OS.</p>
</descr>
<errors>
	<p>This function can fail only when writing to files: if the file was opened in read mode, it will always succeed.</p>
</errors>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fclose.Result">
  <short>Return zero on success. On error, returns an error code.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_feof">
<short>Returns nonzero as soon as you reach the end of the file.</short>
<descr>
	<p>Finds out if you have reached the end of the file. It does not wait for you to attempt to read beyond the end of the file, contrary to the ISO C <var>feof</var> function. The only way to know whether you have read beyond the end of the file is to check the return value of the read operation you use (and be wary of <var>al_pack_*get*^</var> as EOF is also a valid return value with these functions).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
	<link id="al_pack_ferror" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_feof.Result">
  <short>Returns non-zero if you are at the end of the file, zero otherwise.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_ferror">
<short>Tells if an error occurred during an operation on the stream.</short>
<descr>
  <p>Since EOF is used to report errors by some functions, it's often better to use the <link id="al_pack_feof" /> function to check explicitly for end of file and <var>al_pack_ferror</var> to check for errors. Both functions check indicators that are part of the internal state of the stream to detect correctly the different situations.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_ferror.Result">
  <short>Returns nonzero if the error indicator for the stream is set, meaning that an error has occurred during a previous operation on the stream.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_getc">
<short>Returns the next character from a stream.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_getc.Result">
  <short>Returns the next character from the stream `f', or EOF if the end of the file has been reached.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_pack_getc.f">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_putc">
<short>Puts a character in the stream f.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_putc.Result">
  <short>Returns the character written on success, or EOF on error. </short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_igetw">
<short>Like <link id="al_pack_getc" />, but using 16-bit Intel byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_getc" />, but reads a 16-bit word from a file, using Intel byte ordering (least significant byte first, a.k.a. little-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_igetl">
<short>Like <link id="al_pack_getc" />, but using 32-bit Intel byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_getc" />, but reads a 32-bit word from a file, using Intel byte ordering (least significant byte first, a.k.a. little-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_iputw">
<short>Like <link id="al_pack_putc" />, but using 16-bit Intel byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_putc" />, but writes a 16-bit word to a file, using Intel byte ordering (least significant byte first, a.k.a. little-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_putc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_iputl">
<short>Like <link id="al_pack_putc" />, but using 32-bit Intel byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_putc" />, but writes a 32-bit word to a file, using Intel byte ordering (least significant byte first, a.k.a. little-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_putc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_mgetw">
<short>Like <link id="al_pack_getc" />, but using 16-bit Motorola byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_getc" />, but reads a 16-bit word from a file, using Motorola byte ordering (most significant byte first, a.k.a. big-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_mgetl">
<short>Like <link id="al_pack_getc" />, but using 32-bit Motorola byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_getc" />, but reads a 32-bit word from a file, using Motorola byte ordering (most significant byte first, a.k.a. big-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_mputw">
<short>Like <link id="al_pack_putc" />, but using 16-bit Motorola byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_putc" />, but writes a 16-bit word to a file, using Motorola byte ordering (most significant byte first, a.k.a. big-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_putc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_mputl">
<short>Like <link id="al_pack_putc" />, but using 32-bit Motorola byte ordering words.</short>
<descr>
	<p>Like <link id="al_pack_putc" />, but writes a 32-bit word to a file, using Motorola byte ordering (most significant byte first, a.k.a. big-endian).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_putc" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fread">
<short>Reads n bytes from the stream.</short>
<descr>
	<p>Reads <var>n</var> bytes from the stream <var>f</var>, storing them at the memory location pointed to by <var>p</var>. Example:</p>
	<code>VAR
  Buf: ARRAY [0..255] OF BYTE;
    ...
    IF al_pack_fread (@Buf[0], 256, InputFile) &lt;&gt; 256 THEN
      AbortOnError ('Truncated input file!');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
	<link id="al_pack_feof" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fread.Result">
  <short>Returns the number of bytes read, which will be less than <var>n</var> if EOF is reached or an error occurs. Error codes are stored in errno.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fwrite">
<short>Writes n bytes to the stream.</short>
<descr>
	<p>Writes <var>n</var> bytes to the stream <var>f</var> from memory location pointed to by <var>p</var>.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
	<link id="al_pack_fread" />
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fwrite.Result">
  <short>Returns the number of bytes written, which will be less than <var>n</var> if an error occurs. Error codes are stored in errno.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_ungetc">
<short>UNDOCUMENTED</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fgets">
<short>Reads a line from the stream.</short>
<descr>
	<p>Reads a line from the stream <var>f</var>, storing it at location pointed to by <var>p</var>. Stops when a linefeed is encountered, or <var>max</var> bytes have been read. The end of line is handled by detecting the right combination of characters for the platform. This supports CR-LF (DOS/Windows), LF (Unix), and CR (Mac) formats. However, the trailing carriage return is not included in the returned string, in order to provide easy code portability across platforms. If you need the carriage return, use <link id="al_pack_fread" /> and/or <link id="al_pack_getc" /> instead. Example:</p>
	<code>VAR
  Buf: ARRAY [0..255] OF BYTE;

  ...
  WHILE al_pack_fgets (@Buf[0], 256, InputFile) DO
  BEGIN
    { Process input line. }
  END;
  al_fclose (InputFile);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
	<link id="al_pack_fread" />
	<link id="al_pack_getc" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fgets.Result">
  <short>Returns the string on success.</short>
</element>

<!-- function Visibility: default -->
<element name="al_pack_fputs">
<short>Writes a string to the stream.</short>
<descr>
	<p>Writes a string to the stream <var>f</var>. The input string is converted from the current text encoding format to UTF-8 before writing. Newline characters are written as `\r\n' on DOS and Windows platforms. If you don't want this behaviour, use <link id="al_pack_fwrite" /> and/or <link id="al_pack_putc" /> instead.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_pack_fopen" />
	<link id="al_pack_fwrite" />
	<link id="al_pack_putc" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_pack_fputs.Result">
  <short>Returns zero on success or a negative number on error.</short>
</element>
</module> <!-- alfile -->


<!--
  ====================================================================
    alfixed
  ====================================================================
-->

<module name="alfixed">
<short>Fixed point math routines</short>
<descr>
	<p>Allegro provides some routines for working with fixed point numbers, and defines the type <link id="AL_FIXED" /> to be a signed 32-bit integer. The high word is used for the integer part and the low word for the fraction, giving a range of -32768 to 32767 and an accuracy of about four or five decimal places. Fixed point numbers can be assigned, compared, added, subtracted, negated and shifted (for multiplying or dividing by powers of two) using the normal integer operators, but you should take care to use the appropriate conversion routines when mixing fixed point with integer or floating point values. Writing <var>fixed_point_1 + fixed_point_2</var> is 0K, but <var>fixed_point + integer</var> is not.</p>
	<p>One of the advantage of fixed point math routines is that you don't require a floating point coprocessor to use them. This was great in the time period of i386 and i486 machines, but stopped being so useful with the coming of the Pentium class of processors. From Pentium onwards, CPUs have increased their strength in floating point operations, equaling or even surpassing integer math performance. Other advantage is the use of fixed point indexes to arrays, wich would be faster than floating point.</p>
	<p>Depending on the type of operations your program may need, using floating point types may be faster than fixed types if you are targeting a specific machine class. Allegro comes with a test program in the `allegro/tests' directory. Its `Misc' menu contains a basic profile test which can give you an idea of the speed difference between fixed and float types for a few basic operations on your machine. However, don't forget to profile your program in real life conditions, tight loop benchmarks are after all artificial.</p>
	<p>The fixed point square root, sin, cos, tan, inverse sin, and inverse cos functions are implemented using lookup tables, which are very fast but not particularly accurate. At the moment the inverse tan uses an iterative search on the tan table, so it is a lot slower than the others. Note that on machines with very good floating point processors using these functions could be slower in real life code due to cache misses: it may be faster to wait a few extra cicles for a floating point sine result rather than wait for the CPU to fetch the precalculated table from main memory. Always profile your code.</p>
	<p>Angles are represented in a binary format with 256 equal to a full circle, 64 being a right angle and so on. This has the advantage that a simple bitwise <var>AND</var> can be used to keep the angle within the range zero to a full circle, eliminating all those tiresome <var>IF angle >= 360</var> checks.</p>
	<p>Fixed point math is considered <i>"add-on"</i> material and is kept only for backwards compatibility. Whenever a future release of Allegro breaks backwards compatibility, fixed point math will likely be moved to a separate add-on package for the very few users who still find it convenient and useful, and Allegro functions using fixed point math will use other types.</p>
</descr>

<!-- alias type Visibility: default -->
<element name="AL_FIXED">
<short>This is a fixed point integer which can replace float with similar results and is faster than float on low end machines.</short>
<seealso>
	<link id="alfixed" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_itofix">
<short>Converts an integer to fixed point.</short>
<descr>
	<p>Converts an integer to fixed point. This is the same thing as <var>x SHL 16</var>. Remember that overflows (trying to convert an integer greater than 32767) and underflows (trying to convert an integer lesser than -32768) are not detected even in debug builds! The values simply "wrap around". Example:</p>
	<code>VAR
  Number: AL_FIXED;
	...
{ This conversion is OK. }
  Number := al_itofix (100);
{ This check will give wrong results. }
  Number := itofix(64000);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixtoi" />
	<link id="al_ftofix" />
	<link id="al_fixtof" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_itofix.Result">
<short>Returns the value of the integer converted to fixed point ignoring overflows.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_itofix.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixtoi">
<short>Converts a fixed point to integer with rounding.</short>
<descr>
	<p>Converts fixed point to integer, rounding as required to the nearest integer. Example:</p>
	<code>VAR
  Number: AL_FIXED;
	...
{ This will put 33 into `Number'. }
  Number := al_fixtoi (al_itofix (100) DIV 3);
{ But this will round up to 17. }
  Number := al_fixtoi (al_itofix(100) DIV 6);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_itofix" />
	<link id="al_ftofix" />
	<link id="al_fixtof" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixtoi.Result">
<short>Returns the value of the fixed point converted to integer.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixtoi.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_ftofix">
<short>Converts a floating point value to fixed point.</short>
<descr>
	<p>Converts a floating point value to fixed point. Unlike <link id="al_itofix" />, this function clamps values which could overflow the type conversion, setting <link id="alsystem.al_errno">al_errno</link> to non-zero in the process if this happens. Example:</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixtof" />
	<link id="al_itofix" />
	<link id="al_fixtoi" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_ftofix.Result">
<short>Returns the value of the floating point value converted to fixed point clamping overflows (and setting <link id="alsystem.al_errno">al_errno</link>).</short>
</element>

<!-- argument Visibility: default -->
<element name="al_ftofix.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixtof">
<short>Converts a fixed point to floating point.</short>
<descr>
	<p>Converts fixed point to floating point. Example:</p>
	<code>VAR
  Number: REAL;
	...
{ This will put 33.33333 into `Number'. }
  Number := al_fixtof (al_itofix (100) DIV 3);
{ This will put 16.66666 into `Number'. }
  Number := al_fixtof (al_itofix (100) DIV 6);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_ftofix" />
	<link id="al_itofix" />
	<link id="al_fixtoi" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixtof.Result">
<short>Returns the value of the fixed point value converted to floating point</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixtof.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixadd">
<short>Safe function to add fixed point numbers clamping overflow.</short>
<descr>
	<p>Although fixed point numbers can be added with the normal '+' integer operator, that doesn't provide any protection against overflow. If overflow is a problem, you should use this function instead. It is slower than using integer operators, but if an overflow occurs it will set <link id="alsystem.al_errno">al_errno</link> and clamp the result, rather than just letting it wrap. Example:</p>
	<code>VAR
  Number: AL_FIXED;
	...
{ This will put 5035 into `Number'. }
  Number := al_fixadd (al_itofix (5000), al_itofix (35));
{ Sets `al_errno' and puts -32768 into `Number'. }
  Number := al_fixadd (al_itofix (-31000), al_itofix (-3000));
  IF al_errno &lt;&gt; 0 THEN
    al_message ('Error adding fixed point numbers'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixsub" />
	<link id="al_fixmul" />
	<link id="al_fixdiv" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixadd.Result">
<short>Returns the clamped result of adding `x' to `y', setting <link id="alsystem.al_errno">al_errno</link> to ERANGE if there was an overflow.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixadd.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixadd.y">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixsub">
<short>Safe function to subtract fixed point numbers clamping underflow.</short>
<descr>
	<p>Although fixed point numbers can be subtracted with the normal '-' integer operator, that doesn't provide any protection against overflow. If overflow is a problem, you should use this function instead. It is slower than using integer operators, but if an overflow occurs it will set `errno' and clamp the result, rather than just letting it wrap. Example:</p>
	<code>VAR
  Number: AL_FIXED;
   ...
{ This will put 4965 into `Number'. }
  Number := al_fixsub (al_itofix (5000), al_itofix (35));
{ Sets `al_errno' and puts -32768 into `Number'. */
  Number := al_fixsub (al_itofix (-31000), al_itofix (3000));
  IF al_errno &lt;&gt; 0 THEN
    al_message ('Error substracting fixed point numbers'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixadd" />
	<link id="al_fixmul" />
	<link id="al_fixdiv" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixsub.Result">
<short>Returns the clamped result of subtracting `y' from `x', setting `al_errno' to ERANGE if there was an overflow.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixsub.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixsub.y">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixmul">
<short>Multiplies two fixed point values together.</short>
<descr>
	<p>A fixed point value can be multiplied or divided by an integer with the normal `*' and `/' operators. To multiply two fixed point values, though, you must use this function.</p>
	<p>If an overflow occurs, <var>al_errno</var> will be set and the maximum possible value will be returned, but <var>al_errno</var> is not cleared if the operation is successful. This means that if you are going to test for overflow you should set <var>al_errno:=0</var> before calling <var>al_fixmul</var>. Example:</p>
	<code>VAR
  Number: AL_FIXED;
   ...
{ This will put 30000 into `Number'. }
  Number := al_fixmul (al_itofix(10), al_itofix (3000));
{ But this overflows, and sets `al_errno'. }
  Number := al_fixmul (al_itofix (100), al_itofix (3000));
  IF al_errno &lt;&gt; 0 THEN
    al_message ('Error multiplying fixed point numbers'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixadd" />
	<link id="al_fixsub" />
	<link id="al_fixdiv" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixmul.Result">
<short>Returns the clamped result of multiplying `x' by `y', setting `al_errno' to ERANGE if there was an overflow.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixmul.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixmul.y">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixdiv">
<short>Fixed point division.</short>
<descr>
	<p>A fixed point value can be divided by an integer with the normal `/' and <var>DIV</var> operators. To divide two fixed point values, though, you must use this function. If a division by zero occurs, <var>al_errno</var> will be set and the maximum possible value will be returned, but <var>al_errno</var> is not cleared if the operation is successful. This means that if you are going to test for division by zero you should set <var>al_errno:=0</var> before calling <var>al_fixdiv</var>. Example:</p>
	<code>VAR
  Number: AL_FIXED;
   ...
{ This will put 0.06060 `Number'. }
  Number := al_fixdiv (al_itofix (2), al_itofix (33));
{ This will put 0 into `Number'. }
  Number := al_fixdiv (0, al_itofix (-30));
{ Sets `al_errno' and puts -32768 into `Number'. */
  Mumber := al_fixdiv (al_itofix (-100), al_itofix(0));
  IF al_errno &lt;&gt; 0 THEN
    al_message ('Error dividing fixed point numbers'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixadd" />
	<link id="al_fixsub" />
	<link id="al_fixmul" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixdiv.Result">
	<short>Returns the result of dividing `x' by `y'. If `y' is zero, returns the maximum possible fixed point value and sets <var>al_errno</var> to <var>ERANGE</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixdiv.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixdiv.y">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixsqrt">
<short>Fixed point square root.</short>
<descr>
	<p>This finds out the non negative square root of `x'. If `x' is negative, <link id="alsystem.al_errno">al_errno</link> is set to EDOM and the function returns zero.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alfixed" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixsqrt.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixsqrt.x">
<short></short>
</element>

<!-- constant Visibility: default -->
<element name="al_fixtorad">
<short>Constant to convert angles in fixed point format to radians.</short>
<descr>
	<p>This constant gives a ratio which can be used to convert a fixed point number in binary angle format to a fixed point number in radians. Example:</p>
	<code>VAR
  RadAngle, BinaryAngle: AL_FIXED;
		...
{ Set the binary angle to 90 degrees. }
  BinaryAngle := 64;
{ Now convert to radians (about 1.57). }
  RadAngle := al_fixmul (BinaryAngle, al_fixtorad);</code>
</descr>
<seealso>
	<link id="al_radtofix" />
	<link id="al_fixmul" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="al_radtofix">
<short>Constant to convert radians to fixed point angles.</short>
<descr>
	<p>This constant gives a ratio which can be used to convert a fixed point number in radians to a fixed point number in binary angle format. Example:</p>
	<code>VAR
  RadAngle, BinaryAngle: AL_FIXED;
		...
		BinaryAngle := al_fixmul (RadAngle, al_radtofix);</code>
</descr>
<seealso>
	<link id="al_fixtorad" />
	<link id="al_fixmul" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_fixsin">
<short>Fixed point sine of binary angles.</short>
<descr>
	<p>This function finds the sine of a value using a lookup table. The input value must be a fixed point binary angle. Example:</p>
	<code>VAR
  Angle: AL_FIXED;
  Result: INTEGER;
		...
{ Set the binary angle to 90 degrees. }
  Angle := al_itofix (64);
{ The sine of 90 degrees is one. }
  Result := al_fixtoi (al_fixsin (Angle));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixcos" />
	<link id="al_fixtan" />
	<link id="al_fixasin" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixsin.Result">
<short>Returns the sine of a fixed point binary format angle. The return value will be in radians.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixsin.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixcos">
<short>Fixed point cosine of binary angles.</short>
<descr>
	<p>This function finds the cosine of a value using a lookup table. The input value must be a fixed point binary angle. Example:</p>
	<code>VAR
  Angle: AL_FIXED;
  Result: INTEGER;
		...
{ Set the binary angle to 45 degrees. }
  Angle := al_itofix (32);
{ The cosine of 45 degrees is about 0.7071.  }
  Result := al_fixtoi (al_fixcos (Angle));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixsin" />
	<link id="al_fixtan" />
	<link id="al_fixacos" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixcos.Result">
<short>Returns the cosine of a fixed point binary format angle. The return value will be in radians.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixcos.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixtan">
<short>Fixed point tangent of binary angles.</short>
<descr>
	<p>This function finds the tangent of a value using a lookup table. The input value must be a fixed point binary angle. Example:</p>
	<code>VAR
  Angle, Res_a, Res_b: AL_FIXED;
  Dif: DOUBLE;
		...
  Angle := al_itofix (37);
{ Prove that tan (angle) = sin (angle) / cos (angle). }
  Res_a := al_fixdiv (al_fixsin (Angle), al_fixcos (Angle));
  Res_b := al_fixtan (Angle);
  Dif := al_fixtof (al_fixsub (Res_a, Res_b));
  al_message ('Precision error: ' + FloatToStr (dif));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixsin" />
	<link id="al_fixcos" />
	<link id="al_fixatan" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixtan.Result">
<short>Returns the tangent of a fixed point binary format angle. The return value will be in radians.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixtan.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixasin">
<short>Fixed point inverse sine lookup table.</short>
<descr>
	<p>This function finds the inverse sine of a value using a lookup table. The input value must be a fixed point value. The inverse sine is defined only in the domain from <var>-1</var> to <var>1</var>. Outside of this input range, the function will set `errno' to EDOM and return zero. Example:</p>
	<code>VAR
  Angle, Var: AL_FIXED;
		...
{ Sets `Val' to a right binary angle (`64'). }
  Val := al_fixasin (al_itofix (1));
{ Sets `Agle' to 0.2405. }
  Angle := al_fixtof (al_fixmul (al_fixasin (al_ftofix (0.238)), al_fixtorad));
{ This will trigger the errno. }
  Val := al_fixasin (al_ftofix (-1.09));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixsin" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixasin.Result">
	<short>Returns the inverse sine of a fixed point value, measured as fixed point binary format angle, or zero if the input was out of the range. All return values of this function will be in the range <var>-64</var> to <var>64</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixasin.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixacos">
<short>Fixed point inverse cosine lookup table.</short>
<descr>
	<p>This function finds the inverse cosine of a value using a lookup table. The input value must be a fixed point radian. The inverse cosine is defined only in the domain from <var>-1</var> to <var>1</var>. Outside of this input range, the function will set `errno' to EDOM and return zero. Example:</p>
	<code>VAR
  Val: AL_FIXED;
		...
{ Sets `Val' to binary angle 128. }
  Val := al_fixacos (al_itofix (-1));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixcos" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixacos.Result">
	<short>Returns the inverse cosine of a fixed point value, measured as fixed point binary format angle, or zero if the input was out of range. All return values of this function will be in the range <var>0</var> to <var>128</var>.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixacos.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixatan">
<short>Fixed point inverse tangent lookup table.</short>
<descr>
	<p>This function finds the inverse tangent of a value using a lookup table. The input value must be a fixed point radian. The inverse tangent is the value whose tangent is <var>x</var>. Example:</p>
	<code>VAR
  Val: AL_FIXED;
		...
{ Sets `Val' to binary angle 13. }
  Val := al_fixatan (al_ftofix (0.326));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixtan" />
	<link id="al_fixatan2" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixatan.Result">
<short>Returns the inverse tangent of a fixed point value, measured as a fixed point binary format angle.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixatan.x">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_fixatan2">
<short>Fixed point version of the libc atan2() routine.</short>
<descr>
	<p>This is a fixed point version of the libc <var>atan2 ()</var> routine. It computes the arc tangent of <var>y / x</var>, but the signs of both arguments are used to determine the quadrant of the result, and <var>x</var> is permitted to be zero. This function is useful to convert Cartesian coordinates to polar coordinates. Example:</p>
	<code>VAR
  Val: AL_FIXED;
		...
{ Sets `Val' to binary angle 64. }
  Val := al_fixatan2 (al_itofix (1), 0);
{ Sets `Val' to binary angle -109. }
  Val := al_fixatan2 (al_itofix (-1), al_itofix (-2));
{ Fails the result. }
  Val := al_fixatan2 (0, 0);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fixtan" />
	<link id="al_fixatan" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_fixatan2.Result">
	<short>Returns the arc tangent of <var>y / x</var> in fixed point binary format angle, from <var>-128</var> to <var>128</var>. If both <var>x</var> and <var>y</var> are zero, returns zero and sets `errno' to EDOM.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixatan2.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fixatan2.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="__al_inittrig__">
<short>INTERNAL USE ONLY</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

</module> <!-- alfixed -->


<!--
  ====================================================================
    alflic
  ====================================================================
-->

<module name="alflic">
<short>FLIC routines.</short>
<descr>
	<p>There are two high level functions for playing FLI/FLC animations: <link id="al_play_fli" />, which reads the data directly from disk, and <link id="al_play_memory_fli" />, which uses data that has already been loaded into RAM. Apart from the different sources of the data, these two functions behave identically. They draw the animation onto the specified bitmap, which should normally be the screen. Frames will be aligned with the top left corner of the bitmap: if you want to position them somewhere else you will need to create a sub-bitmap for the FLI player to draw onto.</p>
	<p>If the callback function is not <var>NIL</var> it will be called once for each frame, allowing you to perform background tasks of your own. This callback should normally return zero: if it returns non-zero the player will terminate (this is the only way to stop an animation that is playing in looped mode).</p>
	<p>The FLI player returns <link id="AL_FLI_OK" /> if it reached the end of the file, <link id="AL_FLI_ERROR" /> if something went wrong, and the value returned by the callback function if that was what stopped it. If you need to distinguish between different return values, your callback should return positive integers, since <var>FLI_OK</var> is zero and <var>FLI_ERROR</var> is negative.</p>
	<p>Note that the FLI player will only work when the <link id="altimer">timer module</link> is installed, and that it will alter the palette according to whatever palette data is present in the animation file.</p>
	<p>Occasionally you may need more detailed control over how an FLI is played, for example if you want to superimpose a text scroller on top of the animation, or to play it back at a different speed. You could do both of these with the lower level functions described below.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_FLI_OK">
<short>Means that the FLIC animation is correct.</short>
<descr>
</descr>
<seealso>
	<link id="al_play_fli" /><link id="al_play_memory_fli" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_FLI_EOF">
<short>Means that it reached the end of the file</short>
<descr>
	<link id="al_next_fli_frame" />
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_FLI_ERROR">
<short>Means that there's an error in the FLIC animation.</short>
<descr>
</descr>
<seealso>
	<link id="al_play_fli" /><link id="al_play_memory_fli" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_FLI_NOT_OPEN">
<short>Means that there are not a flic opened.</short>
<descr>
</descr>
<seealso>
	<link id="al_next_fli_frame" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_play_fli">
<short>Plays a FLI or FLC animation from disk.</short>
<descr>
	<p>Plays an Autodesk Animator FLI or FLC animation file on the specified <link id="albitmap.AL_BITMAP">AL_BITMAP</link>, reading the data from disk as it is required. If <var>loop</var> is not zero, the player will cycle when it reaches the end of the file, otherwise it will play through the animation once and then return. Read the beginning of chapter <link id="alflic">"FLIC routines"</link> for a description of the callback parameter. Example:</p>
	<code>(* Let users skip looped animations. *)
FUNCTION CheckEscapeKey: INTEGER; CDECL;
BEGIN
  IF al_key[AL_KEY_ESC] &lt;&gt; #0 THEN
    CheckEscapeKey := 1
  ELSE
    CheckEscapeKey := 0;
END;
  ...

Value := al_play_fli ('animlogo.fli', al_screen, 1, @CheckEscapeKey);
IF Value = AL_FLI_ERROR THEN
  al_message ('Error playing intro!');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_memory_fli" /><link id="al_fli_frame" /><link id="altimer.al_install_timer">al_install_timer</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_play_fli.Result">
<short>The FLI player returns <link id="AL_FLI_OK" /> if it reached the end of the file, <link id="AL_FLI_ERROR" /> if something went wrong, and the value returned by the callback function if that was what stopped it.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_fli.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_fli.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_fli.loop">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_fli.callback">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_play_memory_fli">
<short>lays a FLI or FLC animation from memory.</short>
<descr>
	<p>Plays an Autodesk Animator FLI or FLC animation on the specified BITMAP, reading the data from a copy of the file which is held in memory. You can obtain the `fli_data' pointer by mallocing a block of memory and reading an FLI file into it, or by importing an FLI into a grabber <link id="aldtfile">datafile</link>. If <var>loop</var> is not zero, the player will cycle when it reaches the end of the file, otherwise it will play through the animation once and then return. Read the beginning of chapter <link id="alflic">"FLIC routines"</link> for a description of the callback parameter.</p>
	<p>Playing animations from memory is obviously faster than cueing them directly from disk, and is particularly useful with short, looped FLI's. Animations can easily get very large, though, so in most cases you will probably be better just using <link id="al_play_fli" />. You can think of this function as a wrapper on top of <link id="al_open_memory_fli" />, <link id="al_next_fli_frame" /> and <link id="al_close_fli" />. Example:</p>
	<code>Value := al_play_memory_fli (anim_data, screen, 0, NIL);
IF Value = AL_FLI_ERROR THEN
  al_message ('Corrupted animation data?');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_fli" /><link id="al_fli_frame" /><link id="altimer.al_install_timer">al_install_timer</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_play_memory_fli.Result">
	<short>The FLI player returns <link id="AL_FLI_OK" /> if it reached the end of the file, <link id="AL_FLI_ERROR" /> if something went wrong, and the value returned by the callback function if that was what stopped it.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_memory_fli.fli_data">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_memory_fli.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_memory_fli.loop">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_memory_fli.callback">
<short></short>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_bitmap">
<short>Contains the current frame of the animation.</short>
<descr>
	<p>Contains the current frame of the FLI/FLC animation. If there is no open animation, its value will be <var>NIL</var>.</p>
</descr>
<seealso>
	<link id="al_next_fli_frame" /><link id="al_fli_bmp_dirty_from" /><link id="al_fli_palette" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_palette">
<short>Contains the current FLI palette.</short>
<descr>
</descr>
<seealso>
	<link id="al_next_fli_frame" /><link id="al_fli_pal_dirty_from" /><link id="al_fli_bitmap" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_bmp_dirty_from">
<short>Indicate which parts of the image have changed.</short>
<descr>
	<p>This variable is set by <link id="al_next_fli_frame" /> to indicate which part of the <link id="al_fli_bitmap" /> has changed since the last call to <link id="al_reset_fli_variables" />. If <var>al_fli_bmp_dirty_from</var> is greater than <link id="al_fli_bmp_dirty_to" />, the bitmap has not changed, otherwise lines <var>al_fli_bmp_dirty_from</var> to <var>al_fli_bmp_dirty_to</var> (inclusive) have altered. You can use these when copying the <var>al_fli_bitmap</var> onto the screen, to avoid moving data unnecessarily. Example:</p>
	<code>IF al_fli_bmp_dirty_from &lt;= al_fli_bmp_dirty_to THEN
  al_blit (al_fli_bitmap, al_screen, 0, al_fli_bmp_dirty_from,
	   0, al_fli_bmp_dirty_from, al_fli_bitmap^.w,
	   al_fli_bmp_dirty_to - al_fli_bmp_dirty_from + 1);</code>
</descr>
<seealso>
	<link id="al_fli_bmp_dirty_to" /><link id="al_fli_bitmap" /><link id="al_reset_fli_variables" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_bmp_dirty_to">
<short>Indicate which parts of the image have changed.</short>
<descr>
	<p>This variable is set by <link id="al_next_fli_frame" /> to indicate which part of the <link id="al_fli_bitmap" /> has changed since the last call to <link id="al_reset_fli_variables" />. If <link id="al_fli_bmp_dirty_from" /> is greater than <var>al_fli_bmp_dirty_to</var>, the bitmap has not changed, otherwise lines <var>al_fli_bmp_dirty_from</var> to <var>al_fli_bmp_dirty_to</var> (inclusive) have altered. You can use these when copying the <var>al_fli_bitmap</var> onto the screen, to avoid moving data unnecessarily. Example:</p>
	<code>IF al_fli_bmp_dirty_from &lt;= al_fli_bmp_dirty_to THEN
  al_blit (al_fli_bitmap, al_screen, 0, al_fli_bmp_dirty_from,
	   0, al_fli_bmp_dirty_from, al_fli_bitmap^.w,
	   al_fli_bmp_dirty_to - al_fli_bmp_dirty_from + 1);</code>
</descr>
<seealso>
	<link id="al_fli_bmp_dirty_from" /><link id="al_fli_bitmap" /><link id="al_reset_fli_variables" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_pal_dirty_from">
<short>Indicate which parts of the palette have changed.</short>
<descr>
	<p>This variable is set by <link id="al_next_fli_frame" /> to indicate which part of the <link id="al_fli_palette" /> has changed since the last call to <link id="al_reset_fli_variables" />. If <var>al_fli_pal_dirty_from</var> is greater than <link id="al_fli_pal_dirty_to" />, the palette has not changed, otherwise colors <var>al_fli_pal_dirty_from</var> to <var>al_fli_pal_dirty_to</var> (inclusive) have altered. You can use these when updating the hardware palette, to avoid unnecessary calls to <link id="alpalete.al_set_palette">al_set_palette</link>. Example:</p>
	<code>IF al_fli_pal_dirty_from &lt;= al_fli_pal_dirty_to THEN
  al_set_palette_range (al_fli_palette, al_fli_pal_dirty_from,
			al_fli_pal_dirty_to, 1);</code>
	
</descr>
<seealso>
	<link id="al_fli_pal_dirty_to" /><link id="al_fli_palette" /><link id="al_reset_fli_variables" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_pal_dirty_to">
<short>Indicate which parts of the palette have changed.</short>
<descr>
	<p>This variable is set by <link id="al_next_fli_frame" /> to indicate which part of the <link id="al_fli_palette" /> has changed since the last call to <link id="al_reset_fli_variables" />. If <link id="al_fli_pal_dirty_from" /> is greater than <var>al_fli_pal_dirty_to</var>, the palette has not changed, otherwise colors <var>al_fli_pal_dirty_from</var> to <var>al_fli_pal_dirty_to</var> (inclusive) have altered. You can use these when updating the hardware palette, to avoid unnecessary calls to <link id="alpalete.al_set_palette">al_set_palette</link>. Example:</p>
	<code>IF al_fli_pal_dirty_from &lt;= al_fli_pal_dirty_to THEN
  al_set_palette_range (al_fli_palette, al_fli_pal_dirty_from,
			al_fli_pal_dirty_to, 1);</code>
	
</descr>
<seealso>
	<link id="al_fli_pal_dirty_from" /><link id="al_fli_palette" /><link id="al_reset_fli_variables" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_timer">
<short>Global variable for timing FLI playback.</short>
<descr>
	<p>Global variable for timing FLI playback. When you open an FLI file, a timer interrupt is installed which increments this variable every time a new frame should be displayed. Calling <link id="al_next_fli_frame" /> decrements it, so you can test it and know that it is time to display a new frame if it is greater than zero. Example:</p>
	<code>WHILE al_next_fli_frame (0) = AL_FLI_OK DO
BEGIN
{ Do stuff, like play audio stream. 
  or check keys to skip animation. }
{ Rest some time until next frame... }
  WHILE al_fli_timer &lt;= 0 DO
    al_rest (0);
END;</code>
</descr>
<seealso>
	<link id="altimer.al_install_timer">al_install_timer</link><link id="al_next_fli_frame" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_fli_frame">
<short>Stores the current frame number of the animation.</short>
<descr>
	<p>Global variable containing the current frame number in the FLI file. This is useful for synchronising other events with the animation, for instance you could check it in a <link id="al_play_fli" /> callback function and use it to trigger a sample at a particular point. Example:</p>
	<code>WHILE al_next_fli_frame (0) = AL_FLI_OK DO
BEGIN
  IF al_fli_frame = 345 THEN
    al_play_sample (trumpet_sound, 255, 128, 1000, 0);
{ Rest some time until next frame... }
END;</code>
</descr>
<seealso>
	<link id="al_play_fli" /><link id="al_play_memory_fli" /><link id="al_next_fli_frame" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_open_fli">
<short>Makes a FLI file open and ready for playing.</short>
<descr>
	<p>Open FLI files ready for playing, reading the data from disk. Information about the current FLI is held in the global variables <link id="al_fli_bitmap" /> and <link id="al_fli_palette" />, which you can use if this function succeeds. However, you can only have one animation open at a time. Example:</p>
	<code>IF al_open_fli ('intro.fli') = FLI_ERROR THEN
  AbortOnError ('Error playing intro');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_close_fli" /><link id="al_next_fli_frame" /><link id="al_fli_palette" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_open_fli.Result">
<short>Returns <link id="AL_FLI_OK" /> on success, <link id="AL_FLI_ERROR" /> if something went wrong, like trying to open another FLI file without closing the previous one.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_open_fli.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_open_memory_fli">
<short>Makes a FLI animation open and ready for playing.</short>
<descr>
	<p>Open FLI animation ready for playing, reading the data from memory. Information about the current FLI is held in the global variables <link id="al_fli_bitmap" /> and <link id="al_fli_palette" />, which you can use if this function succeeds. However, you can only have one animation open at a time. Example:</p>
	<code>IF al_open_memory_fli (fli_intro) = FLI_ERROR THEN
  AbortOnError ('Error playing intro');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_close_fli" /><link id="al_next_fli_frame" /><link id="al_fli_palette" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_open_memory_fli.Result">
<short>Returns <link id="AL_FLI_OK" /> on success, <link id="AL_FLI_ERROR" /> if something went wrong, like trying to open another FLI animation without closing the previous one.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_open_memory_fli.fli_data">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_close_fli">
<short>Closes a FLI file previously opened.</short>
<descr>
	<p>Closes an FLI file when you have finished reading from it. Remember to do this to avoid having memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_open_fli" /><link id="al_open_memory_fli" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_next_fli_frame">
<short>Reads the next frame of the current animation file.</short>
<descr>
	<p>Reads the next frame of the current animation file. If <var>loop</var> is not zero, the player will cycle when it reaches the end of the file, otherwise it will return <link id="AL_FLI_EOF" />. The frame is read into the global variables <link id="al_fli_bitmap" /> and <link id="al_fli_palette" />. Example:</p>
	<code>WHILE al_next_fli_frame (0) = AL_FLI_OK DO
BEGIN
{ Do stuff, like play audio stream. 
  or check keys to skip animation. }
{ Rest some time until next frame... }
END;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_open_fli" /><link id="al_open_memory_fli" /><link id="al_fli_bitmap" /><link id="al_fli_palette" /><link id="al_fli_timer" /><link id="al_fli_frame" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_next_fli_frame.Result">
	<short>Returns <link id="AL_FLI_OK" /> on success, <link id="AL_FLI_ERROR" /> or <link id="AL_FLI_NOT_OPEN" /> on error, and <link id="AL_FLI_EOF" /> on reaching the end of the file.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_next_fli_frame.loop">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_reset_fli_variables">
<short>Resets the bitmap and palette dirty global variables.</short>
<descr>
	<p>Once you have done whatever you are going to do with the <link id="al_fli_bitmap" /> and <link id="al_fli_palette" />, call this function to reset the <var>al_fli_bmp_dirty_*</var> and <var>al_fli_pal_dirty_*</var> variables.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fli_bmp_dirty_from" /><link id="al_fli_pal_dirty_from" />
</seealso>
</element>

</module> <!-- alflic -->


<!--
  ====================================================================
    alfont
  ====================================================================
-->

<module name="alfont">
<short>Text fonts</short>
<descr>
	<p>Allegro provides routines for loading fonts directly from GRX format .fnt files, 8x8 or 8x16 BIOS format .fnt files, from bitmap images, from datafiles or you can import a multiple-range Unicode font by writing a .txt script that specifies a number of different source files for each range of characters.</p>
	<p>By default, Allegro can only use bitmapped (non-scalable) fonts. If you want to use TrueType fonts, you will need to use an add-on library which allows you to load them on the fly (like AllegTTF or Glyph Keeper, listed among others at http://www.allegro.cc/) and render them directly, or generate a bitmapped version of a TrueType font with tools like TTF2PCX (http://www.talula.demon.co.uk/ttf2pcx/index.html).</p>
</descr>

<!-- alias type Visibility: default -->
<element name="AL_FONTptr">
<short>Pointer to a font structure.</short>
<descr>
	<p>A structure holding an Allegro font, usually created beforehand with the grabber tool or <link id="altext.al_font">Allegro's default font</link>. Read <link id="alfont">Fonts overview</link> for a description on how to load/destroy fonts, and <link id="altext">Text output overview</link> for a description on how to show text.</p>
</descr>
<seealso>
	<link id="altext.al_font">al_font</link><link id="al_load_font" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_load_font">
<short>Loads a font from a file.</short>
<descr>
	<p>Loads a font from a file. At present, this supports loading fonts from a GRX format .fnt file, a 8x8 or 8x16 BIOS format .fnt file, a datafile or any bitmap format that can be loaded by <link id="albitmap.al_load_bitmap">al_load_bitmap</link>.</p>
	<p>If the font contains palette information, then the palette is returned in the second parameter, which should be an array of 256 RGB structures (an <link id="alpalete.AL_PALETTE">AL_PALETTE</link>). The <var>pal</var> argument may be <var>NIL</var>. In this case, the palette data, if present, is simply not returned.</p>
	<p>The third parameter can be used to pass specific information to a custom loader routine. Normally, you can just leave this as <var>NIL</var>. Note that another way of loading fonts is embedding them into a datafile and using the datafile related functions.</p>
	<p>If the file is a bitmap, the size of each character is determined by the layout of the image, which should be a rectangular grid containing all the ASCII characters from space (32) up to the tilde (126). The way the characters are separated depends on the colordepth of the image file:</p>
	<ul>
		<li>paletted (8 bit) image file Use color 0 for the transparent portions of the characters and fill the spaces between each letter with color 255.</li>
		<li>High (15/16 bit) and true (24/32 bit) color image file Use bright pink (maximum red and blue, zero green) for the transparent portions of the characters and fill the spaces between each letter with bright yellow (maximum red and green, zero blue).</li>
	</ul>
	<p>Note that in each horizontal row the bounding boxes around the characters should align and have the same height.</p>
	<p>Probably the easiest way to get to grips with how this works is to use the <var>charfont</var> program at the tools directory.  Have a look at the resulting picture in your paint program: that is the format a font should be in.</p>
	<p>Take care with high and true color fonts: Allegro will convert these to the current colordepth when you load the font. If you try to use a font on a bitmap with a different color depth Allegro will do color conversions on the fly, which will be rather slow. For optimal performance you should set the colordepth to the colordepth you want to use before loading any fonts.</p>
	<p>Example:</p>
	<code>VAR
  MyFont: AL_FONTptr;
  Palette: AL_PALETTE;
BEGIN
          ...
  MyFont := al_load_font ('my_font.pcx', @Palette, NIL);
  IF MyFont = NIL THEN
    AbortOnError ('Couldn''t load font!');
          ...
  al_textout_centre_ex (al_screen, MyFont, 'This is my own pretty font!',
                        AL_SCREEN_W DIV 2, AL_SCREEN_H DIV 2, White, Black);
          ...
  al_destroy_font(bmp);
END;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="albitmap.al_load_bitmap">al_load_bitmap</link><link id="al_destroy_font" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_font.Result">
<short>Returns a pointer to the font or <var>NIL</var> on error. Remember that you are responsible for destroying the font when you are finished with it to avoid memory leaks.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_font.filename">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_font.palette">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_font.p">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_grab_font_from_bitmap">
<short>Grabs a font from a bitmap</short>
<descr>
	<p>This function is the work-horse of <link id="al_load_font" /> when targeting a bitmap file, and can be used to grab a font from a bitmap in memory. You can use this if you want to generate or modify a font at runtime. The bitmap should follow the layout described for loading bitmap font.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_font" /><link id="albitmap" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_grab_font_from_bitmap.Result">
<short>Returns a pointer to the font or <var>NIL</var> on error. Remember that you are responsible for destroying the font when you are finished with it to avoid memory leaks.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_grab_font_from_bitmap.bmp">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_color_font">
<short>Returns <var>NOT 0</var> if a font is a color font.</short>
<descr>
	<p>This function checks if the given font is a color font, as opposed to a monochrome font.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_is_mono_font" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_is_color_font.Result">
<short>Returns  <var>NOT 0</var> (non-zero) if the font is a color font,  <var>0</var> (zero) if it is not.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_color_font.f">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_mono_font">
<short>Returns <var>NOT 0</var> if a font is a monochrome font.</short>
<descr>
	<p>This function checks if the given font is a mono font, as opposed to a color font.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_is_color_font" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_is_mono_font.Result">
<short>>Returns  <var>NOT 0</var> (non-zero) if the font is a monochrome font,  <var>0</var> (zero) if it is not.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_mono_font.f">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_compatible_font">
<short>Check if two fonts are of the same type.</short>
<descr>
	<p>This function compares the two fonts, which you can use to find out if Allegro is capable of merging them.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_is_color_font" /><link id="al_is_mono_font" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_is_compatible_font.Result">
<short>Returns non-zero if the two fonts are of the same general type (both are color fonts or both are monochrome fonts, for instance).</short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_compatible_font.f1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_compatible_font.f2">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_destroy_font">
<short>Frees the memory being used by a font structure.</short>
<descr>
	<p>Frees the memory being used by a font structure. Don't use this on the default global Allegro font or any text routines using it could crash. You should use this only on fonts you have loaded manually after you are done with them, to prevent memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_font" /><link id="al_grab_font_from_bitmap" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_destroy_font.f">
<short></short>
</element>

</module> <!-- alfont -->


<!--
  ====================================================================
    algraph
  ====================================================================
-->

<module name="algraph">
<short>Graphics mode configuration</short>
<descr>
	<p>Graphics modes are the common denominator for most Allegro programs. While it is possible to write platform specific programs using Allegro which don't set a graphic mode through the routines provided in this chapter, these are not very common.</p>
	<p>The first thing to note is that due to the wide range of supported platforms, a graphic mode is the only way to safely communicate with the user. When Allegro was a DOS only library (versions 3.x and previous), it was frequent for programmers to use functions from the C standard library to communicate with the user, like calling printf() before setting a graphic mode or maybe scanf() to read the user's input. However, what would happen for such a game running under Windows where there is no default console output or it may be hidden from the user? Even if the game compiled successfully, it would be unplayable, especially if there was vital information for the user in those text only messages.</p>
	<p>Allegro provides the <link id="alsystem.al_message">al_message</link> procedure to deal with this problem, but this is not a very user friendly method of communicating with the user and its main purpose is displaying small error like messages when no graphic mode is available. Therefore, the first thing your Allegro program should do is set a graphic mode, and from there on, use Allegro's text output routines to display messages to the user, just like `allegro.pas/examples/exhello.pas' does.</p>
	<p>Setting a graphic mode involves deciding how to allocate the memory of the video card for your program. On some platforms this means creating a virtual screen bigger than the physical resolution to do hardware scrolling or page flipping. Virtual screens can cause a lot of confusion, but they are really quite simple. <b>Warning:</b> patronising explanation coming up, so you may wish to skip the rest of this paragraph. Think of video memory as a rectangular piece of paper which is being viewed through a small hole (your monitor) in a bit of cardboard. Since the paper is bigger than the hole you can only see part of it at any one time, but by sliding the cardboard around you can alter which portion of the image is visible. You could just leave the hole in one position and ignore the parts of video memory that aren't visible, but you can get all sorts of useful effects by sliding the screen window around, or by drawing images in a hidden part of video memory and then flipping across to display them.</p>
	<p>For example, you could select a 640x480 mode in which the monitor acts as a window onto a 1024x1024 virtual screen, and then move the visible screen around in this larger area (hardware scrolling). Initially, with the visible screen positioned at the top left corner of video memory, this setup would look like:</p>
	<pre>(0,0)------------(640,0)----(1024,0)
  |                  |           |
  |  visible screen  |           |
  |                  |           |
(0,480)----------(640,480)       |
  |                              |
  |   the rest of video memory   |
  |                              |
(0,1024)--------------------(1024,1024)</pre>
	<p>With a virtual screen bigger than the visible screen you can perform smooth CPU inexpensive scrolling: you draw your graphics once, and then only tell the video card to show a different portion of the screen. However, virtual screens are not supported on all platforms, and on some they might be emulated through software, losing any performance. On top of that, many video cards only allow horizontal scrolling in steps of 32 bytes. This is not a problem if your game runs in 24 or 32 bit, but it tends to mean jerky scrolling for other color depths.</p>
	<p>The other reason you could use virtual screens for is page flipping. This means showing one portion of the virtual screen while your program draws to the hidden one. When you finish, you show the part you have been drawing to and repeat the process with the area now hidden. The result is a perfectly smooth screen update without flickering or other graphical artifacts.</p>
	<!--Scrolling manually to one part of the video memory is one non portable way to accomplish this. The portable way is to use functions like create_system_bitmap(), create_video_bitmap(), show_video_bitmap(), etc. These functions divide the memory of the video card in areas and switch between them, a feature supported on all platforms and video cards (given that they have enough memory for the screen resolutions you asked for).
	-->
	<p>The last thing you need to know about setting a graphic mode are drivers. Each platform has a number of graphic drivers wich support a different range of hardware or behave in different ways. To avoid cluttering your own code with <i>{$ifdefs}</i> and dealing with drivers added after you release your program, Allegro provides several so called magic drivers. These magic drivers don't really exists, they wrap around a specific kind of functionality.</p>
	<p>The magic drivers you can use are <link id="AL_GFX_AUTODETECT" />, <link id="AL_GFX_AUTODETECT_FULLSCREEN" />, <link id="AL_GFX_AUTODETECT_WINDOWED" />, <link id="AL_GFX_SAFE" /> and <link id="AL_GFX_TEXT" />.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_GFX_TEXT">
<short>Closes any previously opened graphics mode.</short>
<descr>
	<p>Closes any previously opened graphics mode, making you unable to use the global variable <link id="al_screen" />, and in those environments that have text modes, sets one previously used or the closest match to that (usually 80x25). With this driver the size parameters of <link id="al_set_gfx_mode" /> don't mean anything, so you can leave them all to zero or any other number you prefer.</p>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_GFX_AUTODETECT" />
	<link id="AL_GFX_AUTODETECT_FULLSCREEN" />
	<link id="AL_GFX_AUTODETECT_WINDOWED" />
	<link id="AL_GFX_SAFE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_AUTODETECT">
<short>Tryes to detect a valid graphics mode.</short>
<descr>
	<p>Allegro will try to set the specified resolution with the current color depth in fullscreen mode. Failing that, it will try to repeat the same operation in windowed mode. If the call to <link id="al_set_gfx_mode" /> succeeds, you are guaranteed to have set the specified resolution in the current color depth, but you don't know if the program is running fullscreen or windowed.</p>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_GFX_TEXT" />
	<link id="AL_GFX_AUTODETECT_FULLSCREEN" />
	<link id="AL_GFX_AUTODETECT_WINDOWED" />
	<link id="AL_GFX_SAFE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_AUTODETECT_FULLSCREEN">
<short>Tryes to set a fullscreen graphics mode.</short>
<descr>
	<p>Allegro will try to set the specified resolution with the current color depth in fullscreen mode. If that is not possible, <link id="al_set_gfx_mode" /> will fail.</p>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_GFX_TEXT" />
	<link id="AL_GFX_AUTODETECT" />
	<link id="AL_GFX_AUTODETECT_WINDOWED" />
	<link id="AL_GFX_SAFE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_AUTODETECT_WINDOWED">
<short>Tryes to set a windowed graphics mode.</short>
<descr>
	<p>Allegro will try to set the specified resolution with the current color depth in a windowed mode. If that is not possible, <link id="al_set_gfx_mode" /> will fail. When it comes to windowed modes, the <i>specified resolution</i> actually means the graphic area your program can draw on, without including window decorations (if any). Note that in windowed modes running with a color depth other than the desktop may result in non optimal performance due to internal color conversions in the graphic driver. Use <link id="alsystem.al_desktop_color_depth">al_desktop_color_depth</link> to your advantage in these situations.</p>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_GFX_TEXT" />
	<link id="AL_GFX_AUTODETECT" />
	<link id="AL_GFX_AUTODETECT_FULLSCREEN" />
	<link id="AL_GFX_SAFE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_SAFE">
<short>Guarantees that a graphic mode will always be set correctly. </short>
<descr>
	<p>Using this driver Allegro guarantees that a graphic mode will always be set correctly. It will try to select the resolution that you request, and if that fails, it will fall back upon whatever mode is known to be reliable on the current platform (this is 320x200 VGA mode under DOS, a 640x480 resolution under Windows, the actual framebuffer's resolution under Linux if it's supported, etc). If it absolutely cannot set any graphics mode at all, it will return negative as usual, meaning that there's no possible video output on the machine, and that you should abort your program immediately, possibly after notifying this to the user with <link id="alsystem.al_message">al_message</link>. This fake driver is useful for situations where you just want to get into some kind of workable display mode, and can't be bothered with trying multiple different resolutions and doing all the error checking yourself. Note however, that after a successful call to <link id="al_set_gfx_mode" /> with this driver, you cannot make any assumptions about the width, height or color depth of the screen: your code will have to deal with this little detail.</p>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_GFX_TEXT" />
	<link id="AL_GFX_AUTODETECT" />
	<link id="AL_GFX_AUTODETECT_FULLSCREEN" />
	<link id="AL_GFX_AUTODETECT_WINDOWED" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_CAN_SCROLL">
<short>Indicates that the scroll_screen() function may be used with this driver.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_CAN_TRIPLE_BUFFER">
<short>Indicates that the request_scroll() and poll_scroll() functions may be used with this driver. If this flag is not set, it is possible that the enable_triple_buffer() function may be able to activate it.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_CURSOR">
<short>Indicates that a hardware mouse cursor is in use. </short>
<descr>
	<p>When this flag is set, it is safe to draw onto the screen without hiding the mouse pointer first. Note that not every cursor graphic can be implemented in hardware: in particular VBE/AF only supports 2-color images up to 32x32 in size, where the second color is an exact inverse of the first. This means that Allegro may need to switch between hardware and software cursors at any point during the execution of your program, so you should not assume that this flag will remain constant for long periods of time. It only tells you whether a hardware cursor is in use at the current time, and may change whenever you hide/redisplay the pointer.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_HLINE">
<short>Indicates that the normal opaque version of the <link id="aldraw.al_hline">al_hline</link> function is implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that the normal opaque version of the <link id="aldraw.al_hline">al_hline</link> function is implemented using a hardware accelerator. This will improve the performance not only of hline() itself, but also of many other functions that use it as a workhorse, for example <link id="aldraw.al_circlefill">al_circlefill</link><!--, triangle(),--> and <link id="aldraw.al_floodfill">al_floodfill</link>.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_HLINE_XOR" />
	<link id="AL_GFX_HW_HLINE_SOLID_PATTERN" />
	<link id="AL_GFX_HW_HLINE_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_HLINE_XOR">
<short>Indicates that the normal opaque version of the <link id="aldraw.al_hline">al_hline</link> function is implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that the XOR version of the <link id="aldraw.al_hline">al_hline</link> function, and any other functions that use it as a workhorse, are implemented using a hardware accelerator.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_HLINE" />
	<link id="AL_GFX_HW_HLINE_SOLID_PATTERN" />
	<link id="AL_GFX_HW_HLINE_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_HLINE_SOLID_PATTERN">
<short>Indicates that the solid and masked pattern modes of the <link id="aldraw.al_hline">al_hline</link> function is implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that the solid and masked pattern modes of the <link id="aldraw.al_hline">al_hline</link>  function, and any other functions that use it as a workhorse, are implemented using a hardware accelerator.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_HLINE" />
	<link id="AL_GFX_HW_HLINE_XOR" />
	<link id="AL_GFX_HW_HLINE_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_HLINE_COPY_PATTERN">
<short>Indicates that the copy pattern mode of the <link id="aldraw.al_hline">al_hline</link> function is implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that the copy pattern mode of the <link id="aldraw.al_hline">al_hline</link> function, and any other functions that use it as a workhorse, are implemented using a hardware accelerator.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_HLINE" />
	<link id="AL_GFX_HW_HLINE_XOR" />
	<link id="AL_GFX_HW_HLINE_SOLID_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_FILL">
<short>Indicates that some opaque filling functions are implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that the opaque version of the <link id="aldraw.al_rectfill">al_rectfill</link>, the <link id="aldraw.al_clear_bitmap">al_clear_bitmap</link> and <link id="aldraw.al_clear_to_color">al_clear_to_color</link> procedures are implemented using a hardware accelerator.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_FILL_XOR" />
	<link id="AL_GFX_HW_FILL_SOLID_PATTERN" />
	<link id="AL_GFX_HW_FILL_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_FILL_XOR">
<short>Indicates that the XOR version of the <link id="aldraw.al_rectfill">al_rectfill</link> procedure is implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_FILL" />
	<link id="AL_GFX_HW_FILL_SOLID_PATTERN" />
	<link id="AL_GFX_HW_FILL_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_FILL_SOLID_PATTERN">
<short>Indicates that the solid and masked pattern modes of the <link id="aldraw.al_rectfill">al_rectfill</link> procedure are implemented using a hardware accelerator (see note below).</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_FILL" />
	<link id="AL_GFX_HW_FILL_XOR" />
	<link id="AL_GFX_HW_FILL_COPY_PATTERN" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_FILL_COPY_PATTERN">
<short>Indicates that the copy pattern mode of the <link id="aldraw.al_rectfill">al_rectfill</link> procedure is implemented using a hardware accelerator (see note below).</short>
<descr>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_FILL" />
	<link id="AL_GFX_HW_FILL_XOR" />
	<link id="AL_GFX_HW_FILL_SOLID_PATTERN" />
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_LINE">
<short>Indicates that the opaque mode <link id="aldraw.al_line">al_line</link> and <link id="aldraw.al_vline">al_vline</link> procedures functions are implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_LINE_XOR" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_LINE_XOR">
<short>Indicates that the XOR mode <link id="aldraw.al_line">al_line</link> and <link id="aldraw.al_vline">al_vline</link> procedures functions are implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_LINE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_TRIANGLE">
<short>Indicates that the opaque mode triangle() function is implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_TRIANGLE_XOR" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_TRIANGLE_XOR">
<short>Indicates that the XOR mode triangle() function is implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_TRIANGLE" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_GLYPH">
<short>Indicates that monochrome character expansion (for <link id="altext">text drawing</link>) is implemented using a hardware accelerator.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="altext" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_VRAM_BLIT">
<short>Indicates that blitting from one part of the screen to another is implemented using a hardware accelerator.</short>
<descr>
	<p>Indicates that blitting from one part of the screen to another is implemented using a hardware accelerator. If this flag is set, blitting within the video memory will almost certainly be the fastest possible way to display an image, so it may be worth storing some of your more frequently used graphics in an offscreen portion of the video memory.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_VRAM_BLIT_MASKED" />
	<link id="AL_GFX_HW_MEM_BLIT" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT" />
	<link id="albltspr" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_VRAM_BLIT_MASKED">
<short>Indicates that the <link id="albltspr.al_masked_blit">al_masked_blit</link> and <link id="albltspr.al_draw_sprite">al_draw_sprite</link> procedures are capable of a hardware accelerated copy from one part of video memory to another.</short>
<descr>
	<p>Indicates that the <link id="albltspr.al_masked_blit">al_masked_blit</link> procedure is capable of a hardware accelerated copy from one part of video memory to another, and that <link id="albltspr.al_draw_sprite">al_draw_sprite</link> will use a hardware copy when given a sub-bitmap of the screen or a video memory bitmap as the source image. If this flag is set, copying within the video memory will almost certainly be the fastest possible way to display an image, so it may be worth storing some of your more frequently used sprites in an offscreen portion of the video memory.</p>
	<p><b>Warning:</b> if this flag is not set, al_masked_blit and al_draw_sprite will not work correctly when used with a video memory source image! You must only try to use these functions to copy within the video memory if they are supported in hardware.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_VRAM_BLIT" />
	<link id="AL_GFX_HW_MEM_BLIT_MASKED" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED" />
	<link id="albltspr.al_masked_blit">al_masked_blit</link>
	<link id="albltspr.al_draw_sprite">al_draw_sprite</link>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_MEM_BLIT">
<short>Indicates that blitting from a memory bitmap onto the screen is being accelerated in hardware.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_MEM_BLIT_MASKED" />
	<link id="AL_GFX_HW_VRAM_BLIT" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT" />
	<link id="albltspr" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_MEM_BLIT_MASKED">
<short>Indicates that the <link id="albltspr.al_masked_blit">al_masked_blit</link> and <link id="albltspr.al_draw_sprite">al_draw_sprite</link> procedures are being accelerated in hardware when the source image is a memory bitmap and the destination is the physical screen.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_MEM_BLIT" />
	<link id="AL_GFX_HW_VRAM_BLIT_MASKED" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED" />
	<link id="albltspr.al_masked_blit">al_masked_blit</link>
	<link id="albltspr.al_draw_sprite">al_draw_sprite</link>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_SYS_TO_VRAM_BLIT">
<short>Indicates that blitting from a system bitmap onto the screen is being accelerated in hardware.</short>
<descr>
	<p>Indicates that blitting from a system bitmap onto the screen is being accelerated in hardware. Note that some acceleration may be present even if this flag is not set, because system bitmaps can benefit from normal memory to screen blitting as well. This flag will only be set if system bitmaps have further acceleration above and beyond what is provided by <link id="AL_GFX_HW_MEM_BLIT" />.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED" />
	<link id="AL_GFX_HW_VRAM_BLIT" />
	<link id="AL_GFX_HW_MEM_BLIT" />
	<link id="albltspr" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED">
<short>Indicates that the <link id="albltspr.al_masked_blit">al_masked_blit</link> and <link id="albltspr.al_draw_sprite">al_draw_sprite</link> procedures are being accelerated in hardware when the source image is a system bitmap and the destination is the physical screen.</short>
<descr>
	<p>Indicates that the <link id="albltspr.al_masked_blit">al_masked_blit</link> and <link id="albltspr.al_draw_sprite">al_draw_sprite</link> procedures are being accelerated in hardware when the source image is a system bitmap and the destination is the physical screen. Note that some acceleration may be present even if this flag is not set, because system bitmaps can benefit from normal memory to screen blitting as well. This flag will only be set if system bitmaps have further acceleration above and beyond what is provided by <link id="AL_GFX_HW_MEM_BLIT_MASKED" />.</p>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT" />
	<link id="AL_GFX_HW_VRAM_BLIT_MASKED" />
	<link id="AL_GFX_HW_MEM_BLIT_MASKED" />
	<link id="albltspr.al_masked_blit">al_masked_blit</link>
	<link id="albltspr.al_draw_sprite">al_draw_sprite</link>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_GFX_SYSTEM_CURSOR">
<short>Indicates that a hardware mouse cursor is in use.</short>
<descr>
</descr>
<seealso>
	<link id="al_gfx_capabilities" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_gfx_capabilities">
<short>Bitfield describing video hardware capabilities.</short>
<descr>
	<p>Bitfield describing the capabilities of the current graphics driver and video hardware. This may contain combination any of the flags descrived in the <b>See also</b> section.</p>
	<p><b>Note:</b> even if the capabilities information says that patterned drawing is supported by the hardware, it will not be possible for every size of pattern. VBE/AF only supports patterns up to 8x8 in size, so Allegro will fall back on the original non-accelerated drawing routines whenever you use a pattern larger than this.</p>
	<p><b>Note2:</b> these hardware acceleration features will only take effect when you are drawing directly onto the screen bitmap, a video memory bitmap, or a sub-bitmap thereof. Accelerated hardware is most useful in a page flipping or triple buffering setup, and is unlikely to make any difference to the classic "draw onto a memory bitmap, then blit to the screen" system. </p>
	<p><b>Note3:</b> current version of Allegro.pas doesn't implements all functions and procedures to take advantages of all hardware accelerations. Original Allegro does.</p>
</descr>
<seealso>
	<link id="AL_GFX_CAN_SCROLL" />
	<link id="AL_GFX_CAN_TRIPLE_BUFFER" />
	<link id="AL_GFX_HW_CURSOR" />
	<link id="AL_GFX_SYSTEM_CURSOR" />
	<link id="AL_GFX_HW_HLINE" />
	<link id="AL_GFX_HW_HLINE_XOR" />
	<link id="AL_GFX_HW_HLINE_SOLID_PATTERN" />
	<link id="AL_GFX_HW_HLINE_COPY_PATTERN" />
	<link id="AL_GFX_HW_FILL" />
	<link id="AL_GFX_HW_FILL_XOR" />
	<link id="AL_GFX_HW_FILL_SOLID_PATTERN" />
	<link id="AL_GFX_HW_FILL_COPY_PATTERN" />
	<link id="AL_GFX_HW_LINE" />
	<link id="AL_GFX_HW_LINE_XOR" />
	<link id="AL_GFX_HW_TRIANGLE" />
	<link id="AL_GFX_HW_TRIANGLE_XOR" />
	<link id="AL_GFX_HW_GLYPH" />
	<link id="AL_GFX_HW_VRAM_BLIT" />
	<link id="AL_GFX_HW_VRAM_BLIT_MASKED" />
	<link id="AL_GFX_HW_MEM_BLIT" />
	<link id="AL_GFX_HW_MEM_BLIT_MASKED" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT" />
	<link id="AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_screen">
<short>Global pointer to the screen hardware video memory.</short>
<descr>
	<p>Global pointer to a bitmap, sized <link id="AL_VIRTUAL_W" /> x <link id="AL_VIRTUAL_H" />. This is created by <link id="al_set_gfx_mode" />, and represents the hardware video memory. Only a part of this bitmap will actually be visible, sized <link id="AL_SCREEN_W" /> x <link id="AL_SCREEN_H" />. Normally this is the top left corner of the larger virtual screen, so you can ignore the extra invisible virtual size of the bitmap if you aren't interested in hardware scrolling or page flipping.<!-- To move the visible window to other parts of the screen bitmap, call scroll_screen().--> Initially the clipping rectangle will be limited to the physical screen size, so if you want to draw onto a larger virtual screen space outside this rectangle, you will need to adjust the clipping.</p>
	<p>For example, to draw a pixel onto the screen you would write:</p>
	<code>al_putpixel (al_screen, x, y, color);</code>
	<p>Or to implement a double-buffered system:</p>
	<code>VAR
  Bmp: AL_BITMAPptr;
BEGIN
{ Make a bitmap in RAM. }
  Bmp := al_create_bitmap (320, 200);
{ Clean the memory bitmap. }
  al_clear_bitmap (Bmp);
{ Draw onto the memory bitmap. }
  al_putpixel (Bmp, x, y, color);
{ Copy it to the screen. }
  al_blit (Bmp, al_screen, 0, 0, 0, 0, 320, 200);</code>
	<!-- Warning: be very careful when using this pointer at the same time as any bitmaps created by the create_video_bitmap() function (see the description of this function for more detailed information). And never try to destroy it with destroy_bitmap(). -->
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="al_is_screen_bitmap" />
	<!-- create_video_bitmap, scroll_screen -->
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_SCREEN_W">
<short>Global define to obtain the size of the screen.</short>
<descr>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_SCREEN_H" />
	<link id="AL_VIRTUAL_W" />
	<link id="AL_VIRTUAL_H" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_SCREEN_H">
<short>Global define to obtain the size of the screen.</short>
<descr>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_SCREEN_W" />
	<link id="AL_VIRTUAL_W" />
	<link id="AL_VIRTUAL_H" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_VIRTUAL_W">
<short>Global define to obtain the virtual size of the screen.</short>
<descr>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_VIRTUAL_H" />
	<link id="AL_SCREEN_W" />
	<link id="AL_SCREEN_H" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_VIRTUAL_H">
<short>Global define to obtain the virtual size of the screen.</short>
<descr>
</descr>
<seealso>
	<link id="al_set_gfx_mode" />
	<link id="AL_VIRTUAL_W" />
	<link id="AL_SCREEN_W" />
	<link id="AL_SCREEN_H" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_NONE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_8_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_8_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_8_TO_24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_8_TO_32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_15_TO_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_15_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_15_TO_24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_15_TO_32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_16_TO_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_16_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_16_TO_24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_16_TO_32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_24_TO_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_24_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_24_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_24_TO_32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32_TO_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32_TO_24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32A_TO_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32A_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32A_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_32A_TO_24">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_DITHER_PAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_DITHER_HI">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_KEEP_TRANS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_DITHER">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_EXPAND_256">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_REDUCE_TO_256">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_EXPAND_15_TO_16">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_REDUCE_16_TO_15">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_EXPAND_HI_TO_TRUE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_REDUCE_TRUE_TO_HI">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_24_EQUALS_32">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_TOTAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_PARTIAL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_MOST">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_COLORCONV_KEEP_ALPHA">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_color_depth">
<short>Sets the global pixel color depth.</short>
<descr>
	<p>Sets the pixel format to be used by subsequent calls to <link id="al_set_gfx_mode" /> and <link id="albitmap.al_create_bitmap">al_create_bitmap</link>. Valid depths are 8 (the default), 15, 16, 24, and 32 bits. Example:</p>
	<code>al_set_color_depth (32);
IF al_set_gfx_mode (AL_GFX_AUTODETECT, 640, 480, 0, 0) &lt;&gt; 0 THEN
  al_message ('Couldn''t set a 32 bit color resolution');</code>
	<p>Note that the screen color depth won't change until the next successful call to al_set_gfx_mode.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_color_depth" />
	<link id="al_set_gfx_mode" />
	<link id="al_set_color_conversion" />
	<link id="alcolor.al_makecol">al_makecol</link>
	<link id="alsystem.al_desktop_color_depth">al_desktop_color_depth</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_depth.depth">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_color_depth">
<short>Returns the current pixel color depth.</short>
<descr>
	<p>Returns the current pixel format. This can be very useful to know in order to write generic functions which select a different code path internally depending on the color depth being used.</p>
	<p>Note that the function returns whatever value you may have set previously with <link id="al_set_color_depth" />, which can be different from the current color depth of the screen global variable. If you really need to know the color depth of the screen, use <link id="albitmap.al_bitmap_color_depth">al_bitmap_color_depth</link>.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_color_depth" />
	<link id="albitmap.al_bitmap_color_depth">al_bitmap_color_depth</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_color_depth.Result">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_color_conversion">
<short>Tells Allegro how to convert images during loading time.</short>
<descr>
	<p>Specifies how to convert images between the various color depths when reading graphics from external bitmap files or datafiles. The mode is a bitmask specifying which types of conversion are allowed. If the appropriate bit is set, data will be converted into the current pixel format (selected by calling the <link id="al_set_color_depth" /> procedure), otherwise it will be left in the same format as the disk file, leaving you to convert it manually before the graphic can be displayed. The default mode is total conversion, so that all images will be loaded in the appropriate format for the current video mode. Valid bit flags are:</p>
	<pre>AL_COLORCONV_NONE                // disable all format
                                 // conversions
AL_COLORCONV_8_TO_15             // expand 8-bit to 15-bit
AL_COLORCONV_8_TO_16             // expand 8-bit to 16-bit
AL_COLORCONV_8_TO_24             // expand 8-bit to 24-bit
AL_COLORCONV_8_TO_32             // expand 8-bit to 32-bit
AL_COLORCONV_15_TO_8             // reduce 15-bit to 8-bit
AL_COLORCONV_15_TO_16            // expand 15-bit to 16-bit
AL_COLORCONV_15_TO_24            // expand 15-bit to 24-bit
AL_COLORCONV_15_TO_32            // expand 15-bit to 32-bit
AL_COLORCONV_16_TO_8             // reduce 16-bit to 8-bit
AL_COLORCONV_16_TO_15            // reduce 16-bit to 15-bit
AL_COLORCONV_16_TO_24            // expand 16-bit to 24-bit
AL_COLORCONV_16_TO_32            // expand 16-bit to 32-bit
AL_COLORCONV_24_TO_8             // reduce 24-bit to 8-bit
AL_COLORCONV_24_TO_15            // reduce 24-bit to 15-bit
AL_COLORCONV_24_TO_16            // reduce 24-bit to 16-bit
AL_COLORCONV_24_TO_32            // expand 24-bit to 32-bit
AL_COLORCONV_32_TO_8             // reduce 32-bit RGB to 8-bit
AL_COLORCONV_32_TO_15            // reduce 32-bit RGB to 15-bit
AL_COLORCONV_32_TO_16            // reduce 32-bit RGB to 16-bit
AL_COLORCONV_32_TO_24            // reduce 32-bit RGB to 24-bit
AL_COLORCONV_32A_TO_8            // reduce 32-bit RGBA to 8-bit
AL_COLORCONV_32A_TO_15           // reduce 32-bit RGBA to 15-bit
AL_COLORCONV_32A_TO_16           // reduce 32-bit RGBA to 16-bit
AL_COLORCONV_32A_TO_24           // reduce 32-bit RGBA to 24-bit
AL_COLORCONV_DITHER_PAL          // dither when reducing to 8-bit
AL_COLORCONV_DITHER_HI           // dither when reducing to
                                 // hicolor
AL_COLORCONV_KEEP_TRANS          // keep original transparency</pre>
	<p>For convenience, the following macros can be used to select common combinations of these flags:</p>
	<pre>AL_COLORCONV_EXPAND_256          // expand 256-color to hi/truecolor
AL_COLORCONV_REDUCE_TO_256       // reduce hi/truecolor to 256-color
AL_COLORCONV_EXPAND_15_TO_16     // expand 15-bit hicolor to 16-bit
AL_COLORCONV_REDUCE_16_TO_15     // reduce 16-bit hicolor to 15-bit
AL_COLORCONV_EXPAND_HI_TO_TRUE   // expand 15/16-bit to 24/32-bit
AL_COLORCONV_REDUCE_TRUE_TO_HI   // reduce 24/32-bit to 15/16-bit
AL_COLORCONV_24_EQUALS_32        // convert between 24- and 32-bit
AL_COLORCONV_TOTAL               // everything to current format
AL_COLORCONV_PARTIAL             // convert 15 &lt;-&gt; 16-bit and
                                 // 24 &lt;-&gt; 32-bit
AL_COLORCONV_MOST                // all but hi/truecolor &lt;-&gt; 256
AL_COLORCONV_DITHER              // dither during all color reductions
AL_COLORCONV_KEEP_ALPHA          // convert everything to current format
                                 // unless it would lose alpha information</pre>
	<p>If you enable the AL_COLORCONV_DITHER flag, dithering will be performed whenever truecolor graphics are converted into a hicolor or paletted format, including by the <link id="albltspr.al_blit">al_blit</link> procedure, and any automatic conversions that take place while reading graphics from disk. This can produce much better looking results, but is obviously slower than a direct conversion.</p>
	<p>If you intend using converted bitmaps with functions like <link id="albltspr.al_masked_blit">al_masked_blit</link> or <link id="albltspr.al_draw_sprite">al_draw_sprite</link>, you should specify the AL_COLORCONV_KEEP_TRANS flag. It will ensure that the masked areas in the bitmap before and after the conversion stay exactly the same, by mapping transparent colors to each other and adjusting colors which would be converted to the transparent color otherwise. It affects every al_blit operation between distinct pixel formats and every automatic conversion.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_color_depth" />
	<link id="albitmap.al_load_bitmap">al_load_bitmap</link>
	<link id="aldtfile.al_load_datafile">al_load_datafile</link>
	<link id="al_get_color_conversion" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_conversion.mode">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_color_conversion">
<short>Returns the current color conversion mode.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_color_conversion" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_color_conversion.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_set_gfx_mode">
<short>Sets a graphic video mode.</short>
<descr>
	<p>Switches into graphics mode. The card parameter should usually be one of the Allegro magic drivers (read <link id="algraph">introduction of chapter <i>"Graphics modes"</i></link>)<!-- or see the platform specific documentation for a list of the available drivers-->. The w and h parameters specify what screen resolution you want. The color depth of the graphic mode has to be specified before calling this function with <link id="al_set_color_depth" />.</p>
	<p>The v_w and v_h parameters specify the minimum virtual screen size, in case you need a large virtual screen for hardware scrolling or page flipping. You should set them to zero if you don't care about the virtual screen size.</p>
	<p>When you call al_set_gfx_mode, the v_w and v_h parameters represent the minimum size of virtual screen that is acceptable for your program. The range of possible sizes is usually very restricted, and Allegro may end up creating a virtual screen much larger than the one you request. Allowed sizes are driver dependent and some drivers do not allow virtual screens that are larger than the visible screen at all: don't assume that whatever you pass will always work.</p>
	<p>In mode-X the virtual width can be any multiple of eight greater than or equal to the physical screen width, and the virtual height will be set accordingly (the VGA has 256k of vram, so the virtual height will be 256*1024/virtual_width).</p>
	<!--Currently, using a big virtual screen for page flipping is considered bad practice. There are platforms which don't support virtual screens bigger than the physical screen but can create different video pages to flip back and forth. This means that, if you want page flipping and aren't going to use hardware scrolling, you should call set_gfx_mode() with (0,0) as the virtual screen size and later create the different video pages with create_video_bitmap(). Otherwise your program will be limited to the platforms supporting hardware scrolling.-->
	<p>After you select a graphics mode, the physical and virtual screen sizes can be checked with the variables <link id="AL_SCREEN_W" />, <link id="AL_SCREEN_H" />, <link id="AL_VIRTUAL_W" /> and <link id="AL_VIRTUAL_H" />.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_color_depth" />
	<link id="al_screen" />
	<link id="alsystem.al_error">al_error</link>
	<link id="AL_GFX_AUTODETECT" />
	<link id="AL_GFX_AUTODETECT_FULLSCREEN" />
	<link id="AL_GFX_AUTODETECT_WINDOWED" />
	<link id="AL_GFX_SAFE" />
	<link id="AL_GFX_TEXT" />
	<link id="AL_SCREEN_W" />
	<link id="AL_SCREEN_H" />
	<link id="AL_VIRTUAL_W" />
	<link id="AL_VIRTUAL_H" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_set_gfx_mode.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_gfx_mode.card">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_gfx_mode.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_gfx_mode.h">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_gfx_mode.v_w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_gfx_mode.v_h">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_is_screen_bitmap">
<short>Tells if a bitmap is the screen bitmap or sub bitmap.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_screen" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_is_screen_bitmap.Result">
<short>Returns TRUE if bmp is the screen bitmap, or a sub-bitmap of the screen.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_is_screen_bitmap.bmp">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_acquire_screen">
<short>Shortcut of <link id="albitmap.al_acquire_bitmap">al_acquire_bitmap</link>(<link id="al_screen" />);</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_release_screen" />
	<link id="albitmap.al_acquire_bitmap">al_acquire_bitmap</link>
	<link id="albitmap.al_release_bitmap">al_release_bitmap</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_release_screen">
<short>Shortcut of <link id="albitmap.al_release_bitmap">al_release_bitmap</link>(<link id="al_screen" />);</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_acquire_screen" />
	<link id="albitmap.al_acquire_bitmap">al_acquire_bitmap</link>
	<link id="albitmap.al_release_bitmap">al_release_bitmap</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_vsync">
<short>Waits for a vertical retrace to begin.</short>
<descr>
	<p>Waits for a vertical retrace to begin. The retrace happens when the electron beam in your monitor has reached the bottom of the screen and is moving back to the top ready for another scan. During this short period the graphics card isn't sending any data to the monitor, so you can do things to it that aren't possible at other times, such as altering the palette without causing flickering (snow). Allegro will automatically wait for a retrace before altering the palette or doing any hardware scrolling, though, so you don't normally need to bother with this function.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alpalete.al_set_palette">al_set_palette</link>
	<!-- scroll_screen -->
</seealso>
</element>

</module> <!-- algraph -->


<!--
  ====================================================================
    aljstick
  ====================================================================
-->

<module name="aljstick">
<short>Joystick and gamepad input</short>
<descr>
	<p>Unlike keyboard or mouse input, which are usually read through hardware interrupts by Allegro, joystick input functions have to be polled because there are no hardware interrupts for them on most platforms. This doesn't mean that you have to poll the joysticks on each line of code you want to read their values, but you should make sure to poll them at least once per frame in your game loop. Otherwise you face the possibility of reading stale incorrect data.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_JOY_TYPE_AUTODETECT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOY_TYPE_NONE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MAX_JOYSTICKS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MAX_JOYSTICK_AXIS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MAX_JOYSTICK_STICKS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MAX_JOYSTICK_BUTTONS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_DIGITAL">
<short>This control is currently providing digital input.</short>
<descr>
</descr>
<seealso>
	<link id="al_joy" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_ANALOGUE">
<short>This control is currently providing analogue input.</short>
<descr>
</descr>
<seealso>
	<link id="al_joy" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_CALIB_DIGITAL">
<short>This controll needs to be calibrated for digital input.</short>
<descr>
	<p>This control will be capable of providing digital input once it has been calibrated, but is not doing this at the moment.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="al_calibrate_joystick" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_CALIB_ANALOGUE">
<short>This control needs to be calibrated for analogue input.</short>
<descr>
	<p>This control will be capable of providing analogue input once it has been calibrated, but is not doing this at the moment.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="al_calibrate_joystick" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_CALIBRATE">
<short>This control needs to be calibrated.</short>
<descr>
	<p>Indicates that this control needs to be calibrated. Many devices require multiple calibration steps, so you should call the <link id="al_calibrate_joystick" /> function from a loop until this flag is cleared.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="al_calibrate_joystick" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_SIGNED">
<short>This control uses signed format.</short>
<descr>
	<p>Indicates that the analogue axis position is in signed format, ranging from -128 to 128. This is the case for all 2d directional controls.</p>
</descr>
<seealso>
	<link id="al_joy" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_UNSIGNED">
<short>This control uses unsigned format.</short>
<descr>
	<p>Indicates that the analogue axis position is in unsigned format, ranging from 0 to 255. This is the case for all 1d throttle controls.</p>
</descr>
<seealso>
	<link id="al_joy" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_ANALOG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_JOYFLAG_CALIB_ANALOG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="AL_JOYSTICK_AXIS_INFO">
<short>Stores joystick axis information.</short>
<descr>
	<p>Read <link id="aljstick">Joystick routines overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="aljstick">Joystick routines overview</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_AXIS_INFO.pos">
<short>Analogue axis position.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_AXIS_INFO.d1">
<short>Digital axis position.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_AXIS_INFO.d2">
<short>Digital axis position.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_AXIS_INFO.name">
<short>Description of this axis.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_JOYSTICK_STICK_INFO">
<short>Stores joystick stick information.</short>
<descr>
	<p>Read <link id="aljstick">Joystick routines overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="aljstick">Joystick routines overview</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_STICK_INFO.flags">
<short>Status flags for this intup.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_STICK_INFO.num_axis">
<short>How many axes do we have? (note the misspelling)</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_STICK_INFO.axis">
<short>Axis state information.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_STICK_INFO.name">
<short>Description of this input</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_JOYSTICK_BUTTON_INFO">
<short>Stores joystick button information.</short>
<descr>
	<p>Read <link id="aljstick">Joystick routines overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_joy" /><link id="aljstick">Joystick routines overview</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_BUTTON_INFO.b">
<short>Boolean on/off flag.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_BUTTON_INFO.name">
<short>Description of this button.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_JOYSTICK_INFOptr">
<short>Pointer to <link id="AL_JOYSTICK_INFO" />.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_JOYSTICK_INFO">
<short>Stores information about joysticks.</short>
<descr>
	<p>Read <link id="aljstick">Joystick routines overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_joy" />
	<link id="aljstick">Joystick overview</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_INFO.flags">
<short>Status flag for this joystick.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_INFO.num_sticks">
<short>How many stick inputs?</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_INFO.num_buttons">
<short>How many buttons?</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_INFO.stick">
<short>Stick state information.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_JOYSTICK_INFO.button">
<short>Button state information.</short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_JOYSTICK_INFO_LISTptr">
	<short>Pointer to <link id="AL_JOYSTICK_INFO_LIST" /></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="AL_JOYSTICK_INFO_LIST">
<short>Stores a list with the joystick information.</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_joy">
<short>Global array of joystick state information.</short>
<descr>
	<p>Global array of joystick state information, which is updated by the <link id="al_poll_joystick" /> procedure. Only the first <link id="al_num_joysticks" /> elements will contain meaningful information. The <link id="AL_JOYSTICK_INFO" /> structure contains all joystick information.</p>
	<p>You may wish to display the button names as part of an input configuration screen to let the user choose what game function will be performed by each button, but in simpler situations you can safely assume that the first two elements in the button array will always be the main trigger controls.</p>
	<p>Each joystick will provide one or more stick inputs, of varying types. These can be digital controls which snap to specific positions (eg. a gamepad controller, the coolie hat on a Flightstick Pro or Wingman Extreme, or a normal joystick which hasn't yet been calibrated), or they can be full analogue inputs with a smooth range of motion. Sticks may also have different numbers of axes, for example a normal directional control has two, but the Flightstick Pro throttle is only a single axis, and it is possible that the system could be extended in the future to support full 3d controllers. A stick input is described by the structure <link id="AL_JOYSTICK_STICK_INFO" />.</p>
	<p>A single joystick may provide several different stick inputs, but you can safely assume that the first element in the stick array will always be the main directional controller.</p>
	<p>Information about each of the stick axis is stored in the substructure <link id="AL_JOYSTICK_AXIS_INFO" />. This provides both analogue input in the <var>pos</var> field (ranging from -128 to 128 or from 0 to 255, depending on the type of the control), and digital values in the <var>d1</var> and <var>d2</var> fields. For example, when describing the X-axis position, the <var>pos</var> field will hold the horizontal position of the joystick, <var>d1</var> will be set if it is moved left, and <var>d2</var> will be set if it is moved right. Allegro will fill in all these values regardless of whether it is using a digital or analogue joystick, emulating the <var>pos</var> field for digital inputs by snapping it to the min, middle, and maximum positions, and emulating the d1 and d2 values for an analogue stick by comparing the current position with the centre point.</p>
	<p>The joystick flags field may contain any combination of the bit flags <link id="AL_JOYFLAG_DIGITAL" />, <link id="AL_JOYFLAG_ANALOGUE" />, <link id="AL_JOYFLAG_CALIB_DIGITAL" />, <link id="AL_JOYFLAG_CALIB_ANALOGUE" />, <link id="AL_JOYFLAG_CALIBRATE" />, <link id="AL_JOYFLAG_SIGNED" />, and <link id="AL_JOYFLAG_UNSIGNED" />.</p>
	<!--
Note for people who spell funny: in case you don't like having to type "analogue", there are some #define aliases in allegro/joystick.h that will allow you to write "analog" instead. 
-->
	<p>Example:</p>
	<code>REPEAT
{ Get joystick input }
  al_poll_joystick;
{ Process input for the first joystick }
IF al_joy^[0].button[0].b &lt;&gt; 0 THEN
  FirstButtonPressed;
IF al_joy^[0].button[1].b &lt;&gt; 0 THEN
  SecondButtonPressed;
      ...
UNTIL Done;</code>
</descr>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_poll_joystick" />
	<link id="al_num_joysticks" />
	<link id="al_calibrate_joystick" />
	<link id="al_calibrate_joystick_name" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_num_joysticks">
<short>Global variable saying how many joysticks there are.</short>
<descr>
	<p>Global variable containing the number of active joystick devices. The current drivers support a maximum of eight controllers.</p>
</descr>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_joy" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_install_joystick">
<short>Initialises the joystick.</short>
<descr>
	<p>Installs Allegro's joystick handler, and calibrates the centre position values. The type parameter should usually be <link id="AL_JOY_TYPE_AUTODETECT" />, or see the platform specific documentation for a list of the available drivers. You must call this routine before using any other joystick functions, and you should make sure that all joysticks are in the middle position at the time. Example:</p>
	<code>al_textout_centre_ex (al_screen, al_font^,
                      'Center the joystick and press a key',
		      AL_SCREEN_W DIV 2, AL_SCREEN_H DIV 2, RedColor, -1);
al_readkey;
IF al_install_joystick (AL_JOY_TYPE_AUTODETECT) &lt;&gt; 0 THEN
  abort_on_error ('Error initialising joystick!');</code>
	<p>As soon as you have installed the joystick module, you will be able to read the button state and digital (on/off toggle) direction information, which may be enough for some games. If you want to get full analogue input, though, you need to use the <link id="al_calibrate_joystick" /> functions to measure the exact range of the inputs.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_remove_joystick" />
	<link id="al_num_joysticks" />
	<link id="al_load_joystick_data" />
	<link id="al_calibrate_joystick" />
	<link id="al_calibrate_joystick_name" />
	<link id="al_poll_joystick" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_joystick.Result">
<short>Returns zero on success.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_joystick.atype">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_joystick">
<short>Removes the joystick handler.</short>
<descr>
	<p>Removes the joystick handler. You don't normally need to bother calling this, because  will do it for you.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_joystick" />
	<link id="alsystem.al_exit">al_exit</link>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_calibrate_joystick_name">
<short>Returns the next calibration text string.</short>
<descr>
	<p>Pass the number of the joystick you want to calibrate as the parameter.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_calibrate_joystick" />
	<link id="al_joy" />
	<link id="al_num_joysticks" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_calibrate_joystick_name.Result">
<short>Returns a text description for the next type of calibration that will be done on the specified joystick, or NIL if no more calibration is required.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_calibrate_joystick_name.n">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_calibrate_joystick">
<short>Calibrates the specified joystick.</short>
<descr>
	<p>Most joysticks need to be calibrated before they can provide full analogue input. This function performs the next operation in the calibration series for the specified stick, assuming that the joystick has been positioned in the manner described by a previous call to <link id="al_calibrate_joystick_name" />, returning zero on success. For example, a simple routine to fully calibrate all the joysticks might look like:</p>
	<code>VAR
  I: INTEGER;
  Msg: STRING;
BEGIN
  FOR I := 0 TO al_num_joysticks^ - 1 DO
  BEGIN
    WHILE al_joy^[i].flags AND AL_JOYFLAG_CALIBRATE &lt;&gt; 0 DO
    BEGIN
      Msg := al_calibrate_joystick_name (i);
      al_textout_centre_ex (al_screen, al_font^, Msg+', and press a key',
                            AL_SCREEN_W DIV 2, AL_SCREEN_H DIV 2,
                            al_makecol (255, 255, 255), 0);
      al_readkey;
      IF al_calibrate_joystick (i) &lt;&gt; 0 THEN
      BEGIN
        al_textout_ex (al_screen, al_font^, 'oops!',
                       AL_SCREEN_W DIV 2, (AL_SCREEN_H DIV 2) + 10,
                       al_makecol (255, 255, 255), 0);
        al_readkey();
        EXIT;
      END;
    END;
  END;
END;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_calibrate_joystick_name" />
	<link id="al_joy" />
	<link id="al_num_joysticks" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_calibrate_joystick.Result">
<short>Returns zero on success, non-zero if the calibration could not be performed successfully.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_calibrate_joystick.n">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_save_joystick_data">
<short>Saves joystick calibration data.</short>
<descr>
	<p>After all the headache of calibrating the joystick, you may not want to make your poor users repeat the process every time they run your program. Call this function to save the joystick calibration data into the specified configuration file, from which it can later be read by <link id="al_load_joystick_data" />. Pass a NIL filename to write the data to the currently selected configuration file.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_joystick_data" />
	<link id="alconfig.al_set_config_file">al_set_config_file</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_save_joystick_data.Result">
<short>Returns zero on success, non-zero if the data could not be saved.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_save_joystick_data.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_joystick_data">
<short>Loads joystick calibration data.</short>
<descr>
	<p>Restores calibration data previously stored by <link id="al_save_joystick_data" /> or the setup utility. This sets up all aspects of the joystick code: you don't even need to call <link id="al_install_joystick" /> if you are using this function. Pass a NIL filename to read the data from the currently selected configuration file.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_save_joystick_data" />
	<link id="alconfig.al_set_config_file">al_set_config_file</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_joystick_data.Result">
<short>Returns zero on success: if it fails the joystick state is undefined and you must reinitialise it from scratch.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_joystick_data.filename">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_poll_joystick">
<short>Polls the joystick.</short>
<descr>
	<p>The joystick handler is not interrupt driven, so you need to call this function every now and again to update the global position values.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_joystick" />
	<link id="al_joy" />
	<link id="al_num_joysticks" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_poll_joystick.Result">
<short>Returns zero on success or a negative number on failure (usually because no joystick driver was installed).</short>
</element>

</module> <!-- aljstick -->


<!--
  ====================================================================
    alkeybrd
  ====================================================================
-->

<module name="alkeybrd">
<short>Keyboard input</short>
<descr>
	<p>The Allegro keyboard handler provides both buffered input and a set of flags storing the current state of each key. Note that it is not possible to correctly detect every combination of keys, due to the design of the PC keyboard. Up to two or three keys at a time will work fine, but if you press more than that the extras are likely to be ignored (exactly which combinations are possible seems to vary from one keyboard to another).</p>
	<p>On DOS, Allegro requires the user to specify the language of the keyboard mapping because it is impossible to obtain this information from the OS, otherwise the default US keyboard mapping will be used. Allegro comes with a prepackaged <var>keyboard.dat</var> file which you can put along with your binary. If this file is present, Allegro will be able to extract the keyboard mapping information stored there. However, the end user still needs to select which keyboard mapping to use. This can be acomplished through the keyboard variable of the system section in a standard <var>allegro.cfg</var> configuration file. Read chapter <link id="alconfig">Configuration routines</link> for more information about this.</p>
</descr>

<!-- function Visibility: default -->
<element name="al_install_keyboard">
<short>Installs the Allegro keyboard interrupt handler.</short>
<descr>
	<p>Installs the Allegro keyboard interrupt handler. You must call this before using any of the keyboard input routines. Once you have set up the Allegro handler, you can no longer use operating system calls or Pascal library functions to access the keyboard.</p>
	<p>Note that on some platforms the keyboard won't work unless you have set a graphics mode, even if this function returns a success value before calling <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>. This can happen in environments with graphic windowed modes, since Allegro usually reads the keyboard through the graphical window (which appears after the <var>al_set_gfx_call</var>). Example:</p>
	<code>al_allegro_init;
al_install_timer;
al_install_keyboard;
{ We are not 100% sure we can read the keyboard yet! }
IF al_set_gfx_mode (AL_GFX_AUTODETECT, 640, 480, 0, 0) &lt;&gt; 0 THEN
  abort_on_error ('Couldn''t set graphic mode!');
{ Now we are guaranteed to be able to read the keyboard. }
al_readkey;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_remove_keyboard" />
	<link id="al_poll_keyboard" />
	<link id="al_key" />
	<link id="al_keypressed" />
	<link id="al_readkey" />
	<link id="al_key_led_flag" />
	<link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_keyboard.Result">
<short>Returns zero on success, or a negative number on failure (but you may decide not to check the return value as this function is very unlikely to fail).</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_keyboard">
<short>Removes the Allegro keyboard handler</short>
<descr>
	<p>Removes the keyboard handler, returning control to the operating system. You don't normally need to bother calling this, because <link id="alsystem.al_exit">al_exit</link> will do it for you. However, you might want to call this during runtime if you want to change the keyboard mapping on those platforms were keyboard mappings are needed. You would first modify the configuration variable holding the keyboard mapping and then reinstall the keyboard handler. Example:</p>
	<code>al_remove_keyboard;
{ Switch to Spanish keyboard mapping. }
al_set_config_string ('system', 'keyboard', 'es');
al_install_keyboard;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="alsystem.al_exit">al_exit</link>
	<link id="alconfig.al_set_config_string">al_set_config_string</link>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_poll_keyboard">
<short>Polls the keyboard.</short>
<descr>
	<p>Wherever possible, Allegro will read the keyboard input asynchronously (ie. from inside an interrupt handler), but on some platforms that may not be possible, in which case you must call this routine at regular intervals to update the keyboard state variables.</p>
	<p>To help you test your keyboard polling code even if you are programming on a platform that doesn't require it, after the first time that you call this function Allegro will switch into polling mode, so from that point onwards you will have to call this routine in order to get any keyboard input at all, regardless of whether the current driver actually needs to be polled or not.</p>
	<p>The <link id="al_keypressed" />, <link id="al_readkey" />, and <link id="al_ureadkey" /> functions call al_poll_keyboard automatically, so you only need to use this function when accessing the <link id="al_key" /> array and <link id="al_key_shifts" /> variable.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_keyboard_needs_poll" />
	<link id="al_install_keyboard" />
	<link id="al_key" />
	<link id="al_key_shifts" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_poll_keyboard.Result">
<short>Returns zero on success, or a negative number on failure (ie. no keyboard driver installed).</short>
</element>

<!-- function Visibility: default -->
<element name="al_keyboard_needs_poll">
<short>Tells if the keyboard needs polling.</short>
<descr>
	<p>Returns <var>&lt;&gt; 0</var> if the current keyboard driver is operating in polling mode.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_poll_keyboard" />
	<link id="al_install_keyboard" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_keyboard_needs_poll.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_keypressed">
<short>Tells if there are keypresses waiting in the input buffer.</short>
<descr>
	<p>Returns <var>&lt;&gt; 0</var> if there are keypresses waiting in the input buffer. You can use this to see if the next call to <link id="al_readkey" /> is going to block or to simply wait for the user to press a key while you still update the screen possibly drawing some animation. Example:</p>
	<code>WHILE keypressed = 0 DO
BEGIN
  { Show cool animated logo. }
END;
{ So he skipped our title screen. }</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_readkey" />
	<link id="al_ureadkey" />
	<link id="al_clear_keybuf" />
	<link id="al_simulate_keypress" />
	<link id="al_simulate_ukeypress" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_keypressed.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_readkey">
<short>Returns the next character from the keyboard buffer.</short>
<descr>
	<p>Returns the next character from the keyboard buffer, in ASCII format. If the buffer is empty, it waits until a key is pressed. You can see if there are queued keypresses with <link id="al_keypressed" />.</p>
	<p>The low byte of the return value contains the ASCII code of the key, and the high byte the scancode. The scancode remains the same whatever the state of the shift, ctrl and alt keys, while the ASCII code is affected by shift and ctrl in the normal way (shift changes case, ctrl+letter gives the position of that letter in the alphabet, eg. ctrl+A = 1, ctrl+B = 2, etc). Pressing alt+key returns only the scancode, with a zero ASCII code in the low byte. For example:</p>
	<code>VAR
  Val: AL_INT;

    ...
  Val := al_readkey;
  IF CHR (Val AND $ff) = 'd' THEN    { by ASCII code }
    al_message ('You pressed "d"'#13);
    
  IF (Val SHR 8) = AL_KEY_SPACE THEN { by scancode }
    al_message ('You pressed Space'#13);

  IF (val AND $ff) = 3 THEN          { ctrl+letter }
    al_message ('You pressed Control+C'#13);

  IF Val = (AL_KEY_X SHL 8) THEN     { alt+letter }
    al_message ('You pressed Alt+X'#13);</code>
	<p>This function cannot return character values greater than 255. If you need to read Unicode input, use <link id="al_ureadkey" /> instead.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_ureadkey" />
	<link id="al_keypressed" />
	<link id="al_clear_keybuf" />
	<link id="al_simulate_keypress" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_readkey.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_ureadkey">
<short>Returns the next Unicode character from the keyboard buffer.</short>
<descr>
	<p>Returns the next character from the keyboard buffer, in Unicode format. If the buffer is empty, it waits until a key is pressed. You can see if there are queued keypresses with <link id="al_keypressed" />. The return value contains the Unicode value of the key, and if not NIL, the pointer argument will be set to the scancode. Unlike <link id="al_readkey" />, this function is able to return character values greater than 255. Example:</p>
	<code>VAR
  Val, Scancode: AL_INT;
          ...
  Val := al_ureadkey (@al_scancode);
  IF Val = $00F1 THEN
    al_message ('You pressed n with tilde'#13);

  IF Val = $00DF THEN
    al_message ('You pressed sharp s'#13);</code>
	<p>You should be able to find Unicode character maps at http://www.unicode.org/. Remember that on DOS you must specify a custom keyboard map (like those found in <var>keyboard.dat</var>) usually with the help of a configuration file specifying the language mapping (keyboard variable in system section of <var>allegro.cfg</var>), or you will get the default US keyboard mapping.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_readkey" />
	<link id="al_keypressed" />
	<link id="al_clear_keybuf" />
	<link id="al_simulate_ukeypress" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_ureadkey.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_ureadkey.scancode">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_simulate_keypress">
<short>Stuffs a key into the keyboard buffer.</short>
<descr>
	<p>Stuffs a key into the keyboard buffer, just as if the user had pressed it. The parameter is in the same format returned by <link id="al_readkey" />. Example:</p>
	<code>al_simulate_keypress (AL_KEY_SPACE SHL 8);
IF al_readkey = (AL_KEY_SPACE SHL 8) THEN
  al_message ('You simulated Alt+Space'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_simulate_ukeypress" />
	<link id="al_keypressed" />
	<link id="al_readkey" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_simulate_keypress.keycode">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_simulate_ukeypress">
<short>tuffs an Unicode key into the keyboard buffer.</short>
<descr>
	<p>Stuffs a key into the keyboard buffer, just as if the user had pressed it. The parameter is in the same format returned by <link id="al_ureadkey" />. Example:</p>
	<code>{ We ignore the scancode simulation. }
al_simulate_ukeypress ($00DF, 0);
IF al_ureadkey (@Scancode) = $00DF THEN
  al_message ('You simulated sharp s'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_simulate_keypress" />
	<link id="al_keypressed" />
	<link id="al_ureadkey" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_simulate_ukeypress.keycode">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_simulate_ukeypress.scancode">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_clear_keybuf">
<short>Clears the keyboard buffer.</short>
<descr>
	<p>Empties the keyboard buffer. Usually you want to use this in your program before reading keys to avoid previously buffered keys to be returned by calls to <link id="al_readkey" /> or <link id="al_ureadkey" />.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_keypressed" />
	<link id="al_readkey" />
	<link id="al_ureadkey" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_leds">
<short>Sets the state of the keyboard LED indicators.</short>
<descr>
	<p>Overrides the state of the keyboard LED indicators. The parameter is a bitmask containing any of the values <link id="AL_KB_SCROLOCK_FLAG" />, <link id="AL_KB_NUMLOCK_FLAG" />, and <link id="AL_KB_CAPSLOCK_FLAG" />, or -1 to restore the default behavior. Example:</p>
	<code>{ Cycle led indicators. }
al_set_leds (AL_KB_SCROLOCK_FLAG);
al_rest (1000);
al_set_leds (AL_KB_CAPSLOCK_FLAG);
al_rest (1000);
al_set_leds (AL_KB_NUMLOCK_FLAG);
al_rest (1000);
al_set_leds (-1);</code>
	<p>Note that the led behaviour cannot be guaranteed on some platforms, some leds might not react, or none at all. Therefore you shouldn't rely only on them to communicate information to the user, just in case it doesn't get through.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_key_led_flag" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_leds.leds">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_keyboard_rate">
<short>Sets the keyboard repeat rate.</short>
<descr>
	<p>Sets the keyboard repeat rate. Times are given in milliseconds. Passing zero times will disable the key repeat.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_readkey" />
	<link id="al_ureadkey" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_keyboard_rate.key_delay">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_keyboard_rate.key_repeat">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_scancode_to_ascii">
<short>Converts a scancode to an ASCII character.</short>
<descr>
	<p>Converts the given scancode to an ASCII character for that key (mangling Unicode values), returning the unshifted uncapslocked result of pressing the key, or zero if the key isn't a character-generating key or the lookup can't be done. The lookup cannot be done for keys like the F1-F12 keys or the cursor keys, and some drivers will only return approximate values. Generally, if you want to display the name of a key to the user, you should use the <link id="al_scancode_to_name" /> function.</p>
	<p>Example:</p>
	<code>VAR
  Ascii: AL_INT;
          ...
  Ascii := al_scancode_to_ascii (Scancode);
  al_message ('You pressed "'+IntToStr (Ascii)+'"'#13);
	</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_scancode_to_name" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_scancode_to_ascii.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_scancode_to_ascii.scancode">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_scancode_to_name">
<short>Converts a scancode to a key name.</short>
<descr>
	<p>This function returns a string pointer containing the name of they key with the given scancode. This is useful if you e.g. let the user choose a key for some action, and want to display something more meaningful than just the scancode. Example:</p>
	<code>VAR
  KeyName: STRING;
    ...
  KeyName := al_scancode_to_name (Scancode);
  al_message ('You pressed the '+KeyName+' key.'#13);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_scancode_to_ascii" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_scancode_to_name.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_scancode_to_name.scancode">
<short></short>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_KEY_LISTptr">
<short>FOR INTERNAL USE</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="AL_KEY_LIST">
<short>FOR INTERNAL USE</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_key">
<short>Array of flags indicating key state.</short>
<descr>
	<p>Pointer of an array of flags indicating the state of each key, ordered by scancode. Wherever possible these values will be updated asynchronously, but if <link id="al_keyboard_needs_poll" /> returns non zero, you must manually call <link id="al_poll_keyboard" /> to update them with the current input state. The scancodes are defined in <var>alkeybrd.pas</var> as a series of <var>AL_KEY_*</var> constants (and are also listed below). For example, you could write:</p>
	<code>IF al_key^[AL_KEY_SPACE] &lt;&gt; #0 THEN
  al_textout_ex (al_screen, al_font^, 'Space is pressed', 10, 10, al_makecol (0, 255, 128), -1);</code>
	<p>Note that the array is supposed to represent which keys are physically held down and which keys are not, so it is semantically read-only.</p>
	<p>These are the keyboard scancodes:</p>
	<pre>AL_KEY_A .. AL_KEY_Z,
AL_KEY_0 .. AL_KEY_9,
AL_KEY_0_PAD .. AL_KEY_9_PAD,
AL_KEY_F1 .. AL_KEY_F12,

AL_KEY_ESC, AL_KEY_TILDE, AL_KEY_MINUS, AL_KEY_EQUALS,
AL_KEY_BACKSPACE, AL_KEY_TAB, AL_KEY_OPENBRACE, AL_KEY_CLOSEBRACE,
AL_KEY_ENTER, AL_KEY_COLON, AL_KEY_QUOTE, AL_KEY_BACKSLASH,
AL_KEY_BACKSLASH2, AL_KEY_COMMA, AL_KEY_STOP, AL_KEY_SLASH,
AL_KEY_SPACE,

AL_KEY_INSERT, AL_KEY_DEL, AL_KEY_HOME, AL_KEY_END, AL_KEY_PGUP,
AL_KEY_PGDN, AL_KEY_LEFT, AL_KEY_RIGHT, AL_KEY_UP, AL_KEY_DOWN,

AL_KEY_SLASH_PAD, AL_KEY_ASTERISK, AL_KEY_MINUS_PAD,
AL_KEY_PLUS_PAD, AL_KEY_DEL_PAD, AL_KEY_ENTER_PAD,

AL_KEY_PRTSCR, AL_KEY_PAUSE,

AL_KEY_ABNT_C1, AL_KEY_YEN, AL_KEY_KANA, AL_KEY_CONVERT, AL_KEY_NOCONVERT,
AL_KEY_AT, AL_KEY_CIRCUMFLEX, AL_KEY_COLON2, AL_KEY_KANJI,

AL_KEY_LSHIFT, AL_KEY_RSHIFT,
AL_KEY_LCONTROL, AL_KEY_RCONTROL,
AL_KEY_ALT, AL_KEY_ALTGR,
AL_KEY_LWIN, AL_KEY_RWIN, AL_KEY_MENU,
AL_KEY_SCRLOCK, AL_KEY_NUMLOCK, AL_KEY_CAPSLOCK

AL_KEY_EQUALS_PAD, AL_KEY_BACKQUOTE, AL_KEY_SEMICOLON, AL_KEY_COMMAND</pre>
	<p>Finally, you may notice an `odd' behaviour of the AL_KEY_PAUSE key. This key only generates an interrupt when it is pressed, not when it is released. For this reason, Allegro pretends the pause key is a `state' key, which is the only way to make it usable. </p>
</descr>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_poll_keyboard" />
	<link id="al_key_shifts" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_key_shifts">
<short>Bitmask containing the current state of modifier keys.</short>
<descr>
	<p>Bitmask containing the current state of shift/ctrl/alt, the special Windows keys, and the accent escape characters. Wherever possible this value will be updated asynchronously, but ifbut if <link id="al_keyboard_needs_poll" /> returns non zero, you must manually call <link id="al_poll_keyboard" /> to update it with the current input state. This can contain any of the flags:</p>
	<pre>AL_KB_SHIFT_FLAG
AL_KB_CTRL_FLAG
AL_KB_ALT_FLAG
AL_KB_LWIN_FLAG
AL_KB_RWIN_FLAG
AL_KB_MENU_FLAG
AL_KB_COMMAND_FLAG
AL_KB_SCROLOCK_FLAG
AL_KB_NUMLOCK_FLAG
AL_KB_CAPSLOCK_FLAG
AL_KB_INALTSEQ_FLAG
AL_KB_ACCENT1_FLAG
AL_KB_ACCENT2_FLAG
AL_KB_ACCENT3_FLAG
AL_KB_ACCENT4_FLAG</pre>
	<p>Example:</p>
	<code>IF al_key^[AL_KEY_W] &lt;&gt; #0 THEN
BEGIN
  IF (al_key_shifts AND AL_KB_SHIFT_FLAG) &lt;&gt; 0 THEN
  BEGIN
    { User is pressing shift + W. }
  END
  ELSE BEGIN
    { Hmmm... lower case W then. }
  END;
END;</code>
</descr>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_poll_keyboard" />
	<link id="al_key" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_three_finger_flag">
<short>Flag to desactivate the emergency exit key combination.</short>
<descr>
	<p>The DJGPP keyboard handler provides an 'emergency exit' sequence which you can use to kill off your program. If you are running under DOS this is the three finger salute, ctrl+alt+del. Most multitasking OS's will trap this combination before it reaches the Allegro handler, in which case you can use the alternative ctrl+alt+end. If you want to disable this behaviour in release versions of your program, set this flag to zeor.</p>
</descr>
<seealso>
	<link id="al_install_keyboard" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_key_led_flag">
<short>Flag to prevent the keyboard LEDs from being updated.</short>
<descr>
	<p>By default, the capslock, numlock, and scroll-lock keys toggle the keyboard LED indicators when they are pressed. If you are using these keys for input in your game (eg. capslock to fire) this may not be desirable, so you can clear this flag to prevent the LED's being updated.</p>
</descr>
<seealso>
	<link id="al_install_keyboard" />
	<link id="al_set_leds" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_A">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_B">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_C">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_D">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_E">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_G">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_H">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_I">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_J">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_K">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_L">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_M">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_N">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_O">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_P">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_Q">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_R">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_S">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_T">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_U">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_V">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_W">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_X">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_Y">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_Z">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_0">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_3">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_4">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_5">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_6">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_7">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_9">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_0_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_1_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_2_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_3_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_4_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_5_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_6_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_7_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_8_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_9_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F3">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F4">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F5">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F6">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F7">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F9">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F10">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F11">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_F12">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ESC">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_TILDE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_MINUS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_EQUALS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_BACKSPACE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_TAB">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_OPENBRACE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_CLOSEBRACE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ENTER">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_COLON">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_QUOTE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_BACKSLASH">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_BACKSLASH2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_COMMA">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_STOP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_SLASH">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_SPACE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_INSERT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_DEL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_HOME">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_END">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_PGUP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_PGDN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_LEFT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_RIGHT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UP">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_DOWN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_SLASH_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ASTERISK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_MINUS_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_PLUS_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_DEL_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ENTER_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_PRTSCR">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_PAUSE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ABNT_C1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_YEN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_KANA">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_CONVERT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_NOCONVERT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_AT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_CIRCUMFLEX">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_COLON2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_KANJI">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_EQUALS_PAD">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_BACKQUOTE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_SEMICOLON">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_COMMAND">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN1">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN2">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN3">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN4">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN5">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN6">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN7">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_UNKNOWN8">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_MODIFIERS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_LSHIFT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_RSHIFT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_LCONTROL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_RCONTROL">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ALT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_ALTGR">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_LWIN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_RWIN">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_MENU">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_SCRLOCK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_NUMLOCK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_CAPSLOCK">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KEY_MAX">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_SHIFT_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_CTRL_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_ALT_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_LWIN_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_RWIN_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_MENU_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_SCROLOCK_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_NUMLOCK_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_CAPSLOCK_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_INALTSEQ_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_ACCENT1_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_ACCENT2_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_ACCENT3_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_KB_ACCENT4_FLAG">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

</module> <!-- alkeybrd -->


<!--
  ====================================================================
    almidi
  ====================================================================
-->

<module name="almidi">
<short>Music routines (MIDI)</short>
<descr>
	<p>Allegro allows you to play MIDI files. MIDI files basically contain notes and the type of instrument that is meant to play them, so they are usually very small in size. However, it's up to the soundcard of the end user to play the notes, and soundcards have been historically known to have poor MIDI performance (at least those oriented to the consumer market). Few consumer cards feature decent MIDI playback. Still, as a game creator you can never be sure if the music of your game will be played as you meant it, because it totally depends on the hardware of the user.</p>
	<p>For this reason Allegro also provides a <link id="alsound.AL_DIGMID">DIGMID</link> driver. This is a software implementation of the so called Wavetable synthesis. Soundcards featuring this store digital samples of real instruments at different pitches, interpolating those that are not recorded, thus achieving a high sound quality. Implementing this in software makes you sure that the quality you hear on your computer is that which will be heard by end users using the same driver.</p>
	<p>The disadvantage of the DIGMID driver is that it uses more CPU than simple MIDI playback, and it steals some hardware voices from the soundcard, which might be more critical for the end user experience than the background music. At the Allegro homepage (http://alleg.sourceforge.net/) you can find more information about DIGMID and where to download digital samples for your MIDI files.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_MIDI_VOICES">
<short>Maximun number of voices</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MIDI_TRACKS">
<short>Maximun number of tracks</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_MIDIptr">
<short>Pointer to <link id="AL_MIDI" />.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_MIDI">
<short>Stores MIDI data.</short>
<descr>
	<p>A structure holding MIDI data. Read <link id="almidi">Music routines (MIDI) overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_load_midi" /><link id="almidi">Music routines (MIDI) overview</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_MIDI.divisions">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_MIDI.data">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_MIDI.len">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_MIDI.track">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_midi_pos">
<short>Stores the current position in the MIDI file.</short>
<descr>
	<p>Stores the current position (beat number) in the MIDI file, or contains a negative number if no music is currently playing. Useful for synchronising animations with the music, and for checking whether a MIDI file has finished playing.</p>
</descr>
<seealso>
	<link id="al_play_midi" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_midi_time">
<short>Contains the position in the currently playing midi.</short>
<descr>
	<p>Contains the position in seconds in the currently playing midi. This is useful if you want to display the current song position in seconds, not as beat number.</p>
</descr>
<seealso>
	<link id="al_play_midi" /><link id="al_midi_pos" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_load_midi">
<short>Loads a MIDI file.</short>
<descr>
	<p>Loads a MIDI file (handles both format 0 and format 1). Example:</p>
	<code>VAR
  Music: AL_MIDIptr;
...
  Music := al_load_midi ('backmus.mid');
  IF Music = NIL THEN
    AbortOnError ('Couldn''t load background music!');</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="alsound.al_install_sound">al_install_sound</link><link id="al_destroy_midi" /><link id="al_play_midi" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_midi.Result">
	<short>Returns a pointer to a MIDI structure, or <var>NIL</var> on error. Remember to free this MIDI file later to avoid memory leaks.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_load_midi.filename">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_destroy_midi">
<short>Destroys a MIDI structure when you are done with it.</short>
<descr>
	<p>Destroys a MIDI structure when you are done with it. It is safe to call this even when the MIDI file might be playing, because it checks and will kill it off if it is active. Use this to avoid memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_load_midi" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_destroy_midi.midi">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_play_midi">
<short>Starts playing the specified MIDI file.</short>
<descr>
	<p>Starts playing the specified MIDI file, first stopping whatever music was previously playing. If the <var>loop</var> flag is set to non-zero, the data will be repeated until replaced with something else, otherwise it will stop at the end of the file. Passing a <var>NIL</var> pointer will stop whatever music is currently playing.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alsound.al_install_sound">al_install_sound</link><link id="al_load_midi" /><link id="al_stop_midi" /><link id="al_midi_pause" /><link id="al_midi_seek" /><link id="al_midi_resume" /><link id="al_play_looped_midi" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_play_midi.Result">
<short>Returns non-zero if an error occurs (this may happen if a patch-caching wavetable driver is unable to load the required samples, or at least it might in the future when somebody writes some patch-caching wavetable drivers :-)</short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_midi.midi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_midi.loop">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_play_looped_midi">
<short>Starts playing a MIDI file with a user-defined loop position.</short>
<descr>
	<p>Starts playing a MIDI file with a user-defined loop position. When the player reaches the loop end position or the end of the file (<var>loop_end</var> may be -1 to only loop at EOF), it will wind back to the loop start point. Both positions are specified in the same beat number format as the <link id="al_midi_pos" /> variable.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_midi" /><link id="al_midi_pos" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_play_looped_midi.Result">
<short>The return value has the same meaning as that of <link id="al_play_midi" />: non-zero if an error occurs, zero otherwise.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_looped_midi.midi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_looped_midi.loop_start">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_play_looped_midi.loop_end">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_stop_midi">
<short>Stops whatever music is currently playing.</short>
<descr>
	<p>Stops whatever music is currently playing. This is the same thing as calling <link id="al_play_midi" /> <var>(NIL, 0)</var>.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_midi" /><link id="al_midi_pause" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_midi_pause">
<short>Pauses the MIDI player.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_midi" /><link id="al_stop_midi" /><link id="al_midi_resume" /><link id="al_midi_seek" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_midi_resume">
<short>Resumes playback of a paused MIDI file.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_midi_pause" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_midi_seek">
<short>Seeks to the given midi_pos in the current MIDI file.</short>
<descr>
	<p>Seeks to the given <link id="al_midi_pos" /> in the current MIDI file. If the <var>target</var> is earlier in the file than the current <var>al_midi_pos</var> it seeks from the beginning; otherwise it seeks from the current position.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_play_midi" /><link id="al_midi_pos" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_midi_seek.Result">
	<short>Returns zero if it could successfully seek to the requested position. Otherwise, a return value of 1 means it stopped playing, and <var>al_midi_pos</var> is set to the negative length of the MIDI file (so you can use this function to determine the length of a MIDI file). A return value of 2 means the MIDI file looped back to the start.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_midi_seek.target">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_load_midi_patches">
<short>Forces the MIDI driver to load a set of patches.</short>
<descr>
	<p>Forces the MIDI driver to load the entire set of patches ready for use. You will not normally need to call this, because Allegro automatically loads whatever data is required for the current MIDI file<!--, but you must call it before sending any program change messages via the midi_out() command-->.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alsound.al_install_sound">al_install_sound</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_load_midi_patches.Result">
<short>Returns non-zero if an error occurred.</short>
</element>

</module> <!-- almidi -->


<!--
  ====================================================================
    almouse
  ====================================================================
-->

<module name="almouse">
<short>Mouse routines</short>
<descr>
	<p>Allegro provides functions for reading the mouse state and displaying a mouse cursor on-screen. You can read the absolute position of the mouse and the state of the mouse buttons from global variables. Additionally, you can read the mouse position difference as mouse mickeys, which is the number of pixels the cursor moved since the last time this information was read.</p>
	<!-- p>Allegro offers three ways to display the mouse cursor:</p -->
<!--li><b>Standard Allegro cursor:</b --><p>Allegro is responsible for drawing the mouse cursor from a timer. Use <link id="al_set_mouse_sprite" /> and <link id="al_show_mouse" /> to define your own cursor and display it on the screen.<!-- You need to call scare_mouse()/unscare_mouse() to hide the mouse cursor whenever you draw to the screen. --></p>
<!--    * Custom operating system cursor (hardware cursor)
      Allegro will let the operating system draw the mouse cursor. Use set_mouse_sprite() and show_mouse() (or show_os_cursor) to define your own cursor and display it on the screen. Not all graphics drivers are capable of this and some may only be able to display cursors upto a certain size. Allegro will fall back on its own cursor drawing if it cannot let the OS handle this. On some platforms, the hardware cursor is incompatible with get_mouse_mickeys() and it is therefor disabled by default. In such cases you need to call enable_hardware_cursor() to enable it explicitly.
    * Default operating system cursor
      Allegro will not draw its own cursor, but use the operating system default cursor. You can use the select_mouse_cursor() function to select the cursor shape to display. As with custom operating system cursors, you need to call enable_hardware_cursor() before you can use this. Or you can use the low level show_os_cursor() function. 

Not all drivers will support all functionality. See the platform specific information for more details.
-->
</descr>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_NONE">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_ALLEGRO">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_ARROW">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_BUSY">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_QUESTION">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MOUSE_CURSOR_EDIT">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_NUM_MOUSE_CURSORS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_x">
<short>Global variable with the mouse position state.</short>
<descr>
	<p>Global variable containing the current mouse position. Wherever possible this value will be updated asynchronously, but if <link id="al_mouse_needs_poll" /> returns non-zero, you must manually call <link id="al_poll_mouse" /> to update them with the current input state. The <var>al_mouse_x</var> position are integer ranging from zero to the right side of the screen.</p>
</descr>
<seealso>
	<link id="al_install_mouse" /><link id="al_poll_mouse" /><link id="al_mouse_needs_poll" /><link id="al_mouse_y" /><link id="al_mouse_z" /><link id="al_mouse_b" /><link id="al_mouse_pos" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_y">
<short>Global variable with the mouse position state.</short>
<descr>
	<p>Global variable containing the current mouse position. Wherever possible this value will be updated asynchronously, but if <link id="al_mouse_needs_poll" /> returns non-zero, you must manually call <link id="al_poll_mouse" /> to update them with the current input state. The <var>al_mouse_y</var> position are integer ranging from zero to the bottom side of the screen.</p>
</descr>
<seealso>
	<link id="al_install_mouse" /><link id="al_poll_mouse" /><link id="al_mouse_needs_poll" /><link id="al_mouse_x" /><link id="al_mouse_z" /><link id="al_mouse_b" /><link id="al_mouse_pos" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_z">
<short>Global variable with the mouse position state.</short>
<descr>
	<p>Global variable containing the current mouse position. Wherever possible this value will be updated asynchronously, but if <link id="al_mouse_needs_poll" /> returns non-zero, you must manually call <link id="al_poll_mouse" /> to update them with the current input state. The <var>al_mouse_z</var> variable holds the current wheel position, when using an input driver that supports wheel mice.</p>
</descr>
<seealso>
	<link id="al_install_mouse" /><link id="al_poll_mouse" /><link id="al_mouse_needs_poll" /><link id="al_mouse_x" /><link id="al_mouse_y" /><link id="al_mouse_b" /><link id="al_mouse_pos" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_b">
<short>Global variable with the mouse button state.</short>
<descr>
	<p>Global variable containing the current mouse position. Wherever possible this value will be updated asynchronously, but if <link id="al_mouse_needs_poll" /> returns non-zero, you must manually call <link id="al_poll_mouse" /> to update them with the current input state. The <var>al_mouse_b</var> variable is a bitfield indicating the state of each button: bit 0 is the left button, bit 1 the right, and bit 2 the middle button. Additional non standard mouse buttons might be available as higher bits in this variable. Usage example:</p>
	<code>IF (al_mouse_b AND 1) &lt;&gt; 0 THEN
  WriteLn ('Left button is pressed');
IF (al_mouse_b AND 2) &lt;&gt; 0 THEN
  WriteLn ('Right button is pressed');</code>
</descr>
<seealso>
	<link id="al_install_mouse" /><link id="al_poll_mouse" /><link id="al_mouse_needs_poll" /><link id="al_mouse_x" /><link id="al_mouse_y" /><link id="al_mouse_z" /><link id="al_mouse_pos" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_pos">
<short>Global variable with the mouse position state.</short>
<descr>
	<p>Global variable containing the current mouse position. Wherever possible this value will be updated asynchronously, but if <link id="al_mouse_needs_poll" /> returns non-zero, you must manually call <link id="al_poll_mouse" /> to update them with the current input state. The <var>al_mouse_pos</var> variable has the current X coordinate in the upper 16 bits and the Y in the lower 16 bits. This may be useful in tight polling loops where a mouse interrupt could occur between your reading of the two separate variables, since you can copy this value into a local variable with a single instruction and then split it up at your leisure. Example:</p>
	<code>VAR
  pos, x, y: INTEGER;
   ...
  pos := al_mouse_pos;
  x := pos SHR 16;
  y := pos AND $0000ffff;</code>
</descr>
<seealso>
	<link id="al_install_mouse" /><link id="al_poll_mouse" /><link id="al_mouse_needs_poll" /><link id="al_mouse_x" /><link id="al_mouse_y" /><link id="al_mouse_z" /><link id="al_mouse_b" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_sprite">
<short>Global variable with the mouse sprite.</short>
<descr>
	<p>Global variable containing the current mouse sprite. This is read-only, and only to be modified using the <link id="al_set_mouse_sprite" />.</p>
</descr>
<seealso>
	<link id="al_set_mouse_sprite" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_x_focus">
<short>Global variable with the mouse sprite and focus point.</short>
<descr>
	<p>Global variable containing the current mouse focus point. This is read-only, and only to be modified using the <link id="al_set_mouse_sprite_focus" />.</p>
</descr>
<seealso>
	<link id="al_mouse_y_focus" /><link id="al_set_mouse_sprite_focus" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_mouse_y_focus">
<short>Global variable with the mouse sprite and focus point.</short>
<descr>
	<p>Global variable containing the current mouse focus point. This is read-only, and only to be modified using the <link id="al_set_mouse_sprite_focus" />.</p>
</descr>
<seealso>
	<link id="al_mouse_x_focus" /><link id="al_set_mouse_sprite_focus" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_install_mouse">
<short>Installs the Allegro mouse handler.</short>
<descr>
	<p>Installs the Allegro mouse handler. You must do this before using any other mouse functions.</p>
	<p>Note that the number of mouse buttons returned by this function is more an indication than a physical reality. With most devices there is no way of telling how many buttons there are, and any user can override the number of mouse buttons returned by this function with a custom <link id="alconfig">configuration file</link> and the variable <var>num_buttons</var>. Even if this value is overriden by the user, the global mouse variables will still report whatever the hardware is sending. </p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_remove_mouse" /><link id="al_poll_mouse" /><link id="al_show_mouse" /><link id="al_mouse_x" /><link id="al_mouse_y" /><link id="al_mouse_b" /><link id="al_mouse_pos" /><link id="al_get_mouse_mickeys" /><link id="al_position_mouse" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_mouse.Result">
<short>Returns -1 on failure, zero if the mouse handler is already installed (in which case this function does nothing) and the number of buttons on the mouse if the mouse handler has successfully been installed (ie. this is the first time a handler is installed or you have removed the previous one).</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_mouse">
<short>Removes the mouse handler.</short>
<descr>
	<p>Removes the mouse handler. You don't normally need to bother calling this, because <link id="alsystem.al_exit">al_allegro_exit</link> will do it for you.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" /><link id="alsystem.al_exit">al_allegro_exit</link>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_poll_mouse">
<short>Polls the mouse.</short>
<descr>
	<p>Wherever possible, Allegro will read the mouse input asynchronously (ie. from inside an interrupt handler), but on some platforms that may not be possible, in which case you must call this routine at regular intervals to update the mouse state variables. To help you test your mouse polling code even if you are programming on a platform that doesn't require it, after the first time that you call this function Allegro will switch into polling mode, so from that point onwards you will have to call this routine in order to get any mouse input at all, regardless of whether the current driver actually needs to be polled or not.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_mouse_needs_poll" /><link id="al_install_mouse" /><link id="al_mouse_x" /><link id="al_mouse_y" /><link id="al_mouse_b" /><link id="al_mouse_pos" /><link id="al_get_mouse_mickeys" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_poll_mouse.Result">
<short>Returns zero on success, or a negative number on failure (ie. no mouse driver installed).</short>
</element>

<!-- function Visibility: default -->
<element name="al_mouse_needs_poll">
<short>Tells if the mouse driver requires polling.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" />
	<link id="al_poll_mouse" />
	<link id="al_mouse_x" />
	<link id="al_mouse_y" />
	<link id="al_mouse_b" />
	<link id="al_mouse_pos" />
	<link id="al_get_mouse_mickeys" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_mouse_needs_poll.Result">
<short>Returns -1 if the current mouse driver is operating in polling mode.</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_show_mouse">
<short>Tells Allegro to display a mouse pointer on the screen.</short>
<descr>
	<p>Tells Allegro to display a mouse pointer on the screen. This will only work if the timer module has been installed. The mouse pointer will be drawn onto the specified bitmap, which should normally be <link id="algraph.al_screen">al_screen</link> (see later for information about bitmaps). To hide the mouse pointer, call <var>al_show_mouse (NIL)</var>.</p>
	<p><b>Note:</b> you must not be showing a mouse pointer on a bitmap at the time that the bitmap is destroyed with <link id="albitmap.al_destroy_bitmap">al_destroy_bitmap</link>, e.g. call <var>al_show_mouse (NIL);</var> before destroying the bitmap. This does not apply to <var>al_screen</var> since you never destroy it with <var>al_destroy_bitmap</var>.</p>
</descr>
<errors>
	<p>If you draw anything onto the screen while the pointer is visible, a mouse movement interrupt could occur in the middle of your drawing operation. If this happens the mouse buffering and graphics drawing code will get confused and will leave 'mouse droppings' all over the screen. To prevent this, you must make sure you turn off the mouse pointer whenever you draw onto the screen. This is not needed if you are using a hardware cursor.</p>
</errors>
<seealso>
	<link id="al_install_mouse" /><link id="altimer.al_install_timer">al_install_timer</link><link id="al_set_mouse_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_show_mouse.bmp">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_mouse_sprite">
<short>Sets the mouse sprite.</short>
<descr>
	<p>You don't like Allegro's mouse pointer? No problem. Use this function to supply an alternative of your own. If you change the pointer and then want to get Allegro's lovely arrow back again, call <var>al_set_mouse_sprite (NIL)</var>.</p>
	<p>As a bonus, <var>al_set_mouse_sprite (NIL)</var> uses the current palette in choosing colors for the arrow. So if your arrow mouse sprite looks ugly after changing the palette, call <var>al_set_mouse_sprite (NIL)</var>.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" />
	<link id="al_show_mouse" />
	<link id="al_set_mouse_sprite_focus" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_mouse_sprite.sprite">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_mouse_sprite_focus">
<short>Sets the mouse sprite focus.</short>
<descr>
	<p>The mouse focus is the bit of the pointer that represents the actual mouse position, ie. the (<link id="al_mouse_x" />, <link id="al_mouse_y" />) position. By default this is the top left corner of the arrow, but if you are using a different mouse pointer you might need to alter it.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_mouse_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_mouse_sprite_focus.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_mouse_sprite_focus.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_position_mouse">
<short>Moves the mouse to the specified screen position.</short>
<descr>
	<p>Moves the mouse to the specified screen position. It is safe to call even when a mouse pointer is being displayed.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" />
	<link id="al_position_mouse_z" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_position_mouse.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_position_mouse.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_position_mouse_z">
<short>Sets the mouse wheel position global variable.</short>
<descr>
	<p>Sets the mouse wheel position variable to the specified value.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" />
	<link id="al_position_mouse" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_position_mouse_z.z">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_mouse_mickeys">
<short>How far the mouse has moved since the last call to this function.</short>
<descr>
	<p>Measures how far the mouse has moved since the last call to this function. The values of <var>mickeyx</var> and <var>mickeyy</var> will become negative if the mouse is moved left or up, respectively. The mouse will continue to generate movement mickeys even when it reaches the edge of the screen, so this form of input can be useful for games that require an infinite range of mouse movement.</p>
	<p>Note that the infinite movement may not work in windowed mode, since under some platforms the mouse would leave the window, and may not work at all if the hardware cursor is in use. </p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_mouse" />
	<link id="al_poll_mouse" />
	<link id="al_mouse_x" />
	<link id="al_mouse_y" />
	<link id="al_mouse_b" />
	<link id="al_mouse_pos" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_mouse_mickeys.mickeyx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_mouse_mickeys.mickeyy">
<short></short>
</element>

</module> <!-- almouse -->


<!--
  ====================================================================
    alpalete
  ====================================================================
-->

<module name="alpalete">
<short>Palette routines</short>
<descr>
 <p>All the Allegro.pas drawing functions use <link id="albase.AL_INT">AL_INT</link> parameters to represent colors. In truecolor resolutions these numbers encode the color directly as a collection of red, green, and blue bits, but in a regular 256-color mode the values are treated as indexes into the current palette, which is a table listing the red, green and blue intensities for each of the 256 possible colors.</p>
 <p>Palette entries are stored in an <link id="alcolor.AL_RGB">AL_RGB</link> structure, which contains red, green and blue intensities in the VGA hardware format, ranging from 0 to 63.</p>
 <p>The type <link id="AL_PALETTE" /> is defined to be an array of <link id="AL_PAL_SIZE" /> AL_RGB structures, where AL_PAL_SIZE is a constant equal to 256.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_PAL_SIZE">
<short>Constant equal to 256.</short>
<seealso>
	<link id="AL_PALETTE" /><link id="al256tra.AL_COLOR_MAP">AL_COLOR_MAP</link>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_PALETTEptr">
<short>Pointer to <link id="AL_PALETTE">color palette</link>.</short>
<seealso>
	<link id="alcolor.AL_RGB">AL_RGB</link><link id="AL_PALETTE" /><link id="al256tra.AL_COLOR_MAP">AL_COLOR_MAP</link>
</seealso>
</element>

<!-- array type Visibility: default -->
<element name="AL_PALETTE">
<short>Palette array.</short>
<descr>
	<p>Allegro palettes are arrays of <link id="AL_PAL_SIZE" /><link id="alcolor.AL_RGB">AL_RGB</link> entries.</p>
</descr>
<seealso>
	<link id="alcolor.AL_RGB">AL_RGB</link><link id="AL_PALETTE" /><link id="al256tra.AL_COLOR_MAP">AL_COLOR_MAP</link>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="AL_RGB_MAPptr">
<short>Pointer to <link id="AL_RGB_MAP" />.</short>
</element>

<!-- record type Visibility: default -->
<element name="AL_RGB_MAP">
<short>RGB map.</short>
<descr>
	<p>Read <link id="alpalete">color palette routines overview</link> for a description on how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="alpalete">color palette routines overview</link><link id="al_create_rgb_table" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_RGB_MAP.data">
<short>INTERNAL USE</short>
</element>

<!-- variable Visibility: default -->
<element name="al_black_palette">
<short>A palette containing solid black colors.</short>
<descr>
	<p>A palette containing solid black colors, used by the fade routines.</p>
</descr>
<seealso>
	<link id="al_default_palette" />
	<link id="al_desktop_palette" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_desktop_palette">
<short>The palette used by the Atari ST low resolution desktop.</short>
<descr>
	<p>The palette used by the Atari ST low resolution desktop. I'm not quite sure why this is still here, except that the grabber and test programs use it. It is probably the only Atari legacy code left in Allegro, and it would be a shame to remove it :-)</p>
	<p>The contents of this palette are 16 colors repeated 16 times. Color entry zero is equal to color entry 16, which is equal to color entry 24, etc.</p>
	<table>
		<tr><td><b>Index</b></td><td><b>Color</b></td><td><b>RGB values</b></td></tr>
		<tr><td>0</td><td>White</td><td>63 63 63</td></tr>
		<tr><td>1</td><td>Red</td><td>63  0  0</td></tr>
		<tr><td>2</td><td>Green</td><td> 0 63  0</td></tr>
		<tr><td>3</td><td>Yellow</td><td>63 63  0</td></tr>
		<tr><td>4</td><td>Blue</td><td> 0  0 63</td></tr>
		<tr><td>5</td><td>Pink</td><td>63  0 63</td></tr>
		<tr><td>6</td><td>Cyan</td><td> 0 63 63</td></tr>
		<tr><td>7</td><td>Grey</td><td>16 16 16</td></tr>
		<tr><td>8</td><td>Light grey</td><td>31 31 31</td></tr>
		<tr><td>9</td><td>Light red</td><td>63 31 31</td></tr>
		<tr><td>10</td><td>Light green</td><td>31 63 31</td></tr>
		<tr><td>11</td><td>Light yellow</td><td>63 63 31</td></tr>
		<tr><td>12</td><td>Light blue</td><td>31 31 63</td></tr>
		<tr><td>13</td><td>Light pink</td><td>63 31 63</td></tr>
		<tr><td>14</td><td>Light cyan</td><td>31 63 63</td></tr>
		<tr><td>15</td><td>Black</td><td> 0  0  0</td></tr>
	</table>
</descr>
<seealso>
	<link id="al_default_palette" />
	<link id="al_black_palette" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_default_palette">
<short>The default IBM BIOS palette.</short>
<descr>
	<p>The default IBM BIOS palette. This will be automatically selected whenever you set a new graphics mode. The palette contains 16 basic colors plus many gradients between them. If you want to see the values, you can write a small Allegro program which saves a screenshot with this palette, or open the grabber tool provided with Allegro and create a new palette object, which will use this palette by default.</p>
</descr>
<seealso>
	<link id="al_desktop_palette" />
	<link id="al_black_palette" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_color">
	<short>Sets the specified palette entry to the specified <link id="alcolor.AL_RGB">AL_RGB</link> triplet.</short>
<descr>
	<p>Sets the specified palette entry to the specified <link id="alcolor.AL_RGB">AL_RGB</link> triplet. Unlike the other palette functions this doesn't do any retrace synchronisation, so you should call <link id="algraph.al_vsync">al_vsync</link> before it to prevent snow problems. Example:</p>
	<code>VAR
  rgb: AL_RGB;
          ...
  al_vsync;
  al_set_color (192, @rgb);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_palette" />
	<link id="al_get_color" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color.idx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color.p">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_palette">
<short>Sets the entire palette of 256 colors.</short>
<descr>
	<p>Sets the entire palette of 256 colors. You should provide an array of 256 RGB structures. Unlike <link id="al_set_color" />, there is no need to call <link id="algraph.al_vsync">al_vsync</link> before this function. Example:</p>
	<code>VAR
  Bmp: AL_BITMAPptr;
  Palette: AL_PALETTE;
          ...
  Bmp := al_load_bitmap (Filename, @Palette);
  IF Bmp = NIL THEN
    AbortOnError ('Couldn''t load bitmap!');
  al_set_palette (palette);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>
	<link id="al_set_palette_range" />
	<link id="al_set_color" />
	<link id="al_get_palette" />
	<link id="al_select_palette" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_palette.p">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_palette_range">
<short>Sets a specific range of the palette.</short>
<descr>
	<p>Sets the palette entries between from and to (inclusive: pass 0 and 255 to set the entire palette). If <var>retrace</var> is non-zero it waits for the vertical retrace, otherwise it sets the colors immediately. Example:</p>
	<code>VAR
  Palette: AL_PALETTE;
          ...
{ Modify the first 16 entries. }
  ChangeFirst16Colors (Palette);
{ Now update them waiting for vsync. }
  al_set_palette_range (Palette, 0, 15, 1);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_palette" />
	<link id="al_get_palette" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_palette_range.p">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_palette_range.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_palette_range.ato">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_palette_range.retrace">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_color">
<short>Retrieves the specified palette entry.</short>
<descr>
	<p>Retrieves the specified palette entry. Example:</p>
	<code>VAR
  Color: AL_RGB;
          ...
  al_get_color (11, @color);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_palette" />
	<link id="al_set_color" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_color.idx">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_color.p">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_palette">
<short>Retrieves the entire palette of 256 colors.</short>
<descr>
	<p>Retrieves the entire palette of 256 colors. You should provide a pointer to an <link id="AL_PALETTE" /> to store it in. Example:</p>
	<code>VAR
  Pal: AL_PALETTE;
          ...
  al_get_palette (@Pal);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_palette_range" />
	<link id="al_get_color" />
	<link id="al_set_palette" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_palette.p">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_palette_range">
<short>Retrieves a specific palette range.</short>
<descr>
	<p>Retrieves the palette entries between from and to (inclusive: pass 0 and 255 to get the entire palette).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_palette" />
	<link id="al_set_palette_range" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_palette_range.p">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_palette_range.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_palette_range.ato">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_palette_range.retrace">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_interpolate">
<short>Calculates a new palette interpolated between two others. </short>
<descr>
	<p>Calculates a temporary palette part way between source and dest, returning it in the output parameter. The position between the two extremes is specified by the pos value: 0 returns an exact copy of source, 64 returns dest, 32 returns a palette half way between the two, etc. This routine only affects colors between from and to (inclusive: pass 0 and 255 to interpolate the entire palette).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_in" />
	<link id="al_fade_out" />
	<link id="al_fade_from" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.spource">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.aoutput">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.apos">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_interpolate.ato">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_from_range">
<short>Gradually fades a part of the palette between two others.</short>
<descr>
	<p>Gradually fades a part of the palette from the source palette to the dest palette. The speed is from 1 (the slowest) up to 64 (instantaneous). This routine only affects colors between from and to (inclusive: pass 0 and 255 to fade the entire palette).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_from" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from_range.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from_range.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from_range.speed">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from_range.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from_range.ato">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_in_range">
<short>Gradually fades a part of the palette from black.</short>
<descr>
	<p>Gradually fades a part of the palette from a black screen to the specified palette. The speed is from 1 (the slowest) up to 64 (instantaneous). This routine only affects colors between from and to (inclusive: pass 0 and 255 to fade the entire palette).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_in" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in_range.p">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in_range.speed">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in_range.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in_range.ato">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_out_range">
<short>Gradually fades a part of the palette to black.</short>
<descr>
	<p>Gradually fades a part of the palette from the current palette to a black screen. The speed is from 1 (the slowest) up to 64 (instantaneous). This routine only affects colors between from and to (inclusive: pass 0 and 255 to fade the entire palette).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_out" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_out_range.speed">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_out_range.from">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_out_range.ato">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_from">
<short>Gradually fades the palette between two others.</short>
<descr>
	<p>Fades gradually from the source palette to the dest palette. The speed is from 1 (the slowest) up to 64 (instantaneous).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_in" />
	<link id="al_fade_out" />
	<link id="al_fade_interpolate" />
	<link id="al_fade_from_range" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from.source">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from.dest">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_from.speed">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_in">
<short>Gradually fades the palette from black.</short>
<descr>
	<p>Fades gradually from a black screen to the specified palette. The speed is from 1 (the slowest) up to 64 (instantaneous).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_out" />
	<link id="al_fade_from" />
	<link id="al_fade_interpolate" />
	<link id="al_fade_in_range" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in.p">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_in.speed">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_fade_out">
<short>Gradually fades the palette to black.</short>
<descr>
	<p>Fades gradually from the current palette to a black screen. The speed is from 1 (the slowest) up to 64 (instantaneous).</p>
	<p>Note that this function will block your game while the fade is in effect, and it won't work right visually if you are not in an 8 bit color depth resolution.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_fade_in" />
	<link id="al_fade_from" />
	<link id="al_fade_interpolate" />
	<link id="al_fade_in_range" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_fade_out.speed">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_select_palette">
<short>Sets the internal palette for color conversion.</short>
<descr>
	<p>Ugly hack for use in various dodgy situations where you need to convert between paletted and truecolor image formats. Sets the internal palette table in the same way as the <link id="al_set_palette" /> function, so the conversion will use the specified palette, but without affecting the display hardware in any way. The previous palette settings are stored in an internal buffer, and can be restored by calling <link id="al_unselect_palette" />. If you call <var>al_select_palette</var> again, however, the internal buffer will be overwritten.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_palette" />
	<link id="al_unselect_palette" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_select_palette.p">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_unselect_palette">
<short>Restores the palette tables that were in use before the last call to <link id="al_select_palette" />.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_select_palette" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_generate_332_palette">
<short>Constructs a fake truecolor palette.</short>
<descr>
	<p>Constructs a fake truecolor palette, using three bits for red and green and two for the blue. The <link id="albitmap.al_load_bitmap">al_load_bitmap</link> function fills the palette parameter with this if the file does not contain a palette itself (ie. you are reading a truecolor bitmap).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="albitmap.al_generate_optimized_palette">al_generate_optimized_palette</link>
	<link id="algraph.al_set_color_depth">al_set_color_depth</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_generate_332_palette.p">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_bestfit_color">
<short>Finds a palette color fitting the requested RGB values.</short>
<descr>
	<p>Searches the specified palette for the closest match to the requested color, which are specified in the VGA hardware 0-63 format. Normally you should call <link id="alcolor.al_makecol8">al_makecol8</link> instead, but this lower level function may be useful if you need to use a palette other than the currently selected one, or specifically don't want to use the <link id="al_set_rgb_map">rgb-map</link> lookup table.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="alcolor.al_makecol8">al_makecol8</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_bestfit_color.Result">
<short>Returns the index of the palette for the closest match to the requested color.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_bestfit_color.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_bestfit_color.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_bestfit_color.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_bestfit_color.b">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_rgb_map">
<short>Sets a look up table to speed up reducing RGB values to palette colors.</short>
<descr>
	<p>To speed up reducing RGB values to 8-bit paletted colors, Allegro uses a 32k lookup table (5 bits for each color component). You must set up this table before using the gouraud shading routines, and if present the table will also vastly accelerate the <link id="alcolor.al_makecol8">al_makecol8</link> and some <var>create_*_table</var> functions. RGB tables can be<!-- precalculated with the rgbmap utility, or--> generated at runtime with <link id="al_create_rgb_table" />.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_create_rgb_table" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_rgb_map.map">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_create_rgb_table">
<short>Generates an RGB mapping table with lookup data for a palette.</short>
<descr>
	<p>Fills the specified RGB mapping table with lookup data for the specified palette. If the callback function is not <var>NIL</var>, it will be called 256 times during the calculation, allowing you to display a progress indicator. Example:</p>
	<code>VAR
  rgbTable: AL_RGB_MAP;
          ...
  al_create_rgb_table (@rgbTable, palette, NIL);
  al_set_rgb_map (@rgb_table);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_rgb_map" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_create_rgb_table.table">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_rgb_table.pal">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_create_rgb_table.callback">
<short></short>
</element>

</module> <!-- alpalete -->


<!--
  ====================================================================
    alsound
  ====================================================================
-->

<module name="alsound">
<short>Sound init routines </short>
<descr>
	<p>Allegro allows you to use the sound hardware in two ways: automatic, or manual. Usually you should try the automatic version first. This means calling <link id="al_install_sound" /> with the autodetection parameters and using the rest of the sound functions to play samples or music. In this situation, Allegro will handle the sound devices and mix the samples and/or music the best way it can.</p>
	<p>However, sound hardware has a limitation on the number of samples it may play all at the same time (from now on, called hardware voices). When you exceed this limit, Allegro will cut off one of the samples being played and reproduce the new one. Depending on the type of sounds you are playing, how many of them you need at the same time and their nature (e.g: vital audio feedback to the user or useless "ping" when some shrapnel hits a rock in the scenary) you will want to specify more carefully how hardware voices are reserved and which samples have priority over others.</p>
	<p>The hardware voice reservation phase has to be done before the call to <var>al_install_sound</var>, since it directly affects how Allegro talks to the sound drivers.</p>
</descr>

<!-- constant Visibility: default -->
<element name="AL_DIGI_AUTODETECT">
<short>Let Allegro pick a digital sound driver</short>
<descr>
</descr>
<seealso>
	<link id="al_install_sound" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_DIGI_NONE">
<short>No digital sound</short>
<descr>
</descr>
<seealso>
	<link id="al_install_sound" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MIDI_AUTODETECT">
<short>Let Allegro pick a MIDI sound driver</short>
<descr>
</descr>
<seealso>
	<link id="al_install_sound" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MIDI_NONE">
<short>No MIDI sound</short>
<descr>
</descr>
<seealso>
	<link id="al_install_sound" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_MIDI_DIGMID">
<short>sample-based software wavetable player</short>
<descr>
</descr>
<seealso>
	<link id="al_install_sound" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_reserve_voices">
<short>Reserve a number of voices for the digital and MIDI drivers.</short>
<descr>
	<p>Call this function to specify the number of voices that are to be used by the digital and MIDI sound drivers respectively. This must be done <b>before</b> calling <link id="al_install_sound" />. If you reserve too many voices, subsequent calls to <var>al_install_sound</var> will fail. How many voices are available depends on the driver, and in some cases you will actually get more than you reserve (eg. the FM synth drivers will always provide 9 voices on an OPL2 and 18 on an OPL3, and the SB digital driver will round the number of voices up to the nearest power of two). Pass negative values to restore the default settings. You should be aware that the sound quality is usually inversely related to how many voices you use, so don't reserve any more than you really need.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_volume_per_voice" />
	<link id="al_install_sound" />
	<link id="al_get_mixer_voices" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_reserve_voices.digi_voices">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_reserve_voices.midi_voidces">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_volume_per_voice">
<short>Sets the volume of a voice.</short>
<descr>
	<p>By default, Allegro will play a centered sample at half volume on both the left and right channel. A sample panned to the far right or left will be played at maximum volume on that channel only. This is done so you can play a single panned sample without distortion. If you play multiple samples at full volume, the mixing process can result in clipping, a noticeable form of distortion. The more samples, the more likely clipping is to occur, and the more clipping, the worse the output will sound.</p>
	<p>If clipping is a problem - or if the output is too quiet - this function can be used to adjust the volume of each voice. You should first check that your speakers are at a reasonable volume, Allegro's global volume is at maximum (see <link id="al_set_volume" />), and any other mixers such as the Windows Volume Control are set reasonably. Once you are sure that Allegro's output level is unsuitable for your application, use this function to adjust it.</p>
	<p>Each time you increase the parameter by one, the volume of each voice will halve. For example, if you pass 4, you can play up to 16 centred samples at maximum volume without distortion.</p>
	<p>If you pass 0 to this function, each centred sample will play at the maximum volume possible without distortion, as will all samples played through a mono driver. Samples at the extreme left and right will distort if played at full volume. If you wish to play panned samples at full volume without distortion, you should pass 1 to this function. <i><b>Note:</b> this is different from the function's behaviour in WIPs 3.9.34, 3.9.35 and 3.9.36. If you used this function under one of these WIPs, you will have to increase your parameter by one to get the same volume.</i></p>
	<p><b>Note:</b> The default behaviour has changed as of Allegro 4.1.15. If you would like the behaviour of earlier versions of Allegro, pass -1 to this function. Allegro will choose a value dependent on the number of voices, so that if you reserve n voices, you can play up to n/2 normalised samples with centre panning without risking distortion. The exception is when you have fewer than 8 voices, where the volume remains the same as for 8 voices. Here are the values, dependent on the number of voices:</p>
	<pre>1-8 voices - set_volume_per_voice(2)
 16 voices - set_volume_per_voice(3)
 32 voices - set_volume_per_voice(4)
 64 voices - set_volume_per_voice(5)</pre>
	<p>Of course this function does not override the volume you specify with <link id="aldigi.al_play_sample">al_play_sample</link><!-- or <link id="al_voice_set_volume" />-->. It simply alters the overall output of the program. If you play samples at lower volumes, or if they are not normalised, then you can play more of them without distortion.</p>
	<p>It is recommended that you hard-code the parameter into your program, rather than offering it to the user. The user can alter the volume with the configuration file instead, or you can provide for this with <var>al_set_volume</var>.</p>
	<p>To restore volume per voice to its default behaviour, pass 1.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_reserve_voices" />
	<link id="al_set_volume" />
	<link id="al_install_sound" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_volume_per_voice.scale">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_install_sound">
<short>Initialises the sound module.</short>
<descr>
	<p>Initialises the sound module. You should normally pass <link id="AL_DIGI_AUTODETECT" /> and <link id="AL_MIDI_AUTODETECT" /> as the driver parameters to this function, in which case Allegro will read hardware settings from the current configuration file. This allows the user to select different values with the setup utility: see the config section for details. Alternatively, see the platform specific documentation for a list of the available drivers. The <var>cfg_path</var> parameter is only present for compatibility with previous versions of Allegro, and has no effect on anything.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_remove_sound" />
	<link id="al_reserve_voices" />
	<link id="al_set_volume" />
	<link id="aldigi.al_play_sample">al_play_sample</link>
	<link id="almidi.al_play_midi">al_play_midi</link>
	<link id="al_install_sound_input" />
	<link id="alsystem.al_error">al_error</link>
	<link id="al_set_mixer_quality" />
	<link id="AL_DIGI_AUTODETECT" />
	<link id="AL_DIGI_NONE" />
	<link id="AL_MIDI_AUTODETECT" />
	<link id="AL_MIDI_DIGMID" />
	<link id="AL_MIDI_NONE" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_sound.Result">
	<short>Returns zero if the sound is successfully installed, and -1 on failure. If it fails it will store a description of the problem in <link id="alsystem.al_error">al_error</link>.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_sound.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_sound.midi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_sound.c">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_sound">
<short>Cleans up after you are finished with the sound routines.</short>
<descr>
	<p>Cleans up after you are finished with the sound routines. You don't normally need to call this, because <link id="alsystem.al_allegro_exit">al_allegro_exit</link> will do it for you.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_sound" />
	<link id="alsystem.al_allegro_exit">al_allegro_exit</link>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_install_sound_input">
<short>UNIMPLEMENTED<!--Initialises the sound recorder module.--></short>
<descr>
	<!--p>Initialises the sound recorder module. You must install the normal sound playback system before calling this routine. The two card parameters should use the same constants as <link id="al_install_sound" />, including <link id="AL_DIGI_NONE" /> and <link id="AL_MIDI_NONE" /> to disable parts of the module, or <link id="AL_DIGI_AUTODETECT" /> and <link id="AL_MIDI_AUTODETECT" /> to guess the hardware.</p-->
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_sound_input.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_sound_input.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_sound_input.midi">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_sound_input">
<short>UNIMPLEMENTED</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_volume">
<short>Alters the global sound output volume.</short>
<descr>
	<p>Alters the global sound output volume. Specify volumes for both digital samples and MIDI playback, as integers from 0 to 255, or pass a negative value to leave one of the settings unchanged. Values bigger than 255 will be reduced to 255. This routine will not alter the volume of the hardware mixer if it exists (i.e. only your application will be affected).</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_sound" />
	<link id="al_set_hardware_volume" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_volume.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_volume.midi">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_hardware_volume">
<short>Alters the hardware sound output volume.</short>
<descr>
	<p>Alters the hardware sound output volume. Specify volumes for both digital samples and MIDI playback, as integers from 0 to 255, or pass a negative value to leave one of the settings unchanged. Values bigger than 255 will be reduced to 255. This routine will use the hardware mixer to control the volume if it exists (i.e. the volume of all the applications on your machine will be affected), otherwise do nothing.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_install_sound" />
	<link id="al_set_volume" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hardware_volume.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hardware_volume.midi">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_volume">
<short>Retrieves the global sound output volume.</short>
<descr>
	<p>Retrieves the global sound output volume, both for digital samples and MIDI playback, as integers from 0 to 255. Parameters <var>digi_volume</var> and <var>midi_volume</var> must be valid pointers to int, or NULL if not interested in specific value.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_volume" />
	<link id="al_get_hardware_volume" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_volume.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_volume.midi">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_get_hardware_volume">
<short>Retrieves the hardware sound output volume.</short>
<descr>
	<p>Retrieves the hardware sound output volume, both for digital samples and MIDI playback, as integers from 0 to 255, or -1 if the information is not available. Parameters <var>digi_volume</var> and <var>midi_volume</var> must be valid pointers to int, or <var>NIL</var> if not interested in specific value.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_volume" />
	<link id="al_get_volume" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_get_hardware_volume.digi">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_hardware_volume.midi">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_mixer_quality">
<short>Sets the resampling quality of the mixer.</short>
<descr>
	<p>Sets the resampling quality of the mixer. Valid values are the same as the <var>quality</var> config variable. Please read chapter <link id="standard_config_variables">Standard config variables</link> for details. You can call this function at any point in your program, even before <link id="alsystem.al_init">al_init</link>.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_mixer_quality" />
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_mixer_quality.quality">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_quality">
<short>Returns the current mixing quality.</short>
<descr>
	<p>Returns the current mixing quality, as specified by the <var>quality</var> config variable, or a previous call to <link id="al_set_mixer_quality" />.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_mixer_quality" />
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_quality.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_frequency">
<short>Returns the mixer frequency, in Hz.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_frequency.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_bits">
<short>Returns the mixer bitdepth (8 or 16).</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_bits.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_channels">
<short>Returns the number of output channels.</short>
<descr>
	<p>Returns the number of output channels. 2 for stereo, 1 for mono, 0 if the mixer isn't active.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_channels.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_voices">
<short>Returns the number of voices allocated to the mixer.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_voices.Result">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_get_mixer_buffer_length">
<short>Returns the number of samples per channel in the mixer buffer.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
	<link id="standard_config_variables">Standard config variables</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_mixer_buffer_length.Result">
<short></short>
</element>

</module> <!-- alsound -->


<!--
  ====================================================================
    alsprrle
  ====================================================================
-->

<module name="alsprrle">
<short>RLE sprites</short>
<descr>
	<p>Because bitmaps can be used in so many different ways, the bitmap structure is quite complicated, and it contains a lot of data. In many situations, though, you will find yourself storing images that are only ever copied to the screen, rather than being drawn onto or used as filling patterns, etc. If this is the case you may be better off storing your images in <link id="AL_RLE_SPRITE" /><!-- or COMPILED_SPRITE (see next chapter)--> structure rather than regular bitmaps.</p>
	<p>RLE sprites store the image in a simple run-length encoded format, where repeated zero pixels are replaced by a single length count, and strings of non-zero pixels are preceded by a counter giving the length of the solid run. RLE sprites are usually much smaller than normal bitmaps, both because of the run length compression, and because they avoid most of the overhead of the bitmap structure. They are often also faster than normal bitmaps, because rather than having to compare every single pixel with zero to determine whether it should be drawn, it is possible to skip over a whole run of zeros with a single add, or to copy a long run of non-zero pixels with fast string instructions.</p>
	<p>Every silver lining has a cloud, though, and in the case of RLE sprites it is a lack of flexibility. You can't draw onto them, and you can't flip them, rotate them, or stretch them. In fact the only thing you can do with them is to blast them onto a bitmap with the <link id="al_draw_rle_sprite" /> procedure, which is equivalent to using <link id="albltspr.al_draw_sprite">al_draw_sprite</link> with a regular bitmap. You can convert bitmaps into RLE sprites at runtime, or you can create RLE sprite structures in grabber datafiles by making a new object of type 'RLE sprite'.</p>
</descr>

<!-- pointer type Visibility: default -->
<element name="AL_RLE_SPRITEptr">
<short>Pointer to <link id ="AL_RLE_SPRITE" /></short>
</element>

<!-- record type Visibility: default -->
<element name="AL_RLE_SPRITE">
<short>Stores the contents of an RLE sprite.</short>
<descr>
	<p>RLE sprites store the image in a simple run-length encoded format, where repeated zero pixels are replaced by a single length count, and strings of non-zero pixels are preceded by a counter giving the length of the solid run. Read <link id="alsprrle">RLE sprites overview</link> for a description of the restrictions and how to obtain/use this structure.</p>
</descr>
<seealso>
	<link id="al_get_rle_sprite" /><link id="albitmap.AL_BITMAP">AL_BITMAP</link><link id="alsprrle">RLE sprites</link>
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="AL_RLE_SPRITE.w">
<short>Width of the sprite.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RLE_SPRITE.h">
<short>Height of the sprite.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RLE_SPRITE.color_depth">
<short>Color depth of the image.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RLE_SPRITE.size">
<short>FOR INTERNAL USE.</short>
</element>

<!-- variable Visibility: default -->
<element name="AL_RLE_SPRITE.dat">
<short>FOR INTERNAL USE</short>
</element>

<!-- function Visibility: default -->
<element name="al_get_rle_sprite">
<short>Creates an RLE sprite using a bitmap as source.</short>
<descr>
	<p>Creates an RLE sprite based on the specified bitmap (which must be a memory bitmap). Remember to free this RLE sprite later to avoid memory leaks. Example:</p>
	<code>VAR
  rle: AL_RLE_SPRITEptr;
  bmp: AL_BITMAPptr;
          ...
{ Create RLE sprite from an existent bitmap. }
  rle := al_get_rle_sprite (bmp);
  IF rle = NIL THEN
    AbortOnError ('Couldn''t create RLE sprite!');
{ We don't need the bitmap any more. }
  al_destroy_bitmap(bmp);
{ Use the RLE sprite. }
          ...
{ Destroy it when we don't need it any more. }
  al_destroy_rle_sprite (rle);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_draw_rle_sprite" />
	<link id="al_destroy_rle_sprite" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_rle_sprite.Result">
<short>Returns a pointer to the created RLE sprite, or <var>NIL</var> if the RLE sprite could not be created. Remember to free this RLE sprite later to avoid memory leaks.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_rle_sprite.bitmap">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_destroy_rle_sprite">
<short>Destroys an RLE sprite.</short>
<descr>
	<p>Destroys an RLE sprite structure previously returned by <link id="al_get_rle_sprite" />. If you pass a <var>NIL</var> pointer this function won't do anything. Use this once you are done with an RLE sprite to avoid memory leaks in your program.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_rle_sprite" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_destroy_rle_sprite.sprite">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_rle_sprite">
<short>Draws an RLE sprite.</short>
<descr>
	<p>Draws an RLE sprite onto a bitmap at the specified position. Example:</p>
	<code>VAR
  rle_sprite: AL_RLE_SPRITEptr;
          ...
  al_draw_rle_sprite (al_screen, rle_sprite, 100, 100);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_get_rle_sprite" />
	<link id="albltspr.al_draw_sprite">al_draw_sprite</link>
	<link id="al_draw_trans_rle_sprite" />
	<link id="al_draw_lit_rle_sprite" />
	<link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_rle_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_rle_sprite.spr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_rle_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_rle_sprite.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_trans_rle_sprite">
<short>Draws a translucent RLE sprite.</short>
<descr>
	<p>Translucent version of <var>al_draw_rle_sprite</var>. See the description of <link id="al_draw_rle_sprite" />. This must only be used after you have set up the color mapping table (for 256-color modes) or blender functions (for truecolor modes). The bitmap and sprite must normally be in the same color depth, but as a special case you can draw 32-bit RGBA format sprites onto any hicolor or truecolor bitmap, as long as you call <link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link> first. Example:</p>
	<code>VAR
  GlobalTransTable: AL_COLOR_MAP;
	...
{ Some one time initialisation code. }
  al_create_trans_table (@GlobalTransTable, MyPalette,
			 128, 128, 128, NIL);
	...
  IF al_get_color_depth = 8 THEN
    al_set_color_map (@GlobalTransTable)
  ELSE
    al_set_trans_blender(128, 128, 128, 128);
  al_draw_trans_rle_sprite (Buffer, RLE_GhostSprite, x, y);</code>	
</descr>
<errors>
</errors>
<seealso>
	<link id="al_draw_rle_sprite" />
	<link id="al_draw_lit_rle_sprite" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="al256tra.al_set_color_map">al_set_color_map</link>
	<link id="altrutra.al_set_alpha_blender">al_set_alpha_blender</link>
	<link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_rle_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_rle_sprite.spr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_rle_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_trans_rle_sprite.y">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_draw_lit_rle_sprite">
<short>Draws a tinted RLE sprite.</short>
<descr>
	<p>Tinted version of <var>al_draw_rle_sprite</var>. See the description of <link id="al_draw_rle_sprite" />. This must only be used after you have set up the color mapping table (for 256-color modes) or blender functions (for truecolor modes). Example:</p>
	<code>VAR
  GlobalLightTable: AL_COLOR_MAP;
	...
{ Some one time initialisation code. }
al_create_light_table (@GlobalLightTable, MyPalette,
		       10, 10, 60, NIL);
	 ...
  IF al_get_color_depth = 8 THEN
    al_set_color_map (@GlobalLightTable)
  ELSE
    al_set_trans_blender (40, 40, 255, 255);
{ Lit the cape with a blueish light. }
  al_draw_lit_rle_sprite (Buffer, RLE_ColoredCape, x, y);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_draw_rle_sprite" />
	<link id="al_draw_trans_rle_sprite" />
	<link id="albltspr.al_draw_lit_sprite">al_draw_lit_sprite</link>
	<link id="al256tra.al_set_color_map">al_set_color_map</link>
	<link id="altrutra.al_set_trans_blender">al_set_alpha_blender</link>
	<link id="albitmap.al_bitmap_mask_color">al_bitmap_mask_color</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_rle_sprite.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_rle_sprite.spr">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_rle_sprite.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_rle_sprite.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_draw_lit_rle_sprite.color">
<short></short>
</element>

</module> <!-- alsprrle -->


<!--
  ====================================================================
    alsystem
  ====================================================================
-->

<module name="alsystem">
<short>System level: initialization, cleanup, etc.</short>
<descr>
</descr>

<!-- constant Visibility: default -->
<element name="AL_SYSTEM_AUTODETECT">
<short>Autodetects the system driver.</short>
<descr>
	<p>Tells to <link id="al_install" /> that must autodetect the system driver.</p>
</descr>
<seealso>
	<link id="al_install" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_SYSTEM_NONE">
<short>No system driver used.</short>
<descr>
	<p>Tells to <link id="al_install" /> that must install a stripped down version of Allegro that won't even try to touch the hardware or do anything platform specific: this can be useful for situations where you only want to manipulate memory bitmaps, such as the text mode datafile tools or the Windows GDI interfacing functions..</p>
</descr>
<seealso>
	<link id="al_install" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_VERSION">
<short>Defined to the major version of Allegro.</short>
<descr>
	<p>Defined to the major version of Allegro. From a version number like 4.1.16, this would be defined to the integer 4.</p>
</descr>
<seealso>
	<link id="AL_SUB_VERSION" /><link id="AL_PAS_VERSION" /><link id="AL_PAS_IS_BETA" /><link id="AL_PAS_VERSION_STR" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_SUB_VERSION">
<short>Defined to the middle version of Allegro.</short>
<descr>
	<p>Defined to the middle version of Allegro. From a version number like 4.1.16, this would be defined to the integer 1.</p>
</descr>
<seealso>
	<link id="AL_VERSION" /><link id="AL_PAS_VERSION" /><link id="AL_PAS_IS_BETA" /><link id="AL_PAS_VERSION_STR" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_PAS_VERSION">
<short>Defined to the minor version of Allegro.pas.</short>
<descr>
	<p>Defined to the minor version of Allegro.pas. From a version number like 4.1.16, this would be defined to the integer 1.</p>
</descr>
<seealso>
	<link id="AL_VERSION" /><link id="AL_SUB_VERSION" /><link id="AL_PAS_IS_BETA" /><link id="AL_PAS_VERSION_STR" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_PAS_VERSION_STR">
<short>Defined to a text string containing all version numbers and maybe some additional text.</short>
<descr>
	<p>Defined to a text string containing all version numbers and maybe some additional text. This could be `4.1.16 BETA' for an Allegro.pas BETA version.</p>
</descr>
<seealso>
	<link id="AL_VERSION" /><link id="AL_SUB_VERSION" /><link id="AL_PAS_IS_BETA" /><link id="AL_PAS_VERSION" />
</seealso>
</element>

<!-- constant Visibility: default -->
<element name="AL_PAS_IS_BETA">
<short>Defined to TRUE if current version is a BETA version.</short>
<descr>
	<p>Defined to TRUE if current version is a BETA version.</p>
	<p>A BETA version is a test version and may be uncomplete or untested.</p>
</descr>
<seealso>
	<link id="AL_VERSION" /><link id="AL_SUB_VERSION" /><link id="AL_PAS_VERSION_STR" /><link id="AL_PAS_VERSION" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_errno">
<short>Stores the last error number.</short>
<descr>
</descr>
<seealso>
	<link id="al_error" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_id_string">
<short>String containing date and version number of Allegro.</short>
<descr>
	<p>Text string containing a date and version number for the library, in case you want to display these somewhere.</p>
</descr>
</element>

<!-- variable Visibility: default -->
<element name="al_error">
<short>Stores the last Allegro error message.</short>
<descr>
	<p>Text string used by <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>, <link id="alsound.al_install_sound">al_install_sound</link> and other functions to report error messages. If they fail and you want to tell the user why, this is the place to look for a description of the problem. Example:</p>
	<code>IF some_allegro_function = ERROR_CODE THEN
BEGIN
  al_set_gfx_mode (AL_GFX_TEXT, 0, 0, 0, 0);
  al_message(al_error);
  EXITT;
END;</code>
</descr>
<seealso>
	<link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link><link id="alsound.al_install_sound">al_install_sound</link>
</seealso>
</element>

<!-- function Visibility: default -->
<element name="AL_ID">
<short>Converts four 8 bit values to a packed 32 bit integer ID.</short>
<descr>
	<p>This function can be used to create a packed 32 bit integer from 8 bit characters, on both 32 and 64 bit machines. These can be used for various things, like custom datafile objects or system IDs. Example:</p>
	<code>VAR
  OSTYPE_LINUX: LONGINT;
BEGIN
  OSTYPE_LINUX := AL_ID(ORD ('T'), ORD ('U'), ORD ('X'), ORD (' '));
END;</code>	
</descr>
</element>

<!-- function result Visibility: default -->
<element name="AL_ID.Result">
<short>The 32 bit identifier.</short>
</element>

<!-- argument Visibility: default -->
<element name="AL_ID.a">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_ID.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_ID.c">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_ID.d">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_install">
<short>Initialises the Allegro library.</short>
<descr>
	<p>Initialises the Allegro library. You must call either this or <link id="al_init" /> before doing anything other<!-- than using the Unicode routines. If you want to use a text mode other than UTF-8, you can set it with set_uformat() before you call this -->. The <!-- other --> functions that can be called before this one will be marked explicitly in the documentation, like <link id="alconfig.al_set_config_file">al_set_config_file</link>.</p>
	<p>The available system ID codes will vary from one platform to another, but you will almost always want to pass <link id="AL_SYSTEM_AUTODETECT" />. Alternatively, <link id="AL_SYSTEM_NONE" /> installs a stripped down version of Allegro that won't even try to touch your hardware or do anything platform specific: this can be useful for situations where you only want to manipulate memory bitmaps, such as the text mode datafile tools or the Windows GDI interfacing functions.</p>
	<p>The `errno_ptr' should point to the errno variable from your libc: this is required because when Allegro is linked as a DLL, it doesn't have direct access to your local libc data. The `atexit_ptr' parameter is for compatibility purpose only and may be NIL.</p>
</descr>
<seealso>
	<link id="al_init" /><link id="al_exit" /><link id="alconfig.al_set_config_file">al_set_config_file</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install.Result">
<short>This function returns zero on success and non-zero on failure (e.g. no system driver could be used). Note: in previous versions of Allegro this function would abort on error.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install.system_id">
<short>System driver identification.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install.errno_ptr">
<short>Pointer to the errno variable.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install.atexit_ptr">
<short>Pointer to the atexit function. May be NIL.</short>
</element>

<!-- function Visibility: default -->
<element name="al_init">
<short>Function to initialise the Allegro library.</short>
<descr>
	<p>Function which initialises the Allegro library. This is the same thing as calling <link id="al_install" /> (<link id="AL_SYSTEM_AUTODETECT" />, @errno, @atexit), where "errno" and "atexit" are a variable and a function from the stdc library.</p>
</descr>
<seealso>
	<link id="al_install" /><link id="al_exit" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_init.Result">
<short>This function returns zero on success and non-zero on failure (e.g. no system driver could be used). Note: in previous versions of Allegro this function would abort on error.</short>

</element>

<!-- procedure Visibility: default -->
<element name="al_exit">
<short>Closes down the Allegro system.</short>
<descr>
	<p>Closes down the Allegro system. This includes returning the system to text mode and removing whatever mouse, keyboard, and timer routines have been installed. This procedure <b>must</b> be called before exit the program.</p>
</descr>
<errors>
	<p>Note that after you call this function, other functions like <link id="albitmap.al_destroy_bitmap">al_destroy_bitmap</link> will most likely crash.</p>
</errors>
<seealso>
	<link id="al_install" /><link id="al_init" /><link id="albitmap.al_destroy_bitmap">al_destroy_bitmap</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_message">
<short>Used mainly to show error messages to users.</short>
<descr>
	<p>Outputs a message. Usually you want to use this to report messages to the user in an OS independant way when some Allegro subsystem cannot be initialised. But you must not use this function if you are in a graphic mode, only before calling <link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>, or after a al_set_gfx_mode (<link id="algraph.AL_GFX_TEXT">AL_GFX_TEXT</link>). Also, this function depends on a system driver being installed, which means that it won't display the message at all on some platforms if Allegro has not been initialised correctly.</p>
	<p>On platforms featuring a windowing system, it will bring up a blocking GUI message box. If there is no windowing system, it will try to print the string to a text console, attempting to work around codepage differences by reducing any accented characters to 7-bit ASCII approximations. Example:</p>
	<code>IF al_init &lt;&gt; 0 THEN
    EXIT (1);
  IF NOT init_my_data THEN
  BEGIN
    al_message ('Sorry, missing game data!\n');
    EXIT (2);
  END;</code>
</descr>
<seealso>
	<link id="al_init" /><link id="al_install" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_message.msg">
<short>Message to output.</short>
</element>

<!-- function Visibility: default -->
<element name="al_set_close_button_callback">
<short>Installs a handler on the close button of the window.</short>
<descr>
	<p>On platforms that have a close button, this routine installs a callback function to handle the close event. In other words, when the user clicks the close button on your program's window or any equivalent device, the function you specify here will be called.</p>
	<p>This function should not generally attempt to exit the program or save any data itself. The function could be called at any time, and there is usually a risk of conflict with the main thread of the program. Instead, you should set a flag during this function, and test it on a regular basis in the main loop of the program.</p>
	<p>Pass NIL as the `proc' argument to this function to disable the close button functionality, which is the default state.</p>
	<!-- p>Note that Allegro cannot intercept the close button of a DOS box in Windows.</p -->
	<p><!-- Also note that the supplied callback is also called under MacOS X when the user hits Command-Q or selects "Quit" from the application menu.-->Example:</p>
	<code>VAR
  CloseButtonPressed: BOOLEAN = FALSE;

PROCEDURE CloseButtonHandler; CDECL;
BEGIN
  ClosePuttonPressed := TRUE;
END;
  
    ...

  al_init;
  al_set_close_button_callback (@CloseButtonHandler);

    ...
             
  WHILE NOT ClosePuttonPressed DO
    DoStuff;</code>
</descr>
</element>

<!-- function result Visibility: default -->
<element name="al_set_close_button_callback.Result">
<short>Returns zero on success and non-zero on failure (e.g. the feature is not supported by the platform).</short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_close_button_callback.proc">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_desktop_color_depth">
<short>Finds out the currently selected desktop color depth.</short>
<descr>
	<p>Finds out the currently selected desktop color depth. You can use this information to make your program use the same color depth as the desktop, which will likely make it run faster because the graphic driver won't be doing unnecessary color conversions behind your back.</p>
	<p>Under some OSes, switching to a full screen graphics mode may automatically change the desktop color depth. You have, therefore, to call this function before setting any graphics mode in order to retrieve the real desktop color depth. Example:</p>
	<code>allegro_init;
   ...
depth := al_desktop_color_depth;
IF depth &lt;&gt; 0 THEN
  al_set_color_depth (depth);</code>	
</descr>
<seealso>
	<link id="al_get_desktop_resolution" /><link id="algraph.al_set_color_depth">al_set_color_depth</link><link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_desktop_color_depth.Result">
<short>Returns the color depth or zero on platforms where this information is not available or does not apply.</short>
</element>

<!-- function Visibility: default -->
<element name="al_get_desktop_resolution">
<short>Finds out the currently selected desktop resolution.</short>
<descr>
	<p>Finds out the currently selected desktop resolution. You can use this information to avoid creating windows bigger than the current resolution. This is especially important for some windowed drivers which are unable to create windows bigger than the desktop. Each parameter is a pointer to an integer where one dimension of the screen will be stored.</p>
	<p>Under some OSes, switching to a full screen graphics mode may automatically change the desktop resolution. You have, therefore, to call this function before setting any graphics mode in order to retrieve the real desktop resolution. Example:</p>
	<code>VAR
  Width, Height: AL_INT;
BEGIN          
  al_init;
     ...
  IF al_get_desktop_resolution (@width, @height) = 0 THEN
  BEGIN
  { Got the resolution correctly }
  END;
     ...
  al_exit;
END.</code>
</descr>
<seealso>
	<link id="al_desktop_color_depth" /><link id="algraph.al_set_gfx_mode">al_set_gfx_mode</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_get_desktop_resolution.Result">
<short>Returns zero on success, or a negative number if this information is not available or does not apply, in which case the values stored in the variables you provided for `width' and `height' are undefined.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_desktop_resolution.w">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_get_desktop_resolution.h">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_window_title">
<short>Alters the window title for your Allegro program.</short>
<descr>
	<p>On platforms that are capable of it, this routine alters the window title for your Allegro program. Note that Allegro cannot set the window title when running in a DOS box under Windows. Example:</p>
	<code>al_set_window_title ('Allegro.pas rules!');</code>
	<p><b>Note:</b> On Delphi compilers this procedure hasn't any effect, so the window will keep its default caption.</p>
</descr>
<seealso>
	<link id="al_set_close_button_callback" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_window_title.title">
<short>The new title.</short>
</element>

<!-- procedure Visibility: default -->
<element name="__al_init_system__">
<short>FOR INTERNAL USE</short>
</element>

</module> <!-- alsystem -->


<!--
  ====================================================================
    altext
  ====================================================================
-->

<module name="altext">
<short>Text output</short>
<descr>
	<p>Allegro provides text output routines that work with both monochrome and color fonts, which can contain any number of Unicode character ranges. The grabber program can create fonts from sets of characters drawn in a bitmap file (see grabber.txt for more information), and can also import GRX or BIOS format font files. The font structure contains a number of hooks that can be used to extend it with your own custom drawing code: see the definition in allegro/text.h for details.</p>
</descr>

<!-- variable Visibility: default -->
<element name="al_font">
<short>A simple 8x8 fixed size font.</short>
<descr>
	<p>A simple 8x8 fixed size font (the mode 13h BIOS default). If you want to alter the font used by the GUI routines, change this to point to one of your own fonts. This font contains the standard ASCII (U+20 to U+7F), Latin-1 (U+A1 to U+FF), and Latin Extended-A (U+0100 to U+017F) character ranges.</p>
</descr>
<seealso>
	<link id="al_textout_ex" />
</seealso>
</element>

<!-- variable Visibility: default -->
<element name="al_404_char">
<short>Character used when Allegro cannot find a glyph.</short>
<descr>
	<p>When Allegro cannot find a glyph it needs in a font, it will instead output the character given in <var>al_404_char</var>. By default, this is set to the caret symbol, `^', but you can change this global to use any other character instead. Example:</p>
	<code>{ Show unknown glyphs with an asterisk. }
  al_404_char^ := ORD ('*');</code>
</descr>
<seealso>
	<link id="al_font" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_textout_ex">
<short>Writes a string on a bitmap.</short>
<descr>
	<p>Writes the string <var>s</var> onto the bitmap at position <var>x, y</var>, using the specified font, foreground color and background color. If the background color is -1, then the text is written transparently. If the foreground color is -1 and a color font is in use, it will be drawn using the colors from the original font bitmap (the one you imported into the grabber program), which allows multicolored text output. For high and true color fonts, the foreground color is ignored and always treated as -1. Example:</p>
	<code>{ Show the program's version in blue letters. }
  al_textout_ex (al_screen, al_font^, 'v4.2.0-beta2', 10, 10,
		 al_makecol (0, 0, 255), -1);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_font" />
	<link id="al_textout_centre_ex" />
	<link id="al_textout_right_ex" />
	<link id="al_textout_justify_ex" />
	<link id="al_text_height" />
	<link id="al_text_length" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.f">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.color">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_ex.bg">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_textout_centre_ex">
<short>Writes a centered string on a bitmap.</short>
<descr>
	<p>Like <link id="al_textout_ex" />, but interprets the <var>x</var> coordinate as the centre rather than the left edge of the string. Example:</p>
	<code>{ Important texts go in the middle. }
  al_textout_centre_ex (al_screen, al_font^, 'GAME OVER',
			AL_SCREEN_W DIV 2, AL_SCREEN_H DIV 2,
			al_makecol (255, 0, 0), al_makecol (0, 0, 0));</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_textout_ex" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.f">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.color">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_centre_ex.bg">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_textout_right_ex">
<short>Writes a right aligned string on a bitmap.</short>
<descr>
	<p>Like <link id="al_textout_ex" />, but interprets the <var>x</var> coordinate as the right rather than the left edge of the string. Example:</p>
	<code>al_textout_right_ex (al_screen, al_font^, 'Look at this color!',
		AL_SCREEN_W - 10, 10, myYellow, -1);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_textout_ex" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.f">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.color">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_right_ex.bg">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_textout_justify_ex">
<short>Draws justified text within a region.</short>
<descr>
	<p>Draws justified text within the region <var>x1-x2</var>. If the amount of spare space is greater than the diff value, it will give up and draw regular left justified text instead. Example:</p>
	<code>VAR
  Num, y: INTEGER;
  Lines: ARRAY [1..4] OF STRING = ('Draws justified text',
				   'within the specified',
				   'x2-x1 area. But not',
				   'T H I S !');
	...
{ Show the justification marker. }
  al_vline (al_screen, 200, 0, AL_SCREEN_H - 1, al_makecol (0, 0, 0));
{ Draw all the lines. }
  y := 0;
  FOR Num := 0 TO LENGTH (Lines) DO
  BEGIN
    al_textout_justify_ex (al_screen, al_font^, Lines[Num], 0, 200,
			   y, 80, al_makecol (0, 0, 0),
			   al_makecol (255, 255, 255));
    INC (y, al_text_height (al_font^));
  END;</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_textout_ex" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.bmp">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.f">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.str">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.x1">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.x2">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.diff">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.color">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_textout_justify_ex.bg">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_text_length">
<short>Returns the length of a string in pixels.</short>
<descr>
	<p>Returns the length (in pixels) of a string in the specified font. Example:</p>
	<code>Width := al_text_length (al_font^, 'I love spam');
          ...
  Bmp := al_create_bitmap (Width, Height);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_text_height" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_text_length.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_text_length.f">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_text_length.str">
<short></short>
</element>

<!-- function Visibility: default -->
<element name="al_text_height">
<short>Returns the height of a font in pixels.</short>
<descr>
	<p>Returns the height (in pixels) of the specified font. Example:</p>
	<code>Height := al_text_height (al_font^);
          ...
  Bmp := al_create_bitmap (Width, Height);</code>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_text_length" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_text_height.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_text_height.f">
<short></short>
</element>

</module> <!-- altext -->


<!--
  ====================================================================
    altimer
  ====================================================================
-->

<module name="altimer">
<short>Time control.</short>
<descr>
 <p>Allegro.pas can set up several virtual timer functions, all going at different speeds.</p>
 <!--Under DOS it will constantly reprogram the clock to make sure they are all called at the correct times. Because they alter the low level timer chip settings, these routines should not be used together with other DOS timer functions like the DJGPP uclock() routine. Moreover, the FPU state is not preserved across Allegro interrupts so you ought not to use floating point or MMX code inside timer interrupt handlers.-->
 <p>The timer procedures are usually implemented using threads, which run parallel to the main thread. Therefore timer callbacks <!--on such platforms--> will not block the main thread when called, so you may need to use appropriate synchronisation devices (eg. mutexes, semaphores, etc.) when accessing data that is shared by a callback and the main thread. (Currently Allegro does not provide such devices.)</p>
</descr>

<!-- function Visibility: default -->
<element name="AL_SECS_TO_TIMER">
<short>Give the number of seconds between each tick.</short>
<seealso>
 <link id="al_install_int_ex" /><link id="AL_MSEC_TO_TIMER" /><link id="AL_BPS_TO_TIMER" /><link id="AL_BPM_TO_TIMER" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_SECS_TO_TIMER.Result">
<short>Interruption value.</short>
</element>

<!-- argument Visibility: default -->
<element name="AL_SECS_TO_TIMER.x">
<short>Number of seconds.</short>
</element>

<!-- function Visibility: default -->
<element name="AL_MSEC_TO_TIMER">
<short>Give the number of milliseconds between each tick.</short>
<seealso>
 <link id="al_install_int_ex" /><link id="AL_SECS_TO_TIMER" /><link id="AL_BPS_TO_TIMER" /><link id="AL_BPM_TO_TIMER" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_MSEC_TO_TIMER.Result">
<short>Interruption value.</short>
</element>

<!-- argument Visibility: default -->
<element name="AL_MSEC_TO_TIMER.x">
<short>Number of milliseconds.</short>
</element>

<!-- function Visibility: default -->
<element name="AL_BPS_TO_TIMER">
<short>Give the number of ticks each second.</short>
<seealso>
 <link id="al_install_int_ex" /><link id="AL_SECS_TO_TIMER" /><link id="AL_MSEC_TO_TIMER" /><link id="AL_BPM_TO_TIMER" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_BPS_TO_TIMER.Result">
<short>Interruption value.</short>
</element>

<!-- argument Visibility: default -->
<element name="AL_BPS_TO_TIMER.x">
<short>Number of interruptions per second.</short>
</element>

<!-- function Visibility: default -->
<element name="AL_BPM_TO_TIMER">
<short>Give the number of ticks each minute.</short>
<seealso>
 <link id="al_install_int_ex" /><link id="AL_SECS_TO_TIMER" /><link id="AL_MSEC_TO_TIMER" /><link id="AL_BPS_TO_TIMER" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_BPM_TO_TIMER.Result">
<short>Interruption value.</short>
</element>

<!-- argument Visibility: default -->
<element name="AL_BPM_TO_TIMER.x">
<short>Number of interruptions per minute.</short>
</element>

<!-- function Visibility: default -->
<element name="al_install_timer">
<short>Installs the Allegro timer interrupt handler.</short>
<descr>
 <p>Installs the Allegro timer interrupt handler. You must do this before installing any user timer routines <!--, and also before displaying a mouse pointer, playing FLI animations or MIDI music, and using any of the GUI routines-->.</p>
</descr>
<seealso>
 <link id="al_remove_timer" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_timer.Result">
<short>Returns zero on success, or a negative number on failure (but you may decide not to check the return value as this function is very unlikely to fail).</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_timer">
<short>Removes the Allegro time handler.</short>
<descr>
 <p>Removes the Allegro timer handler <!--(and, under DOS, passes control of the clock back to the operating system)-->. You don't normally need to bother calling this, because <link id="alsystem.al_exit">al_exit()</link> will do it for you.</p>
</descr>
<seealso>
 <link id="alsystem.al_exit" />
</seealso>
</element>

<!-- function Visibility: default -->
<element name="al_install_int_ex">
<short>Adds or modifies a timer.</short>
<descr>
 <p>Adds a function to the list of user timer handlers or, if it is already installed, retroactively adjusts its speed (i.e makes as though the speed change occured precisely at the last tick). The speed is given in hardware clock ticks, of which there are 1193181 a second. You can convert from other time formats to hardware clock ticks with the functions:</p><dl>
  <dt><link id="AL_SECS_TO_TIMER">AL_SECS_TO_TIMER(secs)</link></dt><dd>Give the number of seconds between each tick.</dd>
  <dt><link id="AL_MSEC_TO_TIMER">AL_MSEC_TO_TIMER(msec)</link></dt><dd>Give the number of milliseconds between ticks.</dd>
  <dt><link id="AL_BPS_TO_TIMER">AL_BPS_TO_TIMER(bps)</link></dt><dd>Give the number of ticks each second.</dd>
  <dt><link id="AL_BPM_TO_TIMER">AL_BPM_TO_TIMER(bpm)</link></dt><dd>Give the number of ticks per minute.</dd>
 </dl>
 <p>There can only be sixteen timers in use at a time, and some other parts of Allegro (<!--the GUI code, the mouse pointer display routines, --><var>rest()</var><!--, the FLI player, and the MIDI player-->) need to install handlers of their own, so you should avoid using too many at the same time. If you call this routine without having first installed the timer module, <link id="al_install_timer" /> will be called automatically.</p>
 <p>Your function will be called by the Allegro interrupt handler and not directly by the processor, so it should be a normal C (<var>CDECL</var>) procedure and does not need a special wrapper. You should be aware, however, that it will be called in an interrupt context, which imposes a lot of restrictions on what you can do in it. It should not use large amounts of stack, it must not make any calls to the operating system, use Pascal or C library functions, or contain any floating point code, and it must execute very quickly. Don't try to do lots of complicated code in a timer handler: as a general rule you should just set some flags and respond to these later in your main control loop.</p>
</descr>
<errors>
 <p>Returns a negative number if there is no room to add a new user timer.</p>
</errors>
<seealso>
 <link id="al_install_int" /><link id="AL_SECS_TO_TIMER" /><link id="AL_MSEC_TO_TIMER" /><link id="AL_BPS_TO_TIMER" /><link id="AL_BPM_TO_TIMER" /><link id="al_remove_int" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_int_ex.Result">
<short>Returns zero on success, or a negative number if there is no room to add a new user timer.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_int_ex.proc">
<short>Timer procedure</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_int_ex.speed">
<short>Interruption speed</short>
</element>

<!-- function Visibility: default -->
<element name="al_install_int">
<short>Installs a user timer handler.</short>
<descr>
 <p>Installs a user timer handler, with the speed given as the number of milliseconds between ticks. This is the same thing as <link id="al_install_int_ex" />(proc, <link id="AL_MSEC_TO_TIMER" />(speed)). If you call this routine without having first installed the timer module, <link id="al_install_timer" /> will be called automatically. Calling again this routine with the same timer handler as parameter allows you to adjust its speed.</p>
</descr>
<errors>
 <p>Returns a negative number if there is no room to add a new user timer.</p>
</errors>
<seealso>
 <link id="al_install_int_ex" /><link id="al_remove_int" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_int.Result">
<short>Returns zero on success, or a negative number if there is no room to add a new user timer.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_int.proc">
<short>Timer procedure</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_int.speed">
<short>Number of milliseconds between each interruption.</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_int">
<short>Removes a timer interruption.</short>
<descr>
 <p>Removes a procedure from the list of user interrupt routines. <link id="alsystem.al_exit">al_exit</link> does this automatically.</p>
</descr>
<seealso>
 <link id="al_install_int_ex" /><link id="al_install_int" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_remove_int.proc">
<short>Timer procedure</short>
</element>

<!-- function Visibility: default -->
<element name="al_install_param_int_ex">
<short>Installs a timer routine with a customizable parameter.</short>
<descr>
 <p>Like <link id="al_install_int_ex" />, but the callback routine will be passed a copy of the specified void pointer parameter. To disable the handler, use <link id="al_remove_param_int" /> instead of al_remove_int.</p>
</descr>
<errors>
 <p>Returns a negative number if there is no room to add a new user timer.</p>
</errors>
<seealso>
 <link id="al_install_int_ex" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_param_int_ex.Result">
<short>Returns zero on success, or a negative number if there is no room to add a new user timer.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_param_int_ex.proc">
<short>Timer procedure</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_param_int_ex.speed">
<short>Interruption speed</short>
</element>

<!-- function Visibility: default -->
<element name="al_install_param_int">
<short>Installs a timer routine with a customizable parameter.</short>
<descr>
 <p>Like <link id="al_install_int" />, but the callback routine will be passed a copy of the specified void pointer parameter. To disable the handler, use <link id="al_remove_param_int" /> instead of al_remove_int.</p>
</descr>
<errors>
 <p>Returns a negative number if there is no room to add a new user timer.</p>
</errors>
<seealso>
 <link id="al_install_int" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="al_install_param_int.Result">
<short>Returns zero on success, or a negative number if there is no room to add a new user timer.</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_param_int.proc">
<short>Timer procedure</short>
</element>

<!-- argument Visibility: default -->
<element name="al_install_param_int.speed">
<short>Interruption speed</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_remove_param_int">
<short>Removes a timer with a customizable parameter.</short>
<descr>
 <p>Like <link id="al_remove_int" />, but for use with timer callbacks that have parameter values. If there is more than one copy of the same callback active at a time, it identifies which one to remove by checking the parameter value (so you can't have more than one copy of a handler using an identical parameter).</p>
</descr>
<errors>
 <p>Returns a negative number if there is no room to add a new user timer.</p>
</errors>
<seealso>
 <link id="al_install_int_ex" /><link id="al_install_int" /><link id="al_remove_int" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_remove_param_int.proc">
<short>Timer procedure</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rest">
<short>Waits a specified number of milliseconds or yields CPU.</short>
<descr>
 <p>This function waits for the specified number of milliseconds.</p>
 <p>Passing 0 as parameter will not wait, but just yield. This can be useful in order to <i>"play nice"</i> with other processes. Other values will cause CPU time to be dropped on most platforms. This will look better to users, and also does things like saving battery power and making fans less noisy.</p>
 <p>Note that calling this inside your active game loop is a bad idea, as you never know when the OS will give you the CPU back, so you could end up missing the vertical retrace and skipping frames. On the other hand, on multitasking operating systems it is good form to give up the CPU for a while if you will not be using it.</p>
</descr>
<seealso>
 <link id="al_rest_callback" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rest.time">
<short>Millisecons</short>
</element>

<!-- procedure Visibility: default -->
<element name="al_rest_callback">
<short>Like al_rest(), but calls the callback during the wait.</short>
<descr>
 <p>Like <link id="al_rest" />, but for non-zero values continually calls the specified function while it is waiting for the required time to elapse. If the provided `callback' parameter is NIL, this function does exactly the same thing as calling al_rest.</p>
</descr>
<seealso>
 <link id="al_rest" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_rest_callback.time">
<short>Millisecons</short>
</element>

<!-- argument Visibility: default -->
<element name="al_rest_callback.callback">
<short>Callback procedure.</short>
</element>

<!-- variable Visibility: default -->
<element name="al_retrace_count">
<short>Retrace count simulator.</short>
<descr>
 <p>If the retrace simulator is installed, this count is incremented on each vertical retrace; otherwise, if the refresh rate is known, the count is incremented at the same rate (ignoring retraces); otherwise, it is incremented 70 times a second. This provides a way of controlling the speed of your program without installing user timer functions.</p>
</descr>
<seealso>
 <link id="algraph.al_vsync">al_vsync</link>
</seealso>
</element>

</module> <!-- altimer -->


<!--
  ====================================================================
    altrutra
  ====================================================================
-->

<module name="altrutra">
<short>Tranparency for 8 bit graphic modes.</short>
<descr>
</descr>

<!-- function type Visibility: default -->
<element name="AL_BLENDER_FUNC">
<short>Callback function type.</short>
<descr>
	<p>Defines the type of function to be ised with <link id="al_set_blender_mode" /> and <link id="al_set_blender_mode_ex" />.</p>
</descr>
<seealso>
	<link id="al_set_blender_mode" />
	<link id="al_set_blender_mode_ex" />
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="AL_BLENDER_FUNC.Result">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_BLENDER_FUNC.x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_BLENDER_FUNC.y">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="AL_BLENDER_FUNC.n">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_alpha_blender">
<short>Enables a special alpha-channel blending mode.</short>
<descr>
	<p>Enables the special alpha-channel blending mode, which is used for drawing 32-bit RGBA sprites. After calling this function, you can use <link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link> or <link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link> to draw a 32-bit source image onto any hicolor or truecolor destination. The alpha values will be taken directly from the source graphic, so you can vary the solidity of each part of the image. You can't use any of the normal translucency functions while this mode is active, though, so you should reset to one of the normal blender modes (eg. <link id="al_set_trans_blender" />) before drawing anything other than 32-bit RGBA sprites.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link>
	<link id="al_set_write_alpha_blender" />
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_write_alpha_blender">
<short>Enables the special alpha-channel editing mode.</short>
<descr>
	<p>Enables the special alpha-channel editing mode, which is used for drawing alpha channels over the top of an existing 32-bit RGB sprite, to turn it into an RGBA format image. After calling this function, you can set the drawing mode to <link id="aldraw.AL_DRAW_MODE_TRANS">AL_DRAW_MODE_TRANS</link> and then write draw color values (0-255) onto a 32-bit image. This will leave the color values unchanged, but alter the alpha to whatever values you are writing. After enabling this mode you can also use <link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link> to superimpose an 8-bit alpha mask over the top of an existing 32-bit sprite.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_alpha_blender" />
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="aldraw.al_drawind_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_trans_blender">
<short>Enables a truecolor blender.</short>
<descr>
	<p>Enables a linear interpolator blender mode for combining translucent or lit truecolor pixels.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_blender_mode" />
	<link id="al_set_alpha_blender" />
	<link id="al_set_write_alpha_blender" />
	<link id="al256tra.AL_COLOR_MAP">AL_COLOR_MAP</link>
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="albltspr.al_draw_lit_sprite">al_draw_lit_sprite</link>
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
	<link id="al_set_add_blender" />
	<link id="al_set_burn_blender" />
	<link id="al_set_color_blender" />
	<link id="al_set_difference_blender" />
	<link id="al_set_dissolve_blender" />
	<link id="al_set_dodge_blender" />
	<link id="al_set_hue_blender" />
	<link id="al_set_invert_blender" />
	<link id="al_set_luminance_blender" />
	<link id="al_set_multiply_blender" />
	<link id="al_set_saturation_blender" />
	<link id="al_set_screen_blender" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_trans_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_trans_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_trans_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_trans_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_add_blender">
<short>Enables an additive blender mode.</short>
<descr>
	<p>Enables an additive blender mode for combining translucent or lit truecolor pixels.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_add_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_add_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_add_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_add_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_burn_blender">
<short>Enables a burn blender mode.</short>
<descr>
	<p>Enables a burn blender mode for combining translucent or lit truecolor pixels. Here the lightness values of the colours of the source image reduce the lightness of the destination image, darkening the image.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_burn_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_burn_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_burn_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_burn_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_color_blender">
<short>Enables a color blender mode.</short>
<descr>
	<p>Enables a color blender mode for combining translucent or lit truecolor pixels. Applies only the hue and saturation of the source image to the destination image. The luminance of the destination image is not affected.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_color_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_difference_blender">
<short>Enables a difference blender mode.</short>
<descr>
	<p>Enables a difference blender mode for combining translucent or lit truecolor pixels. This makes an image which has colours calculated by the difference between the source and destination colours.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_difference_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_difference_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_difference_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_difference_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_dissolve_blender">
<short>Enables a dissolve blender mode. </short>
<descr>
	<p>Enables a dissolve blender mode for combining translucent or lit truecolor pixels. Randomly replaces the colours of some pixels in the destination image with those of the source image. The number of pixels replaced depends on the alpha value (higher value, more pixels replaced; you get the idea :).</p>	
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dissolve_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dissolve_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dissolve_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dissolve_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_dodge_blender">
<short>Enables a dodge blender mode.</short>
<descr>
	<p>Enables a dodge blender mode for combining translucent or lit truecolor pixels. The lightness of colours in the source lighten the colours of the destination. White has the most effect; black has none.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dodge_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dodge_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dodge_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_dodge_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_hue_blender">
<short>Enables a hue blender mode.</short>
<descr>
	<p>Enables a hue blender mode for combining translucent or lit truecolor pixels. This applies the hue of the source to the destination.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hue_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hue_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hue_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_hue_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_invert_blender">
<short>Enables an invert blender mode.</short>
<descr>
	<p>Enables an invert blender mode for combining translucent or lit truecolor pixels. Blends the inverse (or negative) colour of the source with the destination.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_invert_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_invert_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_invert_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_invert_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_luminance_blender">
<short>Enables a luminance blender mode.</short>
<descr>
	<p>Enables a luminance blender mode for combining translucent or lit truecolor pixels. Applies the luminance of the source to the destination. The colour of the destination is not affected.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_luminance_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_luminance_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_luminance_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_luminance_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_multiply_blender">
<short>Enables a multiply blender mode.</short>
<descr>
	<p>Enables a multiply blender mode for combining translucent or lit truecolor pixels. Combines the source and destination images, multiplying the colours to produce a darker colour. If a colour is multiplied by white it remains unchanged; when multiplied by black it also becomes black.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_multiply_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_multiply_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_multiply_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_multiply_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_saturation_blender">
<short>Enables a saturation blender mode.</short>
<descr>
	<p>Enables a saturation blender mode for combining translucent or lit truecolor pixels. Applies the saturation of the source to the destination image.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_saturation_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_saturation_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_saturation_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_saturation_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_screen_blender">
<short>Enables a screen blender mode.</short>
<descr>
	<p>Enables a screen blender mode for combining translucent or lit truecolor pixels. This blender mode lightens the colour of the destination image by multiplying the inverse of the source and destination colours. Sort of like the opposite of the multiply blender mode.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_trans_blender" />
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_screen_blender.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_screen_blender.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_screen_blender.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_screen_blender.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_blender_mode">
<short>Specifies a custom set of truecolor blender routines.</short>
<descr>
	<p>Specifies a custom set of truecolor blender routines, which can be used to implement whatever special interpolation modes you need. This function shares a single blender between the 24 and 32-bit modes.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_blender_mode_ex" />
	<link id="al_set_trans_blender" />
	<link id="al256tra.AL_COLOR_MAP">AL_COLOR_MAP</link>
	<link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link>
	<link id="albltspr.al_draw_lit_sprite">al_draw_lit_sprite</link>
	<link id="aldraw.al_drawing_mode">al_drawing_mode</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.b15">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.b16">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.b24">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode.a">
<short></short>
</element>

<!-- procedure Visibility: default -->
<element name="al_set_blender_mode_ex">
<short>An even more complex version of <link id="al_set_blender_mode" />.</short>
<descr>
	<p>Like <link id="al_set_blender_mode" />, but allows you to specify a more complete set of blender routines. The <var>b15</var>, <var>b16</var>, <var>b24</var>, and <var>b32</var> routines are used when drawing pixels onto destinations of the same format, while <var>b15x</var>, <var>b16x</var>, and <var>b24x</var> are used by <link id="albltspr.al_draw_trans_sprite">al_draw_trans_sprite</link> and <link id="alsprrle.al_draw_trans_rle_sprite">al_draw_trans_rle_sprite</link> when drawing RGBA images onto destination bitmaps of another format. These blenders will be passed a 32-bit x parameter, along with a y value of a different color depth, and must try to do something sensible in response.</p>
</descr>
<errors>
</errors>
<seealso>
	<link id="al_set_blender_mode" />
	<link id="al_set_alpha_blender" />
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b15">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b16">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b24">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b32">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b15x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b16x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b24x">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.r">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.g">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.b">
<short></short>
</element>

<!-- argument Visibility: default -->
<element name="al_set_blender_mode_ex.a">
<short></short>
</element>

</module> <!-- altrutra -->

</package>
</fpdoc-descriptions>
