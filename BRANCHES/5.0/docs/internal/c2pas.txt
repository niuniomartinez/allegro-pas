			Convert C to Pascal
			===================

  This is a brief explanation about how to convert C code to Pascal.  Note that
  this document is to help to write the Allegro.pas wrapper library.

  You should read file "style.txt" too.



Content
-------

 * Allegro's API description
 * Data types
 * Enumerations
 * Parameters and return values
 * NOTES



Allegro's API description
-------------------------

  Allegro aims to define an API that is the same in any platform supported, so
  it's easer to port programs from one to another.  Since each platform has a
  different calling conventions it defines some "macros" to help to declare
  functions[1], data types and variables.

  "AL_FUNC (type, name, args)" defines a procedure (if type is "void") or
  function.  Note that "args" are a list of "type name" separated by comma.

  For example:

    AL_FUNC (void, al_set_new_bitmap_format, (int format));
    AL_FUNC (int, al_get_new_bitmap_format, (void));

  becames

    PROCEDURE al_set_new_bitmap_format (format: LONGINT); CDECL;
    FUNCTION al_get_new_bitmap_format: LONGINT; CDECL;

  The "CDECL" modifier tells the compiler that it's a C function.  It's
  necesary because C uses a different calling convention than Pascal.

  Most functions are in dll/so/dylib files so they're external.  The link
  information should be in the "IMPLEMENTATION" section to try to keep the
  "INTERFACE" section as clean as possible.

  So the previous example lines are inte INTERFACE while the IMPLEMENTATION
  should be:

    PROCEDURE al_set_new_bitmap_format (format: LONGINT); CDECL;
    EXTERNAL ALLEGRO_LIB_NAME;

    FUNCTION al_get_new_bitmap_format: LONGINT) CDECL;
    EXTERNAL ALLEGRO_LIB_NAME;

  Some functions are "inline", and should be "INLINE" in Pascal too.



Data types
----------

  C data types aren't very different than Pascal ones, but we should be careful
  to keep the same size to make them compatible.

  Also, the Free Pascal compiler activates some CPU exceptions to manage data
  conversions.  By default, C compilers don't activate these exceptions.  That
  results in some issues as discused in an Allegro.cc forum thread[2].

  Pointers in C are marked by "*".  "*char" are a pointer to char, but they
  actually use it as ANSISTRINGS.  I think it's better to use "PCHAR" and
  create inlined wrappers for parameters and function returning.

  C doesn't distiguish between array and pointers.  Actually an array is a
  pointer that points to a "non dynamic" memory space.  I think this is why
  Allegro.pas isn't working properly so we'll use pointers and create inlined
  wrappers for parameters and function returning.

  "bool" is the bad guy here.  It's a recent addition to the C language
  (1999 IIRC) and not all compilers supports it.  Allegro's defines it as
  "unsigned char" if compiler doesn't supports it.

  Enumerations are discussed in next section.



  Here you have a list of data types.  First column are C types, second are
  Pascal types.

  bool			BYTEBOOL[3]

  char			CHAR[3]
  unsigned char		BYTE
  *char			PCHAR or ANSISTRING

  int			LONGINT
  long int		LONGINT
  unsigned int		LONGWORD
  unsigned long int	LONGWORD[3]

  uint32_t		LONGWORD

  float			SINGLE
  double		DOUBLE



Enumerations
------------

  Enumerations are another "bad guy".  There are almost no difference between
  "enum" and "int".  In a perfect world, we should use enumerations in Pascal,
  but I think we shouldn't or use a wrapper for functions.

  Free Pascal and Delphi optimizes enumerations.  Both have modifiers that
  modifies that.

  AFAIK C enums are 4 bytes wide, so we can do this:

  PROCEDURE _ActualFunction_ (Value: LONGWORD); CDECL; EXTERNAL ...;

  PROCEDURE TheProcedure (Variable: EnumType);
  BEGIN
    _ActualFunction_ (ORD (Variable));
  END;



Parameters and return values
----------------------------

  In most functions parameters are pased "by value" with no modifications.

  In some cases they're passed as "const", so we must use the "CONST" modifier.

  C hasn't "VAR" nor "OUT" modifiers:  it uses pointer for this.  I think it is
  a bad idea to use "VAR" and "OUT", so we should use pointers and wrappers for
  this.

  PROCEDURE _ActualFunction_ (ValuePtr: ^LONGWORD); CDECL; EXTERNAL ...;

  PROCEDURE TheProcedure (VAR Variable: LONGWORD);
  BEGIN
    _ActualFunction_ (@Variable);
  END;



NOTES
-----

  [1] In C there's no difference between "function" and "procedure"; both are
      functions.  The difference is that some functions doesn't returns any
      value (they're of type "void").

  [2] http://www.allegro.cc/forums/thread/602423

  [3] Not sure.
