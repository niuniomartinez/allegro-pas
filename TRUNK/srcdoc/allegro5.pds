#Allegro5.al_get_allegro_version
Returns the (compiled) version of the Allegro library, packed into a single
integer as groups of 8 bits.

You can use code like this to extract the version number:
@longcode(#
  VAR
    Version: AL_INT;
    Major, Minor, Revision, Release: INTEGER;
    VersionStr: STRING;
  BEGIN
    Version := al_get_allegro_version;
    Major    :=  Version SHR 24;
    Minor    := (Version SHR 16) AND 255;
    Revision := (Version SHR  8) AND 255;
    Release  :=  Version         AND 255;
    VersionStr := Format ('%d.%d.%d(%d)', [Major, Minor, Revision, Release])
  END;
#)
The release number is 0 for an unofficial version and 1 or greater for an
official release. For example "5.0.2[1]" would be the (first) official 5.0.2
release while "5.0.2[0]" would be a compile of a version from the "5.0.2"
branch before the official release.
#Allegro5.al_run_main
This function is useful in cases where you don't have a @code(main) function
but want to run Allegro (mostly useful in a wrapper library).  Under Windows
and Linux this is no problem because you simply can call
@link(al_install_system).  But some other system (like OSX) don't allow calling
@code(al_install_system) in the main thread.  @code(al_run_main) will know what
to do in that case.

The passed @code(argc) and @code(argv) will simply be passed on to
@code(user_main) and the return value of @code(user_main) will be returned.

@bold(Note:)  This is used because the way the C language works.  I didn't test
if Pascal do need this kind of stuff.  Future versions of Allegro.pas would not
include this function, so don't use it unless your really need to (and tell me
if you really need it to remove this warning from documentation).
#Allegro5.AL_ID
This function can be used to create a packed 32 bit integer from 8 bit
characters, on both 32 and 64 bit machines.  These can be used for various
 things, like custom datafile objects or system IDs. Example:
@longcode(#
VAR
  OSTYPE_LINUX: LONGINT;
BEGIN
  OSTYPE_LINUX := AL_ID('TUX ');
END;
#)
#Allegro5.al_rest
This tells the system to pause the current thread for the given amount of time.
With some operating systems, the accuracy can be in the order of 10ms.  That
is, even
@longcode(#
    al_rest (0.000001)
#)
might pause for something like 10ms.  Also see the section on timer events
(i.e. @link(al_create_timer)) for easier ways to time your program without
using up all CPU.
#Allegro5.ALLEGRO_PIXEL_FORMAT
Each pixel format specifies the exact size and bit layout of a
pixel in memory.  Components are specified from high bits to low bits, so for
example a fully opaque red pixel in ARGB_8888 format is @code(0xFFFF0000).

@bold(Note:)
  The pixel format is independent of endianness.  That is, in the above example
  you can always get the red component with

  @code(@(pixel AND $00ff0000@) SHR 16)

  But you can not rely on this code:

  @code(@(PBYTE @(pixel + 2@)@)^)

  It will return the red component on little endian systems, but the green
  component on big endian systems.

  Also note that Allegro's naming is different from OpenGL naming here, where
  a format of @code(GL_RGBA8) merely defines the component order and the exact
  layout including endianness treatment is specified separately.  Usually
  @code(GL_RGBA8) will correspond to @code(ALLEGRO_PIXEL_ABGR_8888) though on
  little endian systems, so care must be taken (note the reversal of RGBA <->
  ABGR).

  The only exception to this @code(ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE) which
  always have the components as 4 bytes corresponding to red, green, blue and
  alpha, in this order, independent of the endianness.
  @seealso(al_set_new_bitmap_format) @seealso(al_get_bitmap_format)
#Allegro5.al_premul_rgba
This is a shortcut for @code(al_map_rgba @(r * a / 255, g * a / 255, b * a / 255, a@)).

By default Allegro uses pre-multiplied alpha for transparent blending of
bitmaps and primitives (see @link(al_load_bitmap_flags) for a discussion of
that feature). This means that if you want to tint a bitmap or primitive to be
transparent you need to multiply the color components by the alpha components
when you pass them to this function. For example, to draw the bitmap tinted red
and half-transparent.
@longcode(#
VAR
  c: ALLEGRO_COLOR;
  bmp: ALLEGRO_BITMAPptr;
BEGIN
  c := al_premul_rgba (255, 0, 0, 127);
  al_draw_tinted_bitmap (bmp, c, 0, 0, 0);
END;
#)
@seealso(al_map_rgba) @seealso(al_premul_rgba_f)
#Allegro5.al_premul_rgba_f
This is a shortcut for @code(al_map_rgba @(r * a, g * a, b * a, a@)).

By default Allegro uses pre-multiplied alpha for transparent blending of
bitmaps and primitives (see @link(al_load_bitmap_flags) for a discussion of
that feature). This means that if you want to tint a bitmap or primitive to be
transparent you need to multiply the color components by the alpha components
when you pass them to this function. For example, to draw the bitmap tinted red
and half-transparent.
@longcode(#
VAR
  c: ALLEGRO_COLOR;
  bmp: ALLEGRO_BITMAPptr;
BEGIN
  c := al_premul_rgba_f (1, 0, 0, 0.5);
  al_draw_tinted_bitmap (bmp, c, 0, 0, 0);
END;
#)
@seealso(al_map_rgba_f) @seealso(al_premul_rgba)
#Allegro5.al_set_new_bitmap_flags
Sets the flags to use for newly created bitmaps. Valid flags are:
@definitionlist(
 @itemLabel(ALLEGRO_VIDEO_BITMAP) @item(Creates a bitmap that resides in the video card memory. These types of bitmaps receive the greatest benefit from hardware acceleration. @link(al_set_new_bitmap_flags) will implicitly set this flag unless @code(ALLEGRO_MEMORY_BITMAP) is present.)
 @itemLabel(ALLEGRO_MEMORY_BITMAP) @item(Create a bitmap residing in system memory. Operations on, and with, memory bitmaps will not be hardware accelerated. However, direct pixel access can be relatively quick compared to video bitmaps, which depend on the display driver in use. @italic(Note: Allegro's software rendering routines are currently very unoptimised.))
 @itemLabel(ALLEGRO_KEEP_BITMAP_FORMAT) @item(Only used when loading bitmaps from disk files, forces the resulting ALLEGRO_BITMAP to use the same format as the file. @italic(This is not yet honoured.))
 @itemLabel(ALLEGRO_FORCE_LOCKING) @item(When drawing to a bitmap with this flag set, always use pixel locking and draw to it using Allegro's software drawing primitives. This should never be used if you plan to draw to the bitmap using Allegro's graphics primitives as it would cause severe performance penalties. However if you know that the bitmap will only ever be accessed by locking it, no unneeded FBOs will be created for it in the OpenGL drivers.)
 @itemLabel(ALLEGRO_NO_PRESERVE_TEXTURE) @item(Normally, every effort is taken to preserve the contents of bitmaps, since Direct3D may forget them. This can take extra processing time. If you know it doesn√¢'t matter if a bitmap keeps its pixel data, for example its a temporary buffer, use this flag to tell Allegro not to attempt to preserve its contents. This can increase performance of your game or application, but there is a catch. See ALLEGRO_EVENT_DISPLAY_LOST for further information.)
 @itemLabel(ALLEGRO_ALPHA_TEST) @item(This is a driver hint only. It tells the graphics driver to do alpha testing instead of alpha blending on bitmaps created with this flag. Alpha testing is usually faster and preferred if your bitmaps have only one level of alpha @(0@). This flag is currently not widely implemented @(i.e., only for memory bitmaps@).)
 @itemLabel(ALLEGRO_MIN_LINEAR) @item(When drawing a scaled down version of the bitmap, use linear filtering. This usually looks better. You can also combine it with the MIPMAP flag for even better quality.)
 @itemLabel(ALLEGRO_MAG_LINEAR) @item(When drawing a magnified version of a bitmap, use linear filtering. This will cause the picture to get blurry instead of creating a big rectangle for each pixel. It depends on how you want things to look like whether you want to use this or not.)
 @itemLabel(ALLEGRO_MIPMAP) @item(This can only be used for bitmaps whose width and height is a power of two. In that case, it will generate mipmaps and use them when drawing scaled down versions. For example if the bitmap is 64x64, then extra bitmaps of sizes 32x32, 16x16, 8x8, 4x4, 2x2 and 1x1 will be created always containing a scaled down version of the original.)
 @itemLabel(ALLEGRO_NO_PREMULTIPLIED_ALPHA) @item(By default, Allegro pre-multiplies the alpha channel of an image with the images color data when it loads it. Typically that would look something like this:
@longcode(#
  r := get_float_byte ();
  g := get_float_byte ();
  b := get_float_byte ();
  a := get_float_byte ();

  r := r * a;
  g := g * a;
  b := b * a;

  set_image_pixel (x, y, r, g, b, a);
#)
  The reason for this can be seen in the Allegro example ex_premulalpha, ie,
  using pre-multiplied alpha gives more accurate color results in some cases.
  To use alpha blending with images loaded with pre-multiplied alpha, you would
  use the default blending mode, which is set with @code(al_set_blender
  @(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA@)) to set the correct
  blender.  This has some caveats.  First, as mentioned above, drawing such an
  image can result in less accurate color blending @(when drawing an image with
  linear filtering on, the edges will be darker than they should be@).  Second,
  the behaviour is somewhat confusing, which is explained in the example below.
@longcode(#
// Load and create bitmaps with an alpha channel
  al_set_new_bitmap_format (ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
// Load some bitmap with alpha in it
  bmp = al_load_bitmap ('some_alpha_bitmap.png');
// We will draw to this buffer and then draw this buffer to the screen
  tmp_buffer = al_create_bitmap (SCREEN_W, SCREEN_H);
// Set the buffer as the target and clear it
  al_set_target_bitmap (tmp_buffer);
  al_clear_to_color (al_map_rgba_f (0, 0, 0, 1));
// Draw the bitmap to the temporary buffer
  al_draw_bitmap (bmp, 0, 0, 0);
// Finally, draw the buffer to the screen
// The output will look incorrect (may take close inspection
// depending on the bitmap -- it may also be very obvious)
  al_set_target_bitmap (al_get_backbuffer (display));
  al_draw_bitmap (tmp_buffer, 0, 0, 0);
#)
 )
)
To explain further, if you have a pixel with 0.5 alpha, and you're using
(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA) for blending, the
formula is:
@longcode(#
  a := da * dst + sa * src
#)
Expands to:
@longcode(#
  result_a := dst_a * (1-0.5) + 0.5 * 0.5;
#)
So if you draw the image to the temporary buffer, it is blended once
resulting in 0.75 alpha, then drawn again to the screen, blended in the
same way, resulting in a pixel has 0.1875 as an alpha value.
@seealso(al_get_new_bitmap_flags) @seealso(al_get_bitmap_flags)
#al_create_bitmap
Creates a new bitmap using the bitmap format and flags for the current
thread. Blitting between bitmaps of differing formats, or blitting between
memory bitmaps and display bitmaps may be slow.

Unless you set the @code(ALLEGRO_MEMORY_BITMAP) flag, the bitmap is created for the
current display.  Blitting to another display may be slow.

If a display bitmap is created, there may be limitations on the allowed
dimensions. For example a DirectX or OpenGL backend usually has a maximum
allowed texture size - so if bitmap creation fails for very large
dimensions, you may want to re-try with a smaller bitmap. Some platforms
also dictate a minimum texture size, which is relevant if you plan to use
this bitmap with the primitives addon. If you try to create a bitmap smaller
than this, this call will not fail but the returned bitmap will be a section
of a larger bitmap with the minimum size. This minimum size is 16 by 16.

Some platforms do not directly support display bitmaps whose dimensions are
not powers of two. Allegro handles this by creating a larger bitmap that has
dimensions that are powers of two and then returning a section of that
bitmap with the dimensions you requested. This can be relevant if you plan
to use this bitmap with the primitives addon but shouldn't be an issue
otherwise.
@seealso(al_set_new_bitmap_format) @seealso(al_set_new_bitmap_flags)
@seealso(al_clone_bitmap) @seealso(al_create_sub_bitmap)
@seealso(al_destroy_bitmap)
#Allegro5.al_put_pixel
Draws a single pixel on the target bitmap.  This operation is slow on
non-memory bitmaps. Consider locking the bitmap if you are going to use this
function multiple times on the same bitmap.  This function is not affected by
the transformations or the color blenders.
@seealso(al_get_pixel) @seealso(al_put_blended_pixel) @seealso(al_lock_bitmap)
#Allegro5.al_create_sub_bitmap
Creates a sub-bitmap of the parent, at the specified coordinates and of the
specified size. A sub-bitmap is a bitmap that shares drawing memory with a
pre-existing (parent) bitmap, but possibly with a different size and clipping
settings.

The sub-bitmap may originate off or extend past the parent bitmap.

See the discussion in @link(al_get_backbuffer) about using sub-bitmaps of the
backbuffer.

The parent bitmap's clipping rectangles are ignored.

If a sub-bitmap was not or cannot be created then NULL is returned.

When you are done with using the sub-bitmap you must call
@link(al_destroy_bitmap) on it to free any resources allocated for it.

Note that destroying parents of sub-bitmaps will not destroy the sub-bitmaps;
instead the sub-bitmaps become invalid and should no longer be used for
drawing - they still must be destroyed with al_destroy_bitmap however.  It
does not matter whether you destroy a sub-bitmap before or after its parent
otherwise.
@seealso(al_create_bitmap)
#Allegro5.al_get_parent_bitmap
Returns the bitmap this bitmap is a sub-bitmap of. Returns @nil if this
bitmap is not a sub-bitmap. This function always returns the real bitmap,
and never a sub-bitmap. This might NOT match what was passed to
@code(al_create_sub_bitmap). Consider this code, for instance:
@longcode(#
VAR
  a, b, c: ALLEGRO_BITMAPptr;
BEGIN
  a := al_create_bitmap (512, 512);
  b := al_create_sub_bitmap (a, 128, 128, 256, 256);
  c := al_create_sub_bitmap (b, 64, 64, 128, 128);
  IF (al_get_parent_bitmap (b)== a) AND (al_get_parent_bitmap(c) = a) THEN
    WriteLn ('b & c are sub-bitmaps of a')
END;
#)
The message will be printed because only a is a real bitmap, and both b and c
are its sub-bitmaps.
@seealso(al_create_sub_bitmap) @seealso(al_is_sub_bitmap)
#Allegro5.al_reparent_bitmap
For a sub-bitmap, changes the parent, position and size.  This is the same as
destroying the bitmap and re-creating it with @code(al_create_sub_bitmap) -
except the bitmap pointer stays the same.  This has many uses, for example an
animation player could return a single bitmap which can just be re-parented to
different animation frames without having to re-draw the contents.  Or a sprite
atlas could re-arrange its sprites without having to invalidate all existing
bitmaps. @seealso(al_create_sub_bitmap) @seealso(al_get_parent_bitmap)
#Allegro5.al_clone_bitmap
Create a new bitmap with @code(al_create_bitmap), and copy the pixel data from
the old bitmap across. If the new bitmap is a memory bitmap, its projection
bitmap is reset to be orthographic.
@seealso(al_create_bitmap) @seealso(al_set_new_bitmap_format)
@seealso(al_set_new_bitmap_flags) @seealso(al_convert_bitmap)
#Allegro5.al_convert_bitmap
Converts the bitmap to the current bitmap flags and format.  The bitmap will
be as if it was created new with @code(al_create_bitmap) but retain its
contents.  All of this bitmap's sub-bitmaps are also converted.  If the new
bitmap type is memory, then the bitmap's projection bitmap is reset to be
orthographic.

If this bitmap is a sub-bitmap, then it, its parent and all the sibling
sub-bitmaps are also converted.
@seealso(al_create_bitmap) @seealso(al_set_new_bitmap_format)
@seealso(al_set_new_bitmap_flags) @seealso(al_clone_bitmap)
#Allegro5.al_conver_memory_bitmap
If you create a bitmap when there is no current display (for example because
you have not called @code(al_create_display) in the current thread) and are
using the @code(ALLEGRO_CONVERT_BITMAP) bitmap flag (which is set by default)
then the bitmap will be created successfully, but as a memory bitmap.  This
function converts all such bitmaps to proper video bitmaps belonging to the
current display.

Note that video bitmaps get automatically converted back to memory bitmaps
when the last display is destroyed.

This operation will preserve all bitmap flags except
@code(ALLEGRO_VIDEO_BITMAP) and @code(ALLEGRO_MEMORY_BITMAP).
@seealso(al_convert_bitmap) @seealso(al_create_bitmap)
#Allegro5.al_draw_bitmap
Draws an unscaled, unrotated bitmap at the given position to the current
target bitmap.  @code(flags) can be a combination of:
@unorderedlist(
  @item(ALLEGRO_FLIP_HORIZONTAL - flip the bitmap about the y-axis)
  @item(ALLEGRO_FLIP_VERTICAL - flip the bitmap about the x-axis)
)
@bold(Note:) The current target bitmap must be a different bitmap. Drawing a
bitmap to itself (or to a sub-bitmap of itself) or drawing a sub-bitmap to
its parent (or another sub-bitmap of its parent) are not currently
supported. To copy part of a bitmap into the same bitmap simply use a
temporary bitmap instead.

@bold(Note:) The backbuffer (or a sub-bitmap thereof) can not be
transformed, blended or tinted. If you need to draw the backbuffer draw it
to a temporary bitmap first with no active transformation (except
translation). Blending and tinting settings/parameters will be ignored. This
does not apply when drawing into a memory bitmap.
@param(bitmap Origin bitmap.)
@param(dx Destination x.)
@param(dy Destination y.)
@param(flags)
@seealso(al_set_target_bitmap) @seealso(al_draw_bitmap_region)
@seealso(al_draw_scaled_bitmap) @seealso(al_draw_rotated_bitmap)
@seealso(al_draw_scaled_rotated_bitmap)
#Allegro5.al_draw_bitmap_region
Draws a region of the given bitmap to the target bitmap.
@param(bitmap Origin bitmap.)
@param(sx source x)
@param(sy source y)
@param(sw source width @(width of region to blit@))
@param(sh source height @(height of region to blit@))
@param(dx destination x)
@param(dy destination y)
@param(flags same as for @code(al_draw_bitmap))
@seealso(al_draw_bitmap) @seealso(al_draw_scaled_bitmap)
@seealso(al_draw_rotated_bitmap) @seealso(al_draw_scaled_rotated_bitmap)
#Allegro5.al_draw_scaled_bitmap
Draws a scaled version of the given bitmap to the target bitmap.
@param(bitmap Origin bitmap.)
@param(sx source x)
@param(sy source y)
@param(sw source width)
@param(sh source height)
@param(dx destination x)
@param(dy destination y)
@param(dw destination width)
@param(dh destination height)
@param(flags same as for al_draw_bitmap)
@seealso(al_draw_bitmap) @seealso(al_draw_bitmap_region)
@seealso(al_draw_rotated_bitmap) @seealso(al_draw_scaled_rotated_bitmap)
#Allegro5.al_draw_rotated_bitmap
Draws a rotated version of the given bitmap to the target bitmap.
Example:
@longcode(#
VAR
  w, h: SINGLE;
BEGIN
  w := al_get_bitmap_width (bitmap);
  h := al_get_bitmap_height (bitmap);
  al_draw_rotated_bitmap (bitmap, w / 2, h / 2, x, y, ALLEGRO_PI / 2, 0);
#)
The above code draws the bitmap centered on x/y and rotates it 90¬∞ clockwise.
@param(bitmap Origin bitmap.)
@param(cx center x @(relative to the left of bitmap@))
@param(cy center y @(relative to the top or bitmap@))
@param(dx destination x)
@param(dy destination y)
@param(angle angle in radians by which to rotate clockwise)
@param(flags same as for al_draw_bitmap)
@seealso(al_draw_bitmap) @seealso(al_draw_bitmap_region)
@seealso(al_draw_scaled_bitmap) @seealso(al_draw_scaled_rotated_bitmap)
#Allegro5.al_draw_scaled_rotated_bitmap
Like @link(al_draw_rotated_bitmap), but can also scale the bitmap.

The point at cx/cy in the bitmap will be drawn at dx/dy and the bitmap is
rotated and scaled around this point.
@param(bitmap Origin bitmap.)
@param(cx center x @(relative to the left of bitmap@))
@param(cy center y @(relative to the top or bitmap@))
@param(dx destination x)
@param(dy destination y)
@param(xscale how much to scale on the x-axis @(e.g. 2 for twice the size@))
@param(yscale how much to scale on the y-axis)
@param(angle angle in radians by which to rotate clockwise)
@param(flags same as for al_draw_bitmap)
@seealso(al_draw_bitmap) @seealso(al_draw_bitmap_region)
@seealso(al_draw_scaled_bitmap)
#Allegro5.al_draw_tinted_bitmap
Like @code(al_draw_bitmap) but multiplies all colors in the bitmap with the
given color. For example:
@longcode(#
al_draw_tinted_bitmap (bitmap, al_map_rgba_f (0.5, 0.5, 0.5, 0.5), x, y, 0);
#)
The above will draw the bitmap 50% transparently (r/g/b values need to be
pre-multiplied with the alpha component with the default blend mode).
@longcode(#
al_draw_tinted_bitmap(bitmap, al_map_rgba_f(1, 0, 0, 1), x, y, 0);
#)
The above will only draw the red component of the bitmap.

See @link(al_draw_bitmap) for a note on restrictions on which bitmaps can be
drawn where.
#Allegro5.al_draw_tinted_scaled_rotated_bitmap
Like @link(al_draw_tinted_scaled_rotated_bitmap) but you specify an area
within the bitmap to be drawn.

You can get the same effect with a sub bitmap:
@longcode(#
  al_draw_tinted_scaled_rotated_bitmap (
    bitmap, sx, sy, sw, sh, tint, cx, cy, dx, dy, xscale, yscale, angle, flags
  );

// This draws the same:
  sub_bitmap := al_create_sub_bitmap (bitmap, sx, sy, sw, sh);
  al_draw_tinted_scaled_rotated_bitmap (
    sub_bitmap, tint, cx, cy, dx, dy, xscale, yscale, angle, flags
  );
#)
See @link(al_draw_bitmap) for a note on restrictions on which bitmaps can be
drawn where.
@seealso(al_draw_tinted_bitmap)
#Allegro5.al_draw_tinted_scaled_rotated_bitmap_region
Like @link(al_draw_tinted_scaled_rotated_bitmap) but you specify an area within the bitmap to be drawn.

You can get the same effect with a sub bitmap:
@longcode(#
  al_draw_tinted_scaled_rotated_bitmap_region (
    bitmap, sx, sy, sw, sh, tint,
    cx, cy, dx, dy, xscale, yscale, angle, flags
  );

{ This draws the same: }
  sub_bitmap := al_create_sub_bitmap (bitmap, sx, sy, sw, sh);
  al_draw_tinted_scaled_rotated_bitmap (
    sub_bitmap, tint, cx, cy,
    dx, dy, xscale, yscale, angle, flags
  );
#)
See @link(al_draw_bitmap) for a note on restrictions on which bitmaps can be drawn where.
@seealso(al_draw_tinted_bitmap)
#Allegro5.al_cstr
Get a @code(AL_STRptr) pointer to the data in a string. This pointer will only be valid while the @code(ALLEGRO_USTR) object is not modified and not destroyed. The pointer may be passed to functions expecting C-style strings, with the following caveats:@unorderedlist(
  @item(@code(ALLEGRO_USTR)s are allowed to contain embedded @code(NUL) @(@code($00)@) bytes. That means @code(al_ustr_size @(u@)) and @code(strlen @(al_cstr @(u@)@)) may not agree.)
  @item(An @code(ALLEGRO_USTR) may be created in such a way that it is not @code(NUL) terminated. A string which is dynamically allocated will always be @code(NUL) terminated, but a string which references the middle of another string or region of memory will not be @code(NUL) terminated.)
  @item(If the @code(ALLEGRO_USTR) references another string, the returned C string will point into the referenced string. Again, no @code(NUL) terminator will be added to the referenced string.)
) @seealso(al_ustr_to_buffer) @seealso(al_cstr_dup)
#Allegro5.al_cstr_dup
Creates a @code(NUL) (@code($00)) terminated copy of the string. Any embedded @code(NUL) bytes will still be presented in the returned string. The new string must eventually be freed with @code(al_free).

If an error occurs @nil is returned.
@seealso(al_cstr) @seealso(al_ustr_to_buffer) @seealso(al_free)
#Allegro5.al_ustr_dup_substr
Return a new copy of a string, containing its contents in the byte interval @code([start_pos, end_pos@)). The new string will be @code(NUL) terminated and will need to be freed with @code(al_ustr_free).

If necessary, use @link(al_ustr_offset) to find the byte offsets for a given code point that you are interested in.
@seealso(al_ustr_dup) @seealso(al_ustr_free)






#Allegro5.al_ref_cstr
Create a string that references the storage of a C-style string. The
information about the string (e.g. its size) is stored in the @code(info)
parameter. The string will not have any other storage allocated of its own,
so if you allocate the info structure on the stack then no explicit "free"
operation is required.

The string is valid until the underlying C string disappears.

Example:
@longcode(#
VAR
  Info: ALLEGRO_USTR_INFO;
  us: ALLEGRO_USTRptr;
BEGIN
  us := al_ref_cstr (Info, 'my string')
END;
#)
@seealso(al_ref_buffer) @seealso(al_ref_ustr)
#Allegro5.al_ustr_next
Find the byte offset of the next code point in string, beginning at
@code(aPos). @code(aPos) does not have to be at the beginning of a code point.

This function just looks for an appropriate byte; it doesn't check if found
offset is the beginning of a valid code point. If you are working with
possibly invalid UTF-8 strings then it could skip over some invalid bytes.
@return(@true on success, and @code(aPos) will be updated to the found
offset. Otherwise returns @false if @code(aPos) was already at the end of
the string, and @code(aPos) is unmodified.)
@seealso(al_ustr_prev)
#Allegro5.al_ustr_prev
Find the byte offset of the previous code point in string, before
@code(aPos). @code(aPos) does not have to be at the beginning of a code point.

This function just looks for an appropriate byte; it doesn't check if found
offset is the beginning of a valid code point. If you are working with
possibly invalid UTF-8 strings then it could skip over some invalid bytes.
@return(@true on success, and @code(aPos) will be updated to the found
offset. Otherwise returns @false if @code(aPos) was already at the end of
the string, and @code(aPos) is unmodified.)
@seealso(al_ustr_next)
#Allegro5.ALLEGRO_FILE_INTERFACE
A structure containing function pointers to handle a type of "file", real
or virtual. See the full discussion in @link(al_set_new_file_interface).

The @code(fi_open) function must allocate memory for whatever userdata
structure it needs.  The pointer to that memory must be returned; it will
then be associated with the file. The other functions can access that data
by calling @link(al_get_file_userdata) on the file handle. If
@code(fi_open) returns @nil then @link(al_fopen) will also return @nil.

The @code(fi_fclose) function must clean up and free the userdata, but
Allegro will free the @code(ALLEGRO_FILEptr) handle.

If @code(fi_fungetc) is @nil, then Allegro's default implementation of a
16 char long buffer will be used.
@seealso(al_set_new_file_interface) @seealso(al_fopen_interface)
@seealso(al_get_file_userdata)
#Allegro5.al_fopen
Creates and opens a file (real or virtual) given the path and mode. The
current file interface is used to open the file.

Depending on the stream type and the mode string, files may be opened in
"text" mode. The handling of newlines is particularly important. For
example, using the default stdio-based streams on DOS and Windows
platforms, where the native end-of-line terminators are @code(CR+LF)
sequences, a call to @link(al_fgetc) may return just one character ('\n')
where there were two bytes (@code(CR+LF)) in the file. When writing out
'\n', two bytes would be written instead. (As an aside, '\n' is not
defined to be equal to @code(LF) either.)

Newline translations can be useful for text files but is disastrous for
binary files. To avoid this behaviour you need to open file streams in
binary mode by using a mode argument containing a "b", e.g. "rb", "wb".
@param(path Path to the file to open.)
@param(mode Access mode to open the file in @('r', 'w', etc.@).)
@return(a file handle on success, or @nil on error.)
@seealso(al_set_new_file_interface) @seealso(al_fclose)
#Allegro5.al_fseek
Set the current position of the given file to a position relative to that
specified by @code(whence), plus @code(offset) number of bytes.

@code(whence) can be:@unorderedlist(
     @item(@code(ALLEGRO_SEEK_SET) - seek relative to beginning of file)
     @item(@code(ALLEGRO_SEEK_CUR) - seek relative to current file position)
     @item(@code(ALLEGRO_SEEK_END) - seek relative to end of file)
)
After a successful seek, the end-of-file indicator is cleared and all
pushback bytes are forgotten.

On some platforms this function may not support large files.
@return(@true on success, @false on failure.)
@seealso(al_ftell) @seealso(al_get_errno)
#Allegro5.al_fungetc
Ungets a single byte from a file. Pushed-back bytes are not written to the
file, only made available for subsequent reads, in reverse order.

The number of pushbacks depends on the backend. The standard I/O backend
only guarantees a single pushback; this depends on the libc implementation.

For backends that follow the standard behavior, the pushback buffer will
be cleared after any seeking or writing; also calls to @link(al_fseek) and
@link(al_ftell) are relative to the number of pushbacks. If a pushback
causes the position to become negative, the behavior of @code(al_fseek)
and @code(al_ftell) are undefined.
@seealso(al_fgetc) @seealso(al_get_errno)
#Allegro5.al_fgets
Reads a string of bytes terminated with a newline or end-of-file into the
buffer given. The line terminator(s), if any, are included in the returned
string. A maximum of @code(max-1) bytes are read, with one byte being
reserved for a @code(NUL) terminator.

See @link(al_fopen) about translations of end-of-line characters.
@param(f File to read from.)
@param(buf Buffer to fill.)
@param(max Maximum size of buffer.)
@return(The pointer to @code(buf) on success. Returns @nil if an error
 occurred or if the end of file was reached without reading any bytes.)
@seealso(al_fget_ustr)
#Allegro5.al_fopen_slice
Opens a slice (subset) of an already open random access file as if it were
a stand alone file. While the slice is open, the parent file handle must
not be used in any way.

The slice is opened at the current location of the parent file, up through
@code(initial_size) bytes. The @code(initial_size) may be any non-negative
integer that will not exceed the bounds of the parent file.

Seeking with ALLEGRO_SEEK_SET will be relative to this starting location.
ALLEGRO_SEEK_END will be relative to the starting location plus the size
of the slice.

The mode can be any combination of:@unorderedlist(
@item(r: read access)  @item(w: write access) @item(e: expandable)
)

For example, a mode of @code('rw') indicates the file can be read and
written. (Note that this is slightly different from the stdio modes.) Keep
in mind that the parent file must support random access and be open in
normal write mode (not append) for the slice to work in a well defined way.

If the slice is marked as expandable, then reads and writes can happen
after the initial end point, and the slice will grow accordingly.
Otherwise, all activity is restricted to the initial size of the slice.

A slice must be closed with @link(al_fclose). The parent file will then be
positioned immediately after the end of the slice.
@seealso(al_fopen)
#Allegro5.al_register_bitmap_loader
Registers a handler for @link(al_load_bitmap). The given function will be
used to handle the loading of bitmaps files with the given extension.

The extension should include the leading dot ('.') character. It will be
matched case-insensitively.

The loader argument may be @nil to unregister an entry.
@return(@true on success, @false on error. Returns @false if unregistering
	   an entry that doesn't exist.)
@seealso(al_register_bitmap_saver) @seealso(al_register_bitmap_loader_f)
#Allegro5.al_register_bitmap_saver
Registers a handler for @link(al_save_bitmap). The given function will be
used to handle the saving of bitmaps files with the given extension.

The extension should include the leading dot ('.') character. It will be
matched case-insensitively.

The loader argument may be @nil to unregister an entry.
@return(@true on success, @false on error. Returns @false if unregistering
	   an entry that doesn't exist.)
@seealso(al_register_bitmap_loader) @seealso(al_register_bitmap_saver_f)
#Allegro5.al_register_bitmap_loader_f
Registers a handler for @link(al_load_bitmap_f). The given function will be
used to handle the loading of bitmaps files with the given extension.

The extension should include the leading dot ('.') character. It will be
matched case-insensitively.

The fs_loader argument may be @nil to unregister an entry.
@return(@true on success, @false on error. Returns @false if unregistering
	   an entry that doesn't exist.)
@seealso(al_register_bitmap_loader)
#Allegro5.al_register_bitmap_saver_f
Registers a handler for @link(al_save_bitmap_f). The given function will be
used to handle the saving of bitmaps files with the given extension.

The extension should include the leading dot ('.') character. It will be
matched case-insensitively.

The fs_saver argument may be @nil to unregister an entry.
@return(@true on success, @false on error. Returns @false if unregistering
	   an entry that doesn't exist.)
@seealso(al_register_bitmap_saver)
#Allegro5.al_register_bitmap_identifier
Registers an identify handler for @link(al_identify_bitmap). The given
function will be used to detect files for the given extension. It will be
called with a single argument of type @link(ALLEGRO_FILEptr) which is a file
handle opened for reading and located at the first byte of the file. The
handler should try to read as few bytes as possible to safely determine if
the given file contents correspond to the type with the extension and return
@true in that case, @false otherwise. The file handle must not be closed but
there is no need to reset it to the beginning.

The extension should include the leading dot ('.') character. It will be
matched case-insensitively.

The @code(identifier) argument may be @nil to unregister an entry.
@return(@true on success, @false on error. Returns @false if unregistering
	   an entry that doesn't exist.)
@seealso(al_identify_bitmap)
#Allegro5.al_load_bitmap
Loads an image file into a new @code(ALLEGRO_BITMAPptr). The file type is
determined by the extension, except if the file has no extension in which
case @code(al_identify_bitmap) is used instead.

This is the same as calling @code(al_load_bitmap_flags) with a flags
parameter of 0.

@bold(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register your
own format handler.
@return(A pointer to the loaded bitmap or @nil on error.)
@seealso(al_load_bitmap_f) @seealso(al_register_bitmap_loader)
@seealso(al_load_bitmap_flags) @seealso(al_set_new_bitmap_format)
@seealso(al_set_new_bitmap_flags) @seealso(al_init_image_addon)
#Allegro5.al_load_bitmap_flags
Loads an image file into a new @code(ALLEGRO_BITMAPptr). The file type is
determined by the extension, except if the file has no extension in which
case @link(al_identify_bitmap) is used instead.

@code(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register your
own format handler.
@param(flags It may be a combination of the following constants:
@unorderedlist(
   @item(@bold(@code(ALLEGRO_NO_PREMULTIPLIED_ALPHA))
    By default, Allegro pre-multiplies the alpha channel of an image with the
    images color data when it loads it. Typically that would look something like
    this:
@longcode(#
    r := get_float_byte;
    g := get_float_byte;
    b := get_float_byte;
    a := get_float_byte;

    r := r * a;
    g := g * a;
    b := b * a;

    set_image_pixel (x, y, r, g, b, a);
#)
    The reason for this can be seen in the Allegro example @code(ex_premulalpha),
    ie, using pre-multiplied alpha gives more accurate color results in some
    cases. To use alpha blending with images loaded with pre-multiplied alpha,
    you would use the default blending mode, which is set with
    @code(al_set_blender @(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA@)).

    The @code(ALLEGRO_NO_PREMULTIPLIED_ALPHA) flag being set will ensure that
    images are not loaded with alpha pre-multiplied, but are loaded with color
    values direct from the image. That looks like this:
@longcode(#
    r := get_float_byte;
    g := get_float_byte;
    b := get_float_byte;
    a := get_float_byte;

    set_image_pixel (x, y, r, g, b, a);
#)
    To draw such an image using regular alpha blending, you would use
    @code(al_set_blender @(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA@))
    to set the correct blender. This has some caveats. First, as mentioned
    above, drawing such an image can result in less accurate color blending
    (when drawing an image with linear filtering on, the edges will be darker
    than they should be). Second, the behaviour is somewhat confusing, which is
    explained in the example below.
@longcode(#
  // Load and create bitmaps with an alpha channel
    al_set_new_bitmap_format (ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
  // Load some bitmap with alpha in it
    bmp := al_load_bitmap ('some_alpha_bitmap.png');
  // We will draw to this buffer and then draw this buffer to the screen
    tmp_buffer := al_create_bitmap (SCREEN_W, SCREEN_H);
  // Set the buffer as the target and clear it
    al_set_target_bitmap (tmp_buffer);
    al_clear_to_color (al_map_rgba_f (0, 0, 0, 1));
  // Draw the bitmap to the temporary buffer
    al_draw_bitmap (bmp, 0, 0, 0);
  // Finally, draw the buffer to the screen
  // The output will look incorrect (may take close inspection
  // depending on the bitmap -- it may also be very obvious)
    al_set_target_bitmap (al_get_backbuffer (display));
    al_draw_bitmap (tmp_buffer, 0, 0, 0);
#)
    To explain further, if you have a pixel with 0.5 alpha, and you're using
    @code(@(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA@)) for blending,
    the formula is:
@longcode(#
    a := da * dst + sa * src
#)
    Expands to:
@longcode(#
    result_a := dst_a * (1-0.5) + 0.5 * 0.5
#)
    So if you draw the image to the temporary buffer, it is blended once
    resulting in 0.75 alpha, then drawn again to the screen, blended in the
    same way, resulting in a pixel has 0.1875 as an alpha value.)
  @item(@bold(@code(ALLEGRO_KEEP_INDEX))

    Load the palette indices of 8-bit .bmp and .pcx files instead of the rgb
    colors.)
  @item(@bold(@code(ALLEGRO_KEEP_BITMAP_FORMAT))

    Force the resulting ALLEGRO_BITMAP to use the same format as the file.

    This is not yet honoured.)
))
@returns(@nil on error.)
@seealso(al_load_bitmap)
#Allegro5.al_load_bitmap_f
Loads an image from an @link(ALLEGRO_FILEptr) stream into a new
@link(ALLEGRO_BITMAPptr). The file type is determined by the passed
@code(ident) parameter, which is a file name extension including the leading
dot. If (and only if) @code(ident) is @nil, the file type is determined with
@link(al_identify_bitmap_f) instead.

This is the same as calling @link(al_load_bitmap_flags_f) with @code(0) for
the @code(flags) parameter.

@bold(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register
your own format handler.
@return(@nil on error. The file remains open afterwards.)
@seealso(al_load_bitmap_flags_f) @seealso(al_load_bitmap)
@seealso(al_register_bitmap_loader_f) @seealso(al_init_image_addon)
#Allegro5.al_load_bitmap_flags_f
Loads an image from an @link(ALLEGRO_FILEptr) stream into a new
@link(ALLEGRO_BITMAPptr). The file type is determined by the passed
@code(ident) parameter, which is a file name extension including the leading
dot. If (and only if) @code(ident) is @nil, the file type is determined with
@link(al_identify_bitmap_f) instead.

The @code(flags) parameter is the same as for @link(al_load_bitmap_flags).

@bold(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register
your own format handler.
@return(@nil on error. The file remains open afterwards.)
@seealso(al_load_bitmap_f) @seealso(al_load_bitmap_flags)
#Allegro5.al_save_bitmap
Saves an @code(ALLEGRO_BITMAP) to an image file. The file type is determined by
the extension.

@bold(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register your
own format handler.
@return(@true on success, @false on error.)
@seealso(al_save_bitmap_f) @seealso(al_register_bitmap_saver)
@seealso(al_init_image_addon)
#Allegro5.al_save_bitmap_f
Saves an ALLEGRO_BITMAP to an ALLEGRO_FILE stream. The file type is
determined by the passed @code(ident) parameter, which is a file name
extension including the leading dot.

@bold(Note:) the core Allegro library does not support any image file
formats by default. You must use the @link(al5image) addon, or register your
own format handler.
@return(@true on success, @false on error.)
@seealso(al_save_bitmap) @seealso(al_register_bitmap_saver_f)
@seealso(al_init_image_addon)
#Allegro5.al_identify_bitmap_f
Tries to guess the bitmap file type of the given file by reading the first
few bytes. The extension, if any, of the passed filename is not taken into
account - only the file contents. By default Allegro cannot recognize any
file types, but calling @link(al_init_image_addon) will add detection of
(some of) the types it can read.
@returns(a pointer to a static string with a file extension for the type,
including the leading dot. For example ".png" or ".jpg". Returns @nil if the
bitmap type cannot be determined.)
@seealso(al_init_image_addon) @seealso(al_identify_bitmap)
@seealso(al_register_bitmap_identifier)
#Allegro5.al_identify_bitmap
This works exactly as @link(al_identify_bitmap_f) but you specify the
filename of the file for which to detect the type and not a file handle. The
extension, if any, of the passed filename is not taken into account - only
the file contents.
@returns(a pointer to a static string with a file extension for the type,
including the leading dot. For example ".png" or ".jpg". Returns @nil if the
bitmap type cannot be determined.)
@seealso(al_init_image_addon) @seealso(al_identify_bitmap_f)
@seealso(al_register_bitmap_identifier)
